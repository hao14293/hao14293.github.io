<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flask 简单实现注册登陆]]></title>
    <url>%2Fyear%2F10%2F07%2F62999%2F</url>
    <content type="text"><![CDATA[注册登录是web交互最基本的功能，简单介绍下最最基本的注册登录，后面会不断补充完善。 这个功能确实很简单，但一定不能眼高手低。当你真正动手去写的时候会发现很多问题。下面列一下需要注意的点: 数据库路径, 我是Linux下的sqlite3，有三个 / 数据库类怎么定义 路由和 HTTP 请求 db.create_all() 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#-*-coding:utf-8 -*-from flask import Flask, url_for, render_template,redirect, request, flash, sessionfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)db = SQLAlchemy(app)app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.sqlite3'app.config['SECRET_KEY'] = 'random string'class users(db.Model): id = db.Column('user_id',db.Integer,primary_key=True) name = db.Column(db.String(100)) password = db.Column(db.String(100)) def __init__(self, name, password): self.name = name self.password = password@app.route('/', methods=['GET', 'POST'])@app.route('/login', methods=['GET','POST'])def login(): if request.method == 'GET': return render_template('login.html') else: user = users.query.filter(users.name == request.form['name']).first() if user: if request.form['password'] == user.password: return render_template('success.html',name=request.form['name']) else: return '密码错误' return render_template('login.html') else: return '该用户未注册' return render_template('login.html')@app.route('/regist', methods=['GET','POST'])def regist(): if request.method == 'GET': return render_template('regist.html') else: if not request.form['name'] or not request.form['password']: return '不能为空 ' else: user = users(request.form['name'], request.form['password']) db.session.add(user) db.session.commit() return 'successfully!' return redirect(url_for('login'))if __name__ == '__main__': db.create_all() app.run(debug=True) 12345678910111213141516171819# login.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Log in&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Login&lt;/h1&gt;&lt;form action="" method="post"&gt; &lt;label for="name"&gt;name&lt;/label&gt;&lt;br&gt; &lt;input type="text" name="name" placeholder="username"&gt;&lt;br&gt; &lt;label for="password"&gt;password&lt;/label&gt;&lt;br&gt; &lt;input type="password" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="login"&gt;&lt;/form&gt;&lt;h3&gt;&lt;a href="&#123;&#123; url_for('regist') &#125;&#125;"&gt;Regist&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718# regist.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Regist&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Regist&lt;/h1&gt;&lt;form action="" method="post"&gt; &lt;label for="name"&gt;name&lt;/label&gt;&lt;br&gt; &lt;input type="text" name="name" placeholder="username"&gt;&lt;br&gt; &lt;label for="password"&gt;password&lt;/label&gt;&lt;br&gt; &lt;input type="password" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="Regist"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112# success.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Success&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Successful, &#123;&#123; name &#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask实践:猜数字]]></title>
    <url>%2Fyear%2F10%2F05%2F44678%2F</url>
    <content type="text"><![CDATA[每个学编程的人大概都写过猜数字游戏，今天我们用Flask来做一个Web版本的猜数字。功能很简单，只有两个路由，三个模板和一个表单组成。 项目结构1234567|-GuesstheNumber 项目名称 |-app.py |-templates/ 模板文件夹 |-index.html |-guess.html |-base.html 基模板 |-venv/ 虚拟环境 实现代码app.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#-*- coding:UTF-8 -*-import randomfrom flask import Flask, render_template, flash, redirect, url_for, sessionfrom flask_wtf import Formfrom wtforms import IntegerField, SubmitFieldfrom wtforms.validators import DataRequired, NumberRangefrom flask_bootstrap import Bootstrapimport sysapp = Flask(__name__)app.config['SECRET_KEY'] = 'very hadr to guess string' #设置secret keybootstrap = Bootstrap(app) #初始化Flask-bootstrap扩展# 设置编码if sys.getdefaultencoding() != 'utf-8': reload(sys) sys.setdefaultencoding('utf-8')@app.route('/')def index(): # 生成一个0~1000的随机数，存储到session变量中 session['number'] = random.randint(0,1000) session['times'] = 10 return render_template('index.html')@app.route('/guess', methods=['GET', 'POST'])def guess(): times = session['times'] #从session变量中获取次数 result = session.get('number') #从session变量中获取随机生成的数字 form = GuessNumberForm() if form.validate_on_submit(): times -= 1 session['times'] = times if times &lt; 0: flash('你输了...o(&gt;_&lt;)o') return redirect(url_for('index')) answer = form.number.data if answer &gt; result: flash('太大了！你还剩%s次机会' % times) elif answer &lt; result: flash('太小了！你还剩%s次机会' % times) else: flash('啊哈，你赢了！V(^-^)V') return redirect(url_for('index')) return redirect(url_for('guess')) return render_template('guess.html', form=form)class GuessNumberForm(Form): number = IntegerField('输入数字(0~1000):', validators=[DataRequired('输入一个有效的数字！'), NumberRange(0,1000, '请输入0~1000以内的数字！')]) submit = SubmitField('提交')if __name__ == '__main__': app.run() index.html123456&#123;% extends "base.html" %&#125;&#123;% block page_content %&#125;&lt;!-- 传入url_for的参数是视图函数的名称 --&gt;&lt;a class="btn btn-success btn-lg" href="&#123;&#123; url_for('guess') &#125;&#125;"&gt;开始游戏&lt;/a&gt;&#123;% endblock %&#125; guess.html12345678&#123;% extends "base.html" %&#125; &lt;!-- 引入基模板 --&gt;&#123;% import "bootstrap/wtf.html" as wtf %&#125;&#123;% block page_content %&#125; &lt;!-- 使用Flask-Bootstrap提供的函数来生成默认样式的表单 --&gt; &#123;&#123; wtf.quick_form(form) &#125;&#125;&#123;% endblock %&#125; 源码: github]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中的 if __name__ == __main__ 该如何理解]]></title>
    <url>%2Fyear%2F10%2F05%2F17089%2F</url>
    <content type="text"><![CDATA[这个问题来自于知乎用户的提问，当时看到这个问题，我只是做了下简单的回答。后来我发现，对于很多人来说，更准确的说应该是大部分的 Python 初学者，对这个问题理解的不是很深刻。所以这里我来做下总结，并试图把这个问题说明白。 程序入口 对于很多编程语言来说，程序都必须要有一个入口，比如 C，C++，以及完全面向对象的编程语言 Java，C# 等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C 和 C++ 都需要有一个 main 函数来作为程序的入口，也就是程序的运行会从 main 函数开始。同样，Java 和 C# 必须要有一个包含 Main 方法的主类来作为程序入口。 而 Python 则有不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。 一个 Python 源码文件除了可以被直接运行外，还可以作为模块（也就是库）被导入。不管是导入还是直接运行，最顶层的代码都会被运行（Python 用缩进来区分代码层次）。而实际上在导入的时候，有一部分代码我们是不希望被运行的。 举一个例子来说明一下，假设我们有一个 const.py 文件，内容如下：123456PI = 3.14def main(): print "PI:", PImain() 我们在这个文件里边定义了一些常量，然后又写了一个 main 函数来输出定义的常量，最后运行 main 函数就相当于对定义做一遍人工检查，看看值设置的都对不对。然后我们直接执行该文件(python const.py),输出：1PI: 3.14 现在，我们有一个 area.py 文件，用于计算圆的面积，该文件里边需要用到 const.py 文件中的 PI 变量，那么我们从 const.py 中把 PI 变量导入到 area.py 中：123456789from const import PIdef calc_round_area(radius): return PI * (radius ** 2)def main(): print "round area: ", calc_round_area(2)main() 运行 area.py，输出结果：12PI: 3.14round area: 12.56 可以看到，const 中的 main 函数也被运行了，实际上我们是不希望它被运行，提供 main 也只是为了对常量定义进行下测试。这时，if _name__ == ‘__main__’ 就派上了用场。把 const.py 改一下：1234567PI = 3.14def main(): print "PI:", PIif __name__ == "__main__": main() 然后再运行 area.py，输出如下：1round area: 12.56 再运行下 const.py，输出如下：1PI: 3.14 这才是我们想要的效果。 if __name__ == ‘_main__’ 就相当于是 Python 模拟的程序入口。Python 本身并没有规定这么写，这只是一种编码习惯。由于模块之间相互引用，不同模块可能都有这样的定义，而入口程序只能有一个。到底哪个入口程序被选中，这取决于 __name__的值。 __name____name__ 是内置变量，用于表示当前模块的名字，同时还能反映一个包的结构。来举个例子，假设有如下一个包：12345a├── b│ ├── c.py│ └── __init__.py└── __init__.py 目录中所有 py 文件的内容都为：1print __name__ 我们执行 python -c “import a.b.c”，输出结果：123aa.ba.b.c 由此可见，__name__ 可以清晰的反映一个模块在包中的层次。其实，所谓模块名就是 import 时需要用到的名字，例如：12import tornadoimport tornado.web 这里的 tornado 和 tornado.web 就被称为模块的模块名。 如果一个模块被直接运行，则其没有包结构，其 __name__ 值为 __main__。例如在上例中，我们直接运行 c.py 文件（python a/b/c.py），输出结果如下：1__main__ 所以，if name == ‘main‘ 我们简单的理解就是： 如果模块是被直接运行的，则代码块被运行，如果模块是被导入的，则代码块不被运行。 实际上，这个问题还可以衍生出其他的一些知识点，例如 main.py 文件与 Python 的 -m 参数。 __main__.py 文件与 python -mPython 的 -m 参数用于将一个模块或者包作为一个脚本运行，而 __main__.py 文件则相当于是一个包的”入口程序“。 首先我们需要来看看 python xxx.py 与 python -m xxx.py 的区别。两种运行 Python 程序的方式的不同点在于，一种是直接运行，一种是当做模块来运行。 先来看一个简单的例子，假设有一个 Python 文件 run.py，其内容如下：12import sysprint sys.path 我们用直接运行的方式启动（python run.py），输出结果(为了说明问题，输出结果只截取了重要部分，下同)：1['/home/huoty/aboutme/pythonstudy/main', ...] 然后以模块的方式运行（python -m run.py）:12['', ...]/usr/bin/python: No module named run.py 由于输出结果只列出了关键的部分，应该很容易看出他们之间的差异。直接运行是把 run.py 文件所在的目录放到了 sys.path 属性中。以模块方式运行是把你输入命令的目录（也就是当前工作路径），放到了 sys.path 属性中。以模块方式运行还有一个不同的地方是，多出了一行 No module named run.py 的错误。实际上以模块方式运行时，Python 先对 run.py 执行一遍 import，所以 print sys.path 被成功执行，然后 Python 才尝试运行 run.py 模块，但是，在 path 变量中并没有 run.py 这个模块，所以报错。而正确的运行方式，应该是 python -m run. 这个例子并不能明显的说明问题。接着我们来看看 __main__.py 的作用。 仍然先看例子，有如下一个包：123package├── __init__.py└── __main__.py __init__.py 123import sysprint "__init__"print sys.path __main__.py 123import sysprint "__main__"print sys.path 用 python -m package 运行结果：1234__init__['', ...]__main__['', ...] 用 python package 运行结果：12__main__['package', ...] 然后我们来总结一下： 1、 加上 -m 参数时会把当前工作目录添加到 sys.path 中，而不加时则会把脚本所在目录添加到 sys.path 中。 2、 加上 -m 参数时 Python 会先将模块或者包导入，然后再执行 3、 _main__.py 文件是一个包或者目录的入口程序。不管是用 python package 还是用 python -m package 运行时， __main__.py 文件总是被执行。 后序我试图使用长篇大论来阐述，在 Python 中如何理解 if _name__ == ‘__main__’ 这个问题，不知道我有没有描述得足够的明白。Python 的确是简单的，优雅的，但也有很多问题是不太容易理解的，例如很多高级的特性，像元类、生成器表达式、描述符、协程等。Python 并没有在太多的地方规定要如何如何，很多的用法只是惯用法，例如 self 和本文讨论的内容。这些用法或是为了让代码看起来更优雅，或是前人的经验。使用 Python 是有无限可能的，你可以写出很多简洁优雅的代码。 转自 http://blog.konghy.cn/2017/04/24/python-entry-program/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈位运算]]></title>
    <url>%2Fyear%2F10%2F03%2F61788%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JS元素大小]]></title>
    <url>%2Fyear%2F08%2F08%2F28779%2F</url>
    <content type="text"><![CDATA[很多行为用到了，很重要。 偏移量(offset dimension)元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（不包括外边距）。通过下列4个属性可以取得元素的偏移量. offsetHeight: 元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。 offsetWidth: 元素在水平方向上占用的空间大小，，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。 offsetLeft: 元素的左外边框至包含元素的左内边框之间的像素距离。 offsetTop: 元素的上外边框至包含元素的上内边框之间的像素距离。 其中，offsetLeft 和 offsetTop 属性与包含元素有关。包含元素的引用保存在 offsetParent属性中。offsetParent属性不一定与parentNode的值相等。通过几个实例测试来理解一下:123456789101112131415161718192021222324252627282930&lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; width: 100%; height: 100%; &#125; #myDiv&#123; width: 500px; height: 800px; margin: 0 auto; background: #ebebeb; &#125; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="myDiv" &gt;&lt;/div&gt; &lt;script&gt; var element = document.getElementById('myDiv'); console.log(element.offsetHeight); console.log(element.offsetHeight); console.log(element.offsetLeft); console.log(element.offsetTop); &lt;/script&gt;&lt;/body&gt; element.offsetHeight 和 element.offsetHeight 很好理解，就是元素的宽高，element.offsetLeft和element.offsetTop就是元素的外边框到父元素的内边框之间的距离。 所有这些偏移量属性都是只读的。 客户区大小(client dimension)元素的客户区大小，指的是元素内容及其内边距所占据的空间大小。有关属性有两个: clientWidth和 clientHeight。这个就很好理解了。 滚动大小 (scroll dimension)滚动大小，指的是包含滚动内容的元素的大小。有些元素（例如 html），即使没有执行任何代码也能自动地添加滚动条;但另外一些元素，则需要通过 CSS 的 overflow属性进行设置才能滚动。以下是四个与滚动大小相关的属性。 scrollHeight: 在没有滚动条的情况下，元素内容的总高度。 scrollWidth: 在没有滚动条的情况下，元素内容的总宽度。 scrollLeft: 被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。 scrollTop: 被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 scrollWidth和 scrollHeight 主要用于确定元素内容的实际大小。例如，通常认为 html 元素是在 Web 浏览器的视口中滚动的元素。因此，带有垂直滚动条的页面总高度就是 document.documentElement.scrollHeight 测试发现， scrollHeight、scrollWidth和 clientHeight、clientWidth 相等。 在确定文档的总高度时，必须取得scrollWidth/clientWidth 和 scrollHeight/clientHeight中的最大值，才能保证在跨浏览器的环境下得到精确的结果。12345var docHeight = Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight);var docWidth = Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth); 通过scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。在元素尚未滚动时，这两个属性的值都等于0.如果元素被垂直滚动了，那么 scrollTop的值会大于0,且表示元素上方不可见内容的像素高度。scrollLeft同理。这两个属性都是可以设置的，因此将元素的 scrollLeft和scrollTop设为0 ，就可以重置元素的滚动位置。 这几个属性在很多地方都会用到。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS3 渐变]]></title>
    <url>%2Fyear%2F08%2F05%2F35788%2F</url>
    <content type="text"><![CDATA[CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。 以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的事件和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。 CSS3 定义了两种类型的渐变（gradients）： 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向 径向渐变（Radial Gradients）- 由它们的中心定义 CSS3 线性渐变为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。语法1background: linear-gradient(direction, color-stop1, color-stop2, ...); 线性渐变 - 从上到下（默认情况下）下面的实例演示了从顶部开始的线性渐变。起点是红色，慢慢过渡到蓝色：12345678# 从上到下的线性渐变：.grad &#123; background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, blue); /* 标准的语法 */&#125; 线性渐变 - 从左到右下面的实例演示了从左边开始的线性渐变。起点是红色，慢慢过渡到蓝色：12345678# 从左到右的线性渐变：.grad &#123; background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to right, red , blue); /* 标准的语法 */&#125; 线性渐变 - 对角你可以通过指定水平和垂直的起始位置来制作一个对角渐变。 下面的实例演示了从左上角开始（到右下角）的线性渐变。起点是红色，慢慢过渡到蓝色：12345678# 从左上角到右下角的线性渐变：.grad &#123; background: -webkit-linear-gradient(left top, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(bottom right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to bottom right, red , blue); /* 标准的语法 */&#125; 使用角度如果你想要在渐变的方向上做更多的控制，你可以定义一个角度，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）。 语法1background: linear-gradient(angle, color-stop1, color-stop2); 角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。但是，请注意很多浏览器(Chrome,Safari,fiefox等)的使用了旧的标准，即 0deg 将创建一个从左到右的渐变，90deg 将创建一个从下到上的渐变。换算公式 90 - x = y 其中 x 为标准角度，y为非标准角度。 带有指定的角度的线性渐变：123456.grad &#123; background: -webkit-linear-gradient(180deg, red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(180deg, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(180deg, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(180deg, red, blue); /* 标准的语法 */&#125; 使用多个颜色结点12345678# 带有多个颜色结点的从上到下的线性渐变：.grad &#123; background: -webkit-linear-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, green, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, green, blue); /* 标准的语法 */&#125; 下面的实例演示了如何创建一个带有彩虹颜色和文本的线性渐变：12345678910#grad &#123; /* Safari 5.1 - 6.0 */ background: -webkit-linear-gradient(left,red,orange,yellow,green,blue,indigo,violet); /* Opera 11.1 - 12.0 */ background: -o-linear-gradient(left,red,orange,yellow,green,blue,indigo,violet); /* Firefox 3.6 - 15 */ background: -moz-linear-gradient(left,red,orange,yellow,green,blue,indigo,violet); /* 标准的语法 */ background: linear-gradient(to right, red,orange,yellow,green,blue,indigo,violet); &#125; 使用透明度（transparent）CSS3 渐变也支持透明度（transparent），可用于创建减弱变淡的效果。 为了添加透明度，我们使用 rgba() 函数来定义颜色结点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。 下面的实例演示了从左边开始的线性渐变。起点是完全透明，慢慢过渡到完全不透明的红色：12345678# 从左到右的线性渐变，带有透明度：.grad &#123; background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); /* Safari 5.1 - 6 */ background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Opera 11.1 - 12*/ background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Firefox 3.6 - 15*/ background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法 */&#125; 重复的线性渐变repeating-linear-gradient() 函数用于重复线性渐变：123456789101112# 一个重复的线性渐变：.grad &#123; /* Safari 5.1 - 6.0 */ background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%); /* Opera 11.1 - 12.0 */ background: -o-repeating-linear-gradient(red, yellow 10%, green 20%); /* Firefox 3.6 - 15 */ background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%); /* 标准的语法 */ background: repeating-linear-gradient(red, yellow 10%, green 20%);&#125; CSS3 径向渐变径向渐变由它的中心定义。 为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。径向渐变的实例：语法1background: radial-gradient(center, shape size, start-color, ..., last-color); 径向渐变 - 颜色结点均匀分布（默认情况下）12345678# 颜色结点均匀分布的径向渐变：.grad &#123; background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: radial-gradient(red, green, blue); /* 标准的语法 */&#125; 径向渐变 - 颜色结点不均匀分布12345678# 颜色结点不均匀分布的径向渐变：#grad &#123; background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */ background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */&#125; 设置形状shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。 12345678# 形状为圆形的径向渐变：.grad &#123; background: -webkit-radial-gradient(circle, red, yellow, green); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(circle, red, yellow, green); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(circle, red, yellow, green); /* Firefox 3.6 - 15 */ background: radial-gradient(circle, red, yellow, green); /* 标准的语法 */&#125; 不同尺寸大小关键字的使用size 参数定义了渐变的大小。它可以是以下四个值： closest-side farthest-side closest-corner farthest-corner 1234567891011121314151617181920212223# 带有不同尺寸大小关键字的径向渐变：.grad1 &#123; /* Safari 5.1 - 6.0 */ background: -webkit-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); /* Opera 11.6 - 12.0 */ background: -o-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); /* Firefox 3.6 - 15 */ background: -moz-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); /* 标准的语法 */ background: radial-gradient(60% 55%, closest-side,blue,green,yellow,black);&#125; .grad2 &#123; /* Safari 5.1 - 6.0 */ background: -webkit-radial-gradient(60% 55%, farthest-side,blue,green,yellow,black); /* Opera 11.6 - 12.0 */ background: -o-radial-gradient(60% 55%, farthest-side,blue,green,yellow,black); /* Firefox 3.6 - 15 */ background: -moz-radial-gradient(60% 55%, farthest-side,blue,green,yellow,black); /* 标准的语法 */ background: radial-gradient(60% 55%, farthest-side,blue,green,yellow,black);&#125; 重复的径向渐变repeating-radial-gradient() 函数用于重复径向渐变： 123456789101112# 一个重复的径向渐变：.grad &#123; /* Safari 5.1 - 6.0 */ background: -webkit-repeating-radial-gradient(red, yellow 10%, green 15%); /* Opera 11.6 - 12.0 */ background: -o-repeating-radial-gradient(red, yellow 10%, green 15%); /* Firefox 3.6 - 15 */ background: -moz-repeating-radial-gradient(red, yellow 10%, green 15%); /* 标准的语法 */ background: repeating-radial-gradient(red, yellow 10%, green 15%);&#125; 浏览器支持表中的数字指定了完全支持该属性的第一个浏览器版本。 后边跟 -webkit-、-moz- 或 -o- 的数字指定了需加上前缀才能支持属性的第一个版本。 参考 http://www.runoob.com/css3/css3-gradients.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS倒影 box-reflect]]></title>
    <url>%2Fyear%2F08%2F04%2F8479%2F</url>
    <content type="text"><![CDATA[CSS 图片倒影，还未包含进CSS3官方标准中。 基本语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253语法：box-reflect：none | &lt;direction&gt; &lt;offset&gt;? &lt;mask-box-image&gt;?&lt;direction&gt; = above | below | left | right&lt;offset&gt; = &lt;length&gt; | &lt;percentage&gt;&lt;mask-box-image&gt; = none | &lt;url&gt; | &lt;linear-gradient&gt; | &lt;radial-gradient&gt; | &lt;repeating-linear-gradient&gt; | &lt;repeating-radial-gradient&gt;默认值：none适用于：所有元素继承性：无动画性：否计算值：指定值取值：none：无倒影&lt;direction&gt; Demo: 简单图片倒影 See with Webkitabove：指定倒影在对象的上边below：指定倒影在对象的下边left：指定倒影在对象的左边right：指定倒影在对象的右边&lt;offset&gt; Demo: 图片与倒影间隔 See with Webkit&lt;length&gt;：用长度值来定义倒影与对象之间的间隔。可以为负值&lt;percentage&gt;：用百分比来定义倒影与对象之间的间隔。可以为负值&lt;mask-box-image&gt; Demo: 更真实的图片倒影 文字倒影与渐变 See with Webkitnone：无遮罩图像&lt;url&gt;：使用绝对或相对地址指定遮罩图像。&lt;linear-gradient&gt;：使用线性渐变创建遮罩图像。&lt;radial-gradient&gt;：使用径向(放射性)渐变创建遮罩图像。&lt;repeating-linear-gradient&gt;：使用重复的线性渐变创建背遮罩像。&lt;repeating-radial-gradient&gt;：使用重复的径向(放射性)渐变创建遮罩图像。说明：设置或检索对象倒影。假设定义了 &lt;mask-box-image&gt;，&lt;offset&gt;必须指定，否则可以省略对应的脚本特性为boxReflect。 来看一下实际用法：123img&#123; -webkit-box-reflect: blow;&#125; 上面这个例子中倒影出现了图片的下方，但实际上我们也可以将倒影安置在左侧、右侧或上侧。只需要相应地设置 above/right/left/blow。 倒影偏移量Offset属性值用来定义图片和倒影影像之间的间距。参考下面的代码：123img&#123; -webkit-box-reflect: blow 10px;&#125; 给倒影增加消隐效果在现实生活中，倒影的出现通常是上半部比较清晰，下面半部逐渐消隐。为了在CSS中实现这种效果，我们需要运用CSS3渐变色(Gradients)功能，就像下面这样：123456789img&#123; -webkit-box-reflect: below 0px -webkit-gradient( linear, left top, left bottom, from(transparent), to( rgba(250,250,250,.1) );&#125; 这段代码就能达到这样的效果： 我们还可以使用color-stop来控制色彩过渡，让倒影更加漂亮： 12345678910img&#123; -webkit-box-reflect: below 0px -webkit-gradient( linear, left top, left bottom, from(transparent), color-stop(70%, transparent), to(rgba(250,250,250,.1) );&#125; 火狐浏览器中倒影的实现目前只有Webkit浏览器(谷歌浏览器和Safari浏览器)实现box-reflect属性。为了在火狐浏览器中也实现倒影功能，我们需要寻找另外的途径：使用-moz-element()方法。这个方法能够复制指定网页元素的内容。让我们来看看下面的例子： 我们把图片包裹着一个ID是someid的里。 并且，为了存放倒影影像，我们将使用:before伪元素，就像下面：12345678910111213141516#someid &#123;position: relative;/* 给倒影留下空间 */margin-bottom: 120px;&#125;#someid:before &#123;content:""; /* needed or nothing will be shown */background: -moz-linear-gradient(top, white, white 30%, rgba(255,255,255,0.9) 65%, rgba(255,255,255,0.7)) 0px 0px,-moz-element(#someid) 0px -127px no-repeat;-moz-transform: scaleY(-1); /* flip the image vertically */position:relative;height:140px;width: 360px; /* 需要 &gt; image width + margin + shadow */top: 247px;left:0px;&#125; 这里的-moz-transform是一个负值，作用就是让复制过来的图形上下颠倒，达到倒影的效果。为了让:before伪元素跟原始图形相配合，我们需要移动它的位置。这里的背景偏移量 (-127px)是:before伪元素高，(140px) – (图片的高 (247px) + div的border (20px))。需要注意的是，火狐浏览器版的倒影实现只能用在页面的背景是真实背景。背景色要和:before伪元素使用的渐变色的颜色一致。 因为所有的属性都是来实现倒影的，而且这些属性都有火狐浏览器独有的前缀，和-Webkit的倒影不冲突，所以在代码在可以把两个版本倒影方法都写上，保证两种浏览器里都有效果。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 746. 使用最小花费爬楼梯(Python)]]></title>
    <url>%2Fyear%2F08%2F04%2F54393%2F</url>
    <content type="text"><![CDATA[746.使用最小花费爬楼梯 数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 思路：动态规划求到达每一阶的最小成本。倒数第一和倒数第二的最小值即为解。 我是这么考虑的：把问题缩小，只有两种办法到达第i阶，一种是i-2阶走两步到达，一种是i-1阶走一步到达。因此到达台阶i的花费即为两种方法中代价最小的。表示为：cost[i] = min(cost[i-2]+cost[i],cost[i-1]+cost[i]). 动态规划核心就是找到最优子结构，然后自上而下或者自底向上求解问题。如果对时间复杂度有要求的话，最好选择递推，相对递归来说效率高。 两种算法，一种通俗易懂，一种比较秀，原理一样。123456789101112class Solution(object): def minCostClimbingStairs(self, cost): """ :type cost: List[int] :rtype: int """ dp = &#123;&#125; dp[0] = cost[0] dp[1] = cost[1] for i in range(2,len(cost)): dp[i] = min(dp[i-2]+cost[i],dp[i-1]+cost[i]) return min(dp[len(cost)-1],dp[len(cost)-2]) 12345678910class Solution(object): def minCostClimbingStairs(self, cost): """ :type cost: List[int] :rtype: int """ dp = [0] * 3 for i in reversed(xrange(len(cost))): dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3]) return min(dp[0], dp[1])]]></content>
      <categories>
        <category>Algorithm and Data Structur</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setTimeout和setInterval]]></title>
    <url>%2Fyear%2F08%2F04%2F59283%2F</url>
    <content type="text"><![CDATA[简单来说，一个是过一段时间执行某个任务，然后就没然后了;一个是每隔一段时间执行一下某个任务。 看似很简单的两个概念，其实用途很广。下面就举两个刚学的例子。 延迟切换菜单栏 (setTimeout)123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;function $(id) &#123; return typeof id==='string'?document.getElementById(id):id; &#125;window.onload=function () &#123; // 标签的索引 var index=0; var timer=null; //定时器 var lis=$('notice-tit').getElementsByTagName('li'), divs=$('notice-con').getElementsByTagName('div'); if(lis.length!=divs.length) return; for(var i=0;i&lt;lis.length;i++)&#123; lis[i].id=i; lis[i].onmouseover=function () &#123; var that=this; //如果存在尊卑执行的定时器，立刻清除，只有当前时间大于500ms才开始执行 if(timer)&#123; clearTimeout(timer); timer=null; &#125; //延迟500ms timer=setTimeout(function () &#123; for(var j=0;j&lt;lis.length;j++)&#123; lis[j].className=''; divs[j].style.display='none'; &#125; lis[that.id].className='select'; divs[that.id].style.display='block'; &#125;,500); &#125; &#125; &#125; &lt;/script&gt; 图片自动循环切换 (setInterval)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script type="text/javascript"&gt; window.onload=function()&#123; var wrap=document.getElementById('wrap'), pic=document.getElementById('pic'), list=document.getElementById('list').getElementsByTagName('li'), index=0, timer=null; var imgs=pic.getElementsByTagName("li"); // 定义并调用自动播放函数 // 定义图片切换函数 // 鼠标划过整个容器时停止自动播放 // 鼠标离开整个容器时继续播放至下一张 // 遍历所有数字导航实现划过切换至对应的图片 if(imgs.length=list.length)&#123; for(var i=0;i&lt;list.length;i++)&#123; list[i].id=i; list[i].onmouseover=function()&#123; qiehuan(this.id); &#125; &#125; &#125; wrap.onmouseover=function()&#123; clearInterval(timer); &#125; wrap.onmouseout=function()&#123; timer=setInterval(play,2000); &#125; if(timer)&#123; clearInterval(timer); timer=null; &#125; timer=setInterval(play,2000); //自动切换函数 function play()&#123; index++; if(index&gt;=list.length)&#123; index=0; &#125; qiehuan(index); &#125; function qiehuan(curindex)&#123; for(var j=0;j&lt;imgs.length;j++)&#123; list[j].className=""; imgs[j].style.display="none"; &#125; list[curindex].className="on"; imgs[curindex].style.display="block"; index=curindex; &#125; &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 720. 词典中最长的单词(Python)]]></title>
    <url>%2Fyear%2F08%2F04%2F40533%2F</url>
    <content type="text"><![CDATA[LeetCode 720. 词典中最长的单词 给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。 若无答案，则返回空字符串。 示例 1: 输入: words = ["w","wo","wor","worl", "world"] 输出: "world" 解释: 单词"world"可由"w", "wo", "wor", 和 "worl"添加一个字母组成。 示例 2: 输入: words = ["a", "banana", "app", "appl", "ap", "apply", "apple"] 输出: "apple" 解释: "apply"和"apple"都能由词典中的单词组成。但是"apple"得字典序小于"apply"。 注意: 所有输入的字符串都只包含小写字母。 words数组长度范围为[1,1000]。 words[i]的长度范围为[1,30]。 先来个最简单，最暴力的解法 方法一巧妙用了set（）,判断每个单词的除去倒数第一个字母是否在set里，用一个变量保存最长的单词。 用判断新单词是否比最长单词更长的方式完成两个需求：1.找出最长；2.同样最长的情况下，保留字母序最小的。这样做的前提是先对words进行排序。 123456789101112131415class Solution(object): def longestWord(self, words): """ :type words: List[str] :rtype: str """ words.sort() res = set(['']) longestWord = '' for word in words: if word[:-1] in res: res.add(word) if len(word) &gt; len(longestWord): longestWord = word return longestWord 这个set用的妙，这种方法学习一下。]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中各种width/height]]></title>
    <url>%2Fyear%2F08%2F03%2F25026%2F</url>
    <content type="text"><![CDATA[对于初学者来说，搞明白这些概念真的痛苦。 窗口位置IE、Safari、Opera 和 Chrome 都提供了 screenLeft 和 screenTop属性，分别用于表示窗口相对于屏幕左边和上边的位置。 Firefox 则在 screenX 和 screenY 属性中提供了相同的窗口位置信息， Safari 和 Chrome 也同时支持这两种属性。Opera 虽然也支持 screenX 和 screenY ，但与 screenLeft 和 screenTop属性并不对应，因此建议大家不要在Opera 中使用它们。 使用下列代码可以跨浏览器取得窗口左边和上边的位置。 12var leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY; 嗯，书上就这么写的，什么意思呢？ 下面实际测试一下。 123456# Chrome 浏览器var leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY;console.log(leftPos);console.log(topPos); 结果如图这个时候我浏览器是全屏的，我是Ubuntu 系统，和Mac系统一样，屏幕顶部会有状态条，所以 0 24就是指当前浏览器窗口最左边和最上边距离电脑屏幕左边框的上边框的距离。那，浏览器不全屏呢？这时候浏览器没有全屏， 结果就变了，所以 screenLeft 和 screenTop属性就是当前浏览器窗口最左边和最上边距离电脑屏幕左边框的上边框的距离。 在使用这些值的时候，还必须注意一些小问题。在 IE、Opera中，screenLeft 和 screenTop中保存的是从屏幕左边和上边到由 window 对象表示的页面可见区域的距离。 但是在 Chrome、Firefox和 Safari中， screenY或screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y轴坐标为0时返回0. 更让人捉摸不透是，Firefox、Safari和Chrome 始终返回页面中每个框架的 top.screenX 和 top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于 window 对象使用 screenX 和 screenY 每次也都会返回相同的值。而IE 和 Opera 则会给出框架相对于屏幕边界的精确坐标值。 窗口大小接下来进入重点啦。IE9+、Firefox、Safari、Opera 和 Chrome 均提供了4个属性： innerwidth、innerHeight、outerWidth、outerHeight。在IE9+、Safari、Firefox中，outerWidth、outerHeight返回浏览器窗口本身的尺寸（无论是从最外层的 window 对象还是从某个框架访问）。在 Opera 中，这两个属性的值表示页面视图容器的大小。 而innerwidth、innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。在Chrome 中，outerWidth、outerHeight与 innerwidth、innerHeight返回相同的值，即视口大小而非浏览器窗口大小。在IE、Firefox、Safari、Opera 和 Chrome 中， document.documentElement.clientWidth 和 document.documentElement.clientHeight 中保存了页面视口的信息。在IE6中，这些属性必须在标准模式下才有效;如果是混杂模式，就必须通过 document.body.clientWidth和document.body.clientHeight取得相同信息。而对于混杂模式下的Chrome，则无论通过 document.documentElement 还是 document.body中的 clientWidth和clientHeight属性，都可以取得视口的大小。虽然无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小123456789101112var pageWidth = window.innerWidth, pageHeight = window.innerHeight; if (typeof pageWidth != "number")&#123; if (document.compatMode == "CSS!Compat")&#123; pageWidth = document.documentElement.clientWidth; pageHeight = docuement.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 好啦，看完一脸蒙逼。。。实际测试以下吧。12345# Chrome 先看各种 widthconsole.log(window.innerWidth);console.log(window.outerWidth);console.log(document.documentElement.clientWidth);console.log(document.body.clientWidth); 结果再看看不是全屏状态document.documentElement.clientWidth与document.body.clientWidth始终相等，都比window少一个滚动条宽度。但是 window.innerWidth与 window.outerWidth为什么不相同了呢？我们再看一种情况，我把控制台放在右侧(刚才两种情况都在底部)，调整控制台宽度，再看一下这下应该能看明白了吧，innerWidth是指可视窗口宽度，outerWidth指浏览器窗口宽度。document.documentElement.clientWidth与document.body.clientWidth指可视窗口宽度减去滚动条宽度。那刚才控制台在底部时，window.innerWidth与 window.outerWidth为什么不相同了呢？这是因为浏览器没有全屏时左右会有边框，这一部分不是可视窗口。 那 Height呢？测试一下。12345# chromeconsole.log(window.innerHeight); console.log(window.outerHeight); console.log(document.documentElement.clientHeight); console.log(document.body.clientHeight); 需要注意的是，此时没有放任何元素961 是可视区域高度， 1056是浏览器窗口高度。 我们再看种情况，此时&lt;body&gt;中 放一个 div,设置以下样式1234567.scrolldiv&#123; width: 500px; height: 400px; border: 0; margin: 1000px auto 100px auto; background-color: #FF0000; &#125; 我们再看一下各种高度 诶，不一样了，可以得出以下结论 window.innerHeight与 window.outerHeight 分别表示 可视区域和浏览器窗口高度，document.documentElement.clientHeight表示整个网页的高度(可视区域加上可视区域中目前看不到的高度)，document.body.clientHeight表示可视区域高度。 JS新手，有错误请指出。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python Click 学习笔记]]></title>
    <url>%2Fyear%2F08%2F01%2F36314%2F</url>
    <content type="text"><![CDATA[(原文)Python Click 学习笔记 Click 是 Flask 的团队 pallets 开发的优秀开源项目，它为命令行工具的开发封装了大量方法，使开发者只需要专注于功能实现。恰好我最近在开发的一个小工具需要在命令行环境下操作，就写个学习笔记。 国际惯例，先来一段 “Hello World” 程序（假定已经安装了 Click 包）。1234567891011121314# hello.pyimport click@click.command()@click.option('--count', default=1, help='Number of greetings.')@click.option('--name', prompt='Your name', help='The person to greet.')def hello(count, name): """Simple program that greets NAME for a total of COUNT times.""" for x in range(count): click.echo('Hello %s!' % name)if __name__ == '__main__': hello() 执行 python hello.py –count=3，不难猜到控制台的输出结果。除此之外，Click 还悄悄地做了其他的工作，比如帮助选项： 123456789$ python hello.py --helpUsage: hello.py [OPTIONS] Simple program that greets NAME for a total of COUNT times.Options: --count INTEGER Number of greetings. --name TEXT The person to greet. --help Show this message and exit. 函数秒变 CLI从上面的 “Hello World” 演示中可以看出，Click 是通过装饰器来把一个函数方法装饰成命令行接口的，这个装饰器方法就是 @click.command()。 12345import click@click.command()def hello(): click.echo('Hello World!') @click.command() 装饰器把 hello() 方法变成了 Command 对象，当它被调用时，就会执行该实例内的行为。而 –help 参数就是 Command 对象内置的参数。 不同的 Command 实例可以关联到 group 中。group 下绑定的命令就成为了它的子命令，参考下面的代码： 1234567891011121314@click.group()def cli(): pass@click.command()def initdb(): click.echo('Initialized the database')@click.command()def dropdb(): click.echo('Dropped the database')cli.add_command(initdb)cli.add_command(dropdb) @click.group 装饰器把方法装饰为可以拥有多个子命令的 Group 对象。由 Group.add_command() 方法把 Command 对象关联到 Group 对象。也可以直接用 @Group.command 装饰方法，会自动把方法关联到该 Group 对象下。 1234567891011@click.group()def cli(): pass@cli.command()def initdb(): click.echo('Initialized the database')@cli.command()def dropdb(): click.echo('Dropped the database') 命令行的参数是不可或缺的，Click 支持对 command 方法添加自定义的参数，由 option() 和 argument() 装饰器实现。 123456@click.command()@click.option('--count', default=1, help='number of greetings')@click.argument('name')def hello(count, name): for x in range(count): click.echo('Hello %s!' % name) 打包跨平台可执行程序通过 Click 编写了简单的命令行方法后，还需要把 .py 文件转换成可以在控制台里运行的命令行程序。最简单的办法就是在文件末尾加上如下代码： 12if __name__ == '__main__': command() Click 支持使用 setuptools 来更好的实现命令行程序打包，把源码文件打包成系统中的可执行程序，并且不限平台。一般我们会在源码根目录下创建 setup.py 脚本，先看一段简单的打包代码： 1234567891011121314from setuptools import setupsetup( name='hello', version='0.1', py_modules=['hello'], install_requires=[ 'Click', ], entry_points=''' [console_scripts] hello=hello:cli ''',) 留意 entry_points 字段，在 console_scripts 下，每一行都是一个控制台脚本，等号左边的的是脚本的名称，右边的是 Click 命令的导入路径。 详解命令行参数上面提到了自定义命令行参数的两个装饰器：@click.option() 和 @click.argument()，两者有些许区别，使用场景也有所不同。 总体而言，argument() 装饰器比 option() 功能简单些，后者支持下面的特性： 自动提示缺失的输入； option 参数可以从环境变量中获取，argument 参数则不行； option 参数在 help 输出中有完整的文档，argument 则没有； 而 argument 参数可以接受可变个数的参数值，而 option 参数只能接收固定个数的参数值（默认是 1 个）。 Click 可以设置不同的参数类型，简单类型如 click.STRING，click.INT，click.FLOAT，click.BOOL。 命令行的参数名由 “-short_name” 和 “–long_name” 声明，如果参数名既没有以 “-“ 开头，也没有以 “–” 开头，那么这边变量名会成为被装饰方法的内部变量，而非方法参数。 Option 参数option 最基础的用法就是简单值变量，option 接收一个变量值，下面是一段示例代码： 1234@click.command()@click.option('--n', default=1)def dots(n): click.echo('.' * n) 如果在命令行后面跟随参数 –n=2 就会输出两个点，如果传参数，默认输出一个点。上面的代码中，参数类型没有显示给出，但解释器会认为是 INT 型，因为默认值 1 是 int 值。有些时候需要传入多个值，可以理解为一个 list，option 只支持固定长度的参数值，即设置后必须传入，个数由 nargs 确定。 1234@click.command()@click.option('--pos', nargs=2, type=float)def findme(pos): click.echo('%s / %s' % pos) findme –pos 2.0 3.0 输出结果就是 2.0 / 3.0 既然可以传入 list，那么 tuple 呢？Click 也是支持的： 1234@click.command()@click.option('--item', type=(unicode, int))def putitem(item): click.echo('name=%s id=%d' % item) 这样就传入了一个 tuple 变量，putitem –item peter 1338 得到的输出就是 name=peter id=1338上面没有设置 nargs，因为 nargs 会自动取 tuple 的长度值。因此上面的代码实际上等同于： 1234@click.command()@click.option('--item', nargs=2, type=click.Tuple([unicode, int]))def putitem(item): click.echo('name=%s id=%d' % item) option 还支持同一个参数多次使用，类似 git commit -m aa -m bb 中 -m 参数就传入了 2 次。option 通过 multiple 标识位来支持这一特性： 1234@click.command()@click.option('--message', '-m', multiple=True)def commit(message): click.echo('\n'.join(message)) 有时候，命令行参数是固定的几个值，这时就可以用到 Click.choice 类型来限定传参的潜在值： 12345# choice@click.command()@click.option(&apos;--hash-type&apos;, type=click.Choice([&apos;md5&apos;, &apos;sha1&apos;]))def digest(hash_type): click.echo(hash_type) 当上面的命令行程序参数 –hash-type 不是 md5 或 sha1，就会输出错误提示，并且在 –help 提示中也会对 choice 选项有显示。 如果希望命令行程序能在我们错误输入或漏掉输入的情况下，友好的提示用户，就需要用到 Click 的 prompt 功能，看代码： 12345# prompt@click.command()@click.option('--name', prompt=True)def hello(name): click.echo('Hello %s!' % name) 如果在执行 hello 时没有提供 –name 参数，控制台会提示用户输入该参数。也可以自定义控制台的提示输出，把 prompt 改为自定义内容即可。 对于类似账户密码等参数的输入，就要进行隐藏显示。option 的 hide_input 和 confirmation_promt 标识就是用来控制密码参数的输入： 123456# password@click.command()@click.option('--password', prompt=True, hide_input=True, confirmation_prompt=True)def encrypt(password): click.echo('Encrypting password to %s' % password.encode('rot13')) Click 把上面的操作进一步封装成装饰器 click.password_option()，因此上面的代码也可以简化成： password1234@click.command()@click.password_option()def encrypt(password): click.echo('Encrypting password to %s' % password.encode('rot13')) 有的参数会改变命令行程序的执行，比如 node 是进入 Node 控制台，而 node –verion 是输出 node 的版本号。Click 提供 eager 标识对参数名进行标记，拦截既定的命令行执行流程，而是调用一个回调方法，执行后直接退出。下面模拟 click.version_option() 的功能，实现 –version 参数名输出版本号： 123456789101112# eagerdef print_version(ctx, param, value): if not value or ctx.resilient_parsing: return click.echo('Version 1.0') ctx.exit()@click.command()@click.option('--version', is_flag=True, callback=print_version, expose_value=False, is_eager=True)def hello(): click.echo('Hello World!') 对于类似删除数据库表这样的危险操作，Click 支持弹出确认提示，–yes 标识位置为 True 时会让用户再次确认： 1234567891011# yes parametersdef abort_if_false(ctx, param, value): if not value: ctx.abort()@click.command()@click.option('--yes', is_flag=True, callback=abort_if_false, expose_value=False, prompt='Are you sure you want to drop the db?')def dropdb(): click.echo('Dropped all tables!') 测试运行下： 12345$ dropdbAre you sure you want to drop the db? [y/N]: nAborted!$ dropdb --yesDropped all tables! 同样的，Click 对次进行了封装，click.confirmation_option() 装饰器实现了上述功能： 1234@click.command()@click.confirmation_option(prompt='Are you sure you want to drop the db?')def dropdb(): click.echo('Dropped all tables!') 前面只讲了默认的参数前缀 – 和 -，Click 允许开发者自定义参数前缀（虽然严重不推荐）。 12345678# other prefix@click.command()@click.option('+w/-w')def chmod(w): click.echo('writable=%s' % w)if __name__ == '__main__': chmod() 如果想要用 / 作为前缀，而且要像上面一样采用布尔标识，会产生冲突，因为布尔标识也是用 /，这种情况下可以用 ; 代替布尔标识的 /： 1234567@click.command()@click.option('/debug;/no-debug')def log(debug): click.echo('debug=%s' % debug)if __name__ == '__main__': log() 既然支持 Choice，不难联想到 Range，先看代码： 123456789# range@click.command()@click.option('--count', type=click.IntRange(0, 20, clamp=True))@click.option('--digit', type=click.IntRange(0, 10))def repeat(count, digit): click.echo(str(digit) * count)if __name__ == '__main__': repeat() Argument 参数Argument 的作用类似 Option，但没有 Option 那么全面的功能。 和 Option 一样，Argument 最基础的应用就是传递一个简单变量值： 1234@click.command()@click.argument('filename')def touch(filename): click.echo(filename) 命令行后跟的参数值被赋值给参数名 filename。 另一个用的比较广泛的是可变参数，也是由 nargs 来确定参数个数，变量值会以 tuple 的形式传入函数： 123456@click.command()@click.argument('src', nargs=-1)@click.argument('dst', nargs=1)def copy(src, dst): for fn in src: click.echo('move %s to folder %s' % (fn, dst)) 运行程序： 123$ copy foo.txt bar.txt my_foldermove foo.txt to folder my_foldermove bar.txt to folder my_folder Click 支持通过文件名参数对文件进行操作，click.File() 装饰器就是处理这种操作的，尤其是在类 Unix 系统下，它支持以 - 符号作为标准输入/输出。 12345678910# File@click.command()@click.argument('input', type=click.File('rb'))@click.argument('output', type=click.File('wb'))def inout(input, output): while True: chunk = input.read(1024) if not chunk: break output.write(chunk) 运行程序，先将文本写进文件，再读取 12345$ inout - hello.txthello^D$ inout hello.txt -hello 如果参数值只是想做为文件名而已呢，很简单，将 type 指定为 click.Path()： 1234@click.command()@click.argument('f', type=click.Path(exists=True))def touch(f): click.echo(click.format_filename(f)) 1234567$ touch hello.txthello.txt$ touch missing.txtUsage: touch [OPTIONS] FError: Invalid value for "f": Path "missing.txt" does not exist.]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解CSS字体]]></title>
    <url>%2Fyear%2F08%2F01%2F37219%2F</url>
    <content type="text"><![CDATA[主要讲引用网络字体 常规字体在css中字体通过 font 属性设置,如123456.font&#123; font-family: 'Microsoft TaHei'; font-size: 24px; font-weight: 400; font-style: italic; &#125; 字体通常用英文名。下面是常见的字体中文名与其英文名 windows常见内置中文字体 字体中文名 字体英文名 宋体 SimSun 黑体 SimHei 微软雅黑 Microsoft Yahei 微软正黑体 Microsoft JhengHei 楷体 KaiTi 新宋体 NSimSun 仿宋 FangSong 网络字体 网络字体通过 @font-face 引用。 IE9+以及各个主流浏览器均支持。 语法 123456 @font-face &#123; font-family: &lt;字体名&gt;; src: &lt;字体路径&gt; [&lt;格式&gt;][,&lt;字体路径&gt; [&lt;格式&gt;]]*; [font-weight: &lt;粗细&gt;]; [font-style: &lt;样式&gt;];&#125; 12345678910111213&lt;style type="text/css"&gt;@font-face &#123; font-family: 'Bungee Inline'; font-style: normal; font-weight: 400; src: local('Bungee Inline'), local('BungeeInline-Regular'), url(https://fonts.gstatic.com/s/bungeeinline/v2/Tb-1914q4rFpjT-F66PLCfn8qdNnd5eCmWXua5W-n7c.woff) format('woff'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;&#125;h2&#123; font-family: 'Bungee Inline';&#125;&lt;/style&gt; 代码块中，font-family和src是必需的。src中的local()表是从本地系统查找字体，如果找不到，再从url()指定的查找。format()指的是字体的格式，常用字体格式如下： format格式 Font格式 后缀名 truetype TrueType .tff opentype OpenType .tff, .oft truetype-aat TrueType width Apple Advanced Typography extensions .tff embedded-opentype Embedded Open Type .eot svg SVG Font .svg, .svgz 浏览器支持程度 浏览器 支持类型 IE6,7,8 仅支持 .eot Firefox 3.5 支持 .ttf, .otf格式 Firefox 3.6 支持 .ttf, .otf, 及woff格式 Chrome,Safari, Opera 支持 .ttf, .otf, .svg 格式 关于兼容各个浏览器的兼容写法，可以参考一下一个国外大神Paul Irish写的兼容代码：12345678@font-face &#123; font-family: '字体名'; src: url('字体名.eot'); /* IE9 兼容模式 */ src: url('字体名.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('字体名.woff') format('woff'), /* 现代浏览器 */ url('字体名.ttf') format('truetype'), /* Safari, Android, iOS */ url('字体名.svg#grablau') format('svg'); /* Legacy iOS */ &#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文本等细节类样式处理]]></title>
    <url>%2Fyear%2F08%2F01%2F25720%2F</url>
    <content type="text"><![CDATA[background background-color background-image background-repeat background-position background-attachment background-size 透明度 filter: alpha(opacity=50); //IE opacity: 0.5; 透明度会影响后代 rgba background:rgba(255,0,0,0.5); 如果只是想要背景透明，子元素不透明，可在父元素和子元素中间加一层和父元素一样大小的div，利用 background:rgba()设置透明度 段落样式 line-height text-decoration text-indent &nbsp; &nbsp; &nbsp; &nbsp; //首行文本缩进 text-align vertical-align &nbsp; &nbsp;(支持不好，很少用) word-spacing / letter-spacing word-spacing 是单词间间距; letter-spacing是字符间间距。 word-wrap / word-breakword-wrap: 设置长单词能否换行word-wrap: break-word;word-break: 设置自动换行的处理方法word-break: break-all; 字体类 color font-family font-size font-style font-weight font: style weight size/line-height family 网络字体 表格 table caption tr / td thead / tbody / tfoot col / colgroup rowspan / colspan border border-collapse border-spacing empty-cells 表单是前后端数据传输的主要方式 formfrom 元素特有属性 action method (get / post) enctype ( 数据传输时的编码类型)application/x-www-form-urlencoded; multipart/foem-data; text/plain; inputinput是一个“神奇”的元素，它并不仅仅拥有一种表现形式，可以定义多种形式的输入框，用来让用户“输入”数据。输入框的形式由该元素的type属性来设置。在这说一下当 input type=”radio” 时，name 属性要设置为同一个属性值。当表单中存在文件域时，enctype要设置为 multipart/form-data; method要设置为 post。 label12&lt;p&gt;&lt;label for="user"&gt;用户名: &lt;/label&gt;&lt;input type="text" id="user" &gt;&lt;/p&gt; 为label标签设置for属性，for的属性值为user;为文本域设置id属性，id的属性为user，当用户单击label标签时，文本域会自动处于聚焦状态。 默认聚焦状态会有外边框 ,可以outline: none; 取消。 select.option\optgroup12345678910111213&lt;select&gt; &lt;option&gt; 1 &lt;/option&gt; &lt;option&gt; 2 &lt;/option&gt; &lt;option&gt; 3 &lt;/option&gt;&lt;/select&gt;&lt;select&gt;&lt;optgroup&gt; &lt;option&gt; 1 &lt;/option&gt; &lt;option&gt; 2 &lt;/option&gt; &lt;option&gt; 3 &lt;/option&gt;&lt;/optgroup&gt;&lt;/select&gt; fieldset 与 legendlegend表示fieldset标签的标题，包含于field元素当中 disabled checked readonly selected]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-686. 重复叠加字符串匹配(Python)]]></title>
    <url>%2Fyear%2F07%2F31%2F47574%2F</url>
    <content type="text"><![CDATA[686.重复叠加字符串匹配 给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。 举个例子，A = "abcd"，B = "cdabcdab"。 答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”，此时 B 是其子串；A 重复叠加两遍后为"abcdabcd"，B 并不是其子串。 注意: A 与 B 字符串的长度在1和10000区间范围内。 12345678910111213141516171819class Solution(object): def repeatedStringMatch(self, A, B): """ :type A: str :type B: str :rtype: int """ if(A.count(B)&gt;=1): return 1 if(set(A)!=set(B)): return -1 i=int(len(B)/len(A)) while(1): C=A*i if(C.count(B)&gt;0): return i elif i&gt;3: return -1 i+=1 不明白的可以留言]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 float 属性]]></title>
    <url>%2Fyear%2F07%2F25%2F46266%2F</url>
    <content type="text"><![CDATA[为什么要浮动div 元素属于块元素，块元素默认宽度是占满父级的，给父元素设置了宽度后还是会单独占一行。在HTML设计之初，没有几个“容器类标签”既能设置宽高，又能和别的元素同处一行。块元素能够设置宽高但是默认独占一行，行元素默认是内容撑开宽高的，虽然某个行元素能够和其他行元素处于同一行，但是并不能够设置宽高。如果希望div或其他元素“既能够设置宽高，又能够跟其他元素处于同一行”，就需要使用到 浮动。 浮动的影响 设置浮动的元素会“脱离文档流”。浮动的元素，并不属于文档中的普通流，元素漂浮于普通流之上，像浮云一样，但能够左右浮动。由于浮动的这种特性，会造成高度塌陷。 浮动元素会对兄弟元素布局产生影响，但是仅针对它后面的兄弟级元素，并不会对前面的布局造成影响。 清除浮动清除浮动指清除掉上述浮动元素造成的影响 浮动——— clear 属性规定元素的哪一侧不允许存在其他浮动元素。需要注意两点: (1) 并非浮动元素的所有兄弟级元素都需要清除浮动，只需要针对浮动元素的下一个兄弟级元素设置清除浮动，后面所有元素的布局都会恢复。(2)如果希望在第二个div(浮动元素)与第三个div(清除浮动的兄弟元素)之间有一定间距，为浮动元素后的下一个兄弟级元素设置顶部外边距时会失效(与上方空白区叠加)，此时，可以为浮动元素设置下边距。 空标签清除浮动 就是在浮动元素后加一个没有内容的空标签并设置 clear: both; 属性 br 标签清除浮动 在需要清除浮动的地方加上 &lt;brclear=”all”&gt; 为父元素设置浮动 利用after伪元素清除浮动 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .wrap&#123; border: 1px solid #000000; &#125; .con&#123; float: left; height: 200px; background: #cccccc; &#125; .wrap:after&#123; content: '\200B'; clear: both; display: block; height: 0; &#125; .wrap&#123; *zoom:1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;div class="con"&gt;第一个div&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 458. 可怜的小猪]]></title>
    <url>%2Fyear%2F07%2F25%2F48466%2F</url>
    <content type="text"><![CDATA[很有意思的一个算法题 题目： 有1000只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在15分钟内死去。 问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？ 回答这个问题，并为下列的进阶问题编写一个通用算法。 进阶: 假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出“有毒”水桶？n只水桶里有且仅有一只有毒的桶。 解题思路 这道题最重要的就是解题思路。 其实最关键的就是用一个n维空间定义坐标的思想。 注意，题目中并没有说1头小猪15分钟内只能喝1桶水。 用题目中给的数据为例： 每只猪在实验时间内可检测的数量是60/15+1=5（需要注意的是最后要+1，因为如果前面的水喝完都没死的话，说明毒水肯定是最后一桶，也不用再喝了）。 如果用两头小猪进行实验，则可将水桶定义为二维坐标，两头猪分别检测x与y方向的水：每头猪15分钟内需尝试5桶水（一排或一列）。 以此类推，3头猪则可推广到3维坐标，对应的，每头小猪每15分钟内尝试5^2桶水。 这样，每增加1头小猪，可检测的水桶数就乘5，问题解决效率就很高了。 理清了思路，代码其实很简单。 class Solution(object): def poorPigs(self, buckets, minutesToDie, minutesToTest): """ :type buckets: int :type minutesToDie: int :type minutesToTest: int :rtype: int """ times = minutesToTest / minutesToDie + 1 #每头猪最多可测试的水桶数 num = 0 while pow(times,num) < buckets: num = num + 1 return num]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解不起眼的 &lt;head&gt; 标签]]></title>
    <url>%2Fyear%2F07%2F24%2F54492%2F</url>
    <content type="text"><![CDATA[头标签 &lt;head&gt; ,这个不起眼不被重视的标签，其实很重要，值得深入理解一下。&lt;head&gt; 部分可以放 &lt;base&gt;&lt;link&gt;&lt;meta&gt;&lt;script&gt;&lt;style&gt;以及&lt;title&gt;。 下面分别说一下这些标签作用: &lt;title&gt;: 网页的标题，显示在浏览器选项卡上。 &lt;meta&gt;: 元信息，所谓元信息，指的是对信息进行描述的信息。比如，网页有什么属性，用什么语言，作者是谁，主要内容是什么，这些都是元信息。 meta是用来在HTML文档中模拟HTTP的响应头报文。 有下面几条属性: 属性 值 描述 content some_text 定义与 http-equiv 或 name 属性相关的元信息 http-equiv content-type/expires/refresh/set-cookie 把 content 属性关联到 HTTP 头部。 name author/description/keywords/generator/revised/others 把 content 属性关联到一个名称。 scheme some_text 定义用于翻译 content 属性值的格式。 看几个例子: &lt;meta name="keywords" content="HTML,ASP,SQL" &gt; &lt;meta name="author" content="lili" &gt; 一般大家对 meta 的了解就这么多，其实meta 还有很多属性也很有用，下面详细说一下: 基本语法： &lt; meta 属性="该属性下的子属性" content="具体子属性对应的属性值" &gt; name属性: generator: 代码的生成工具 keywords: 关键词，不同词语用英文逗号分隔开 description: 描述信息 author: 作者 copyright: 版权 renderer: 渲染内核 robots: 机器人，主要包括 all,none,index,noindex,follow,nofollow几种属性值。 * all: 文件将被检索，且页面上的链接可以被查询 * none : 文件将不被检索，且页面上的链接不可以被查询 * index: 文件将被检索 * noindex: 文件将不被检索，但页面上的链接可以被查询(不让robot/spider登录) * follow: 页面上的链接可以被查询 * nofollow: 文件将不被检索，页面上的链接可以被查询(不让robot/spider 顺着此页链接向下深入地探查) http-equiv属性: content-type: 编码类型 content-language: 语言 refresh: 用于定时让网页刷新或跳转到指定页面 expires: 设定网页的到期时间，一旦过期则必须到服务器上重新调用。必须使用GMT时间格式 pragma: 用于设定禁止浏览器从本地的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出 set-cookie: 设置cookie过期时间 pics-label: 用于进行网页等级评定 windows-target: 告知网页在当前窗口中以独立页面显示，可以防止网页被别人当做一个frame调用，即防止被钓鱼 page-enter: 用于设定进入网页时的特殊效果 page-exit: 离开网页时的特殊效果 当前使用频繁的主要有 字符编码、关键字、描述信息、自动刷新、独立页面显示 设置字符编码: &lt;meta charset="UTF-8" &gt; 这些设置主要是告诉浏览器信息，也方便搜索引擎抓取自己的页面 * link: link标签定义文档与外部资源的关系。 最常见的是链接样式表。 link 中 最常用的属性是 rel &lt;link rel="value" &gt; 主要是链接外部样式表 &lt;link rel="stylesheet" href="./css/index.css" &gt; link另外一个主要用处是 定义 icon 图标 &lt;link rel="icon" href="images/favicon.png" sizes="16*16" type="image/png" &gt; &lt;head&gt; 中的重点大概就是这些，一些小知识点还是挺重要的。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[千万不要还不会走就想跑]]></title>
    <url>%2Fyear%2F07%2F24%2F20335%2F</url>
    <content type="text"><![CDATA[就是给自己提个醒，一步一步来，不要还不会走就想跑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[最长回文子串]]></title>
    <url>%2Fyear%2F07%2F10%2F52608%2F</url>
    <content type="text"><![CDATA[leetcode 第5题 题目表述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba”也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 这个题很有意思，放一下官方解答。这类题真是经常遇到，值得好好研究一下各种算法。下面是我提交的 中心扩展算法:12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ def preProcess(s): if not s: return ['^', '$'] T = ['^'] for c in s: T += ['#', c] T += ['#', '$'] return T T = preProcess(s) P = [0] * len(T) center, right = 0, 0 for i in xrange(1, len(T) - 1): i_mirror = 2 * center - i if right &gt; i: P[i] = min(right - i, P[i_mirror]) else: P[i] = 0 while T[i + 1 + P[i]] == T[i - 1 - P[i]]: P[i] += 1 if i + P[i] &gt; right: center, right = i, i + P[i] max_i = 0 for i in xrange(1, len(T) - 1): if P[i] &gt; P[max_i]: max_i = i start = (max_i - 1 - P[max_i]) / 2 return s[start : start + P[max_i]] 这个算法很好但真的不好理解，值得记录下来。]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python操作链表]]></title>
    <url>%2Fyear%2F07%2F08%2F17560%2F</url>
    <content type="text"><![CDATA[终于考完试了，又可以每天开心地敲代码了。 利用暑假时间，准备用Python把 LeetCode 刷一遍。今天做一道简单链表题的时候，突然发现用Python无法直接操作链表，在网上找了一下，发现可以自己定义实现，所以就打个笔记。 1.定义链表12345# Definition for singly-linked list.class ListNode(object): def __init__(self): self.val = None self.next = None 2.对链表的操作123456789101112131415161718192021222324252627class ListNode_handle: def __init__(self): self.cur_node = None def add(self, data): # add a new node pointed to previous node node = ListNode() node.val = data node.next = self.cur_node self.cur_node = node return node def print_ListNode(self, node): while node: print '\nnode: ', node, ' value: ', node.val, ' next: ', node.next node = node.next def _reverse(self, nodelist): list = [] while nodelist: list.append(nodelist.val) nodelist = nodelist.next result = ListNode() result_handle = ListNode_handle() for i in list: result = result_handle.add(i) return result 如 要将1,8,3按照1–&gt;8–&gt;3的顺序使用ListNode_1操作放入链表ListNode()中，可以进行如下操作12345ListNode_1 = ListNode_handle()l1 = ListNode()l1_list = [1,8,3]for i in l1_list: l1 = ListNode_1.add(i) 反向排列列表1l1 = ListNode_1.reverse(l1) 打印链表1ListNode_1.print_ListNode(l1) 如这个算法题 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 1234567891011121314151617181920212223242526272829303132333435363738# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if l1 is None: return l2 if l2 is None: return l1 tmp = ListNode(0) res = tmp flag = 0 while l1 or l2: tmpsum = 0 if l1: tmpsum = l1.val l1 = l1.next if l2: tmpsum += l2.val l2 = l2.next tmpres = ((tmpsum + flag) % 10) flag = ((tmpsum + flag) // 10) res.next = ListNode(tmpres) res = res.next if flag: res.next = ListNode(1) res = tmp.next del tmp return res]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML/CSS 问答题]]></title>
    <url>%2Fyear%2F06%2F10%2F58581%2F</url>
    <content type="text"><![CDATA[HTML/CSS 基础简答题，检验基础掌握情况。 什么是HTML5？ 什么是“W3C”？ 解释“页面重构”？ 简述JPG、GIF、PNG三者的区别。 请描述“页面回流”与“页面重绘”。 简述border: 0; 与 border: none;的区别。 请描述“不同CSS引入方式的优劣势”。 请详细阐述对“浮动”和“清除浮动”的理解。 描述锚文本的含义。 简述块元素与行元素的区别。 简述 display: none; 与 visibility: hidden 的区别。 简述标签的嵌套规则。 简述 strong、em、b、i的区别。 简述a标签4个伪类书写顺序的原因。 简述img的alt与title的区别。 简述href属性与src属性的区别。 简述 overflow: auto; 与 overflow: scroll；的区别。 谈谈你对margin 负值的理解。 简述实现背景透明的方法以及区别。 简述背景图合并的实现原理，以及与CSS Sprite 的区别。 简述 word-wrap 与 word-break 的区别。 简述 word-spacing 与 letter-spacing 的区别。 简述 italic 与 oblique 的区别。 当元素设置绝对定位之后，到底针对谁进行定位？ 请总结最大宽度/高度、最小宽度/高度的使用情景。 简述table 布局与 HTML+CSS 布局的区别。 简述 table各个元素的嵌套规则。 简述 “ button标签” 与 “类型为button 的 input 标签”功能上的区别。 简述 form 中的 readonly 和 disabled 属性的区别。 简述表单元素在实际开发当中的制作方法。 简述行元素与块元素的区别。 简述 alt 与 title 的区别。 简述link 与 @import 的区别。 简述 relative 与 absolute 的区别。 简述 DIV/HTML + CSS布局与 table布局的区别。 简述浏览器内核以及浏览器内核前缀。 简述 :nth-child(n) 与:nth-of-type(n) 两种选择器的区别。 简述文本阴影与盒阴影的区别。 简述背景切割与背景原点的区别。 简述背景尺寸的 cover 和 contain 的区别。 简述 rem 与 em 的区别。 简述响应式布局的优劣势。 移动端的兼容问题。 三维变形与二维变形的区别是什么。 如何理解关键帧。 简述CSS3动画与CSS3过渡的区别。 1]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2Fyear%2F06%2F09%2F37026%2F</url>
    <content type="text"><![CDATA[CSS2.0 版本中，共有10种选择器，ID选择器、类名选择器、标签名选择器、群组选择器、后代选择器、子代选择器、通配符选择器、毗邻选择器、伪类选择器、属性选择器。 1. CSS2 选择器 选择器语法 选择器含义 #wrap ID选择器 .wrap 类名选择器 div 标签名选择器 #wrap p 后代选择器 #wrap&gt;p 子代选择器 #wrap, .con p 群组选择器 * 通配符选择器 .con+p 毗邻选择器 :hover,:active 伪类选择器 input[type=’text’] 属性选择器 2. CSS3 选择器————通用兄弟选择器12E~F&#123;/*样式代码*/&#125;p~ul&#123;&#125; 匹配任何在E元素之后的同级F元素。通用兄弟选择器将选择某元素后面的所有兄弟元素，与毗邻选择器类似，需要在同一父元素中。 3. CSS3 选择器————伪类选择器3.1 结构性伪类 选择器语法 选择器含义 E:root 匹配文档的根元素，对于HTML文档，就是HTML元素 E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1 E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 E:nth-last-of-type(n) 与:nth-last-child()作用类似，但是仅匹配使用同种标签的元素 E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或:nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或:nth-of-type(1):nth-last-type(1) E:empty 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素 E:not(s) 匹配不符合当前选择器的任何元素 3.2与用户界面相关的伪类 选择器语法 选择器含义 E:enabled 匹配表单中激活的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的rasio或checkbox 元素 E:selection 匹配用户当前选中的元素]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[伪元素]]></title>
    <url>%2Fyear%2F06%2F08%2F4047%2F</url>
    <content type="text"><![CDATA[1.什么是伪元素伪元素可以理解成“虚假的元素”，它们虽然会在内容元素的前后插入额外的元素，但并不会在文档中生成，在文档的源代码当中并不能够找到它们。虽然在结构上是“虚假”的元素，但在表现上和“普通”元素没有什么区别，能够为它们添加任何样式，比如改变文字颜色、添加背景、调整字体大小等。 2.伪元素的种类 伪元素种类 描述 :first-letter 向文本的第一个字母添加特殊样式 :first-line 向文本的首行添加特殊样式 :before 在元素之前添加内容 :after 在元素之后添加内容 :before 和 :after 较为常用，能够辅助实现各类效果和功能。 伪元素使用一个或两个冒号都可以。 3.after 与 before 伪元素在伪元素中添加内容可以使用content属性。需要注意，如果不为伪元素设置content属性，伪元素并不会显示。如果希望伪元素能够显示，又不希望伪元素当中存在任何可视文本内容，可以将content 设置为”\200B”(零宽度的空格) 默认情况下，after 与 before 伪元素以行元素的特性进行渲染。如果希望伪元素能够以块元素显示，为其设置display:block;即可。 利用伪元素可以实现背景图等功能。 4.伪类 属性 描述 CSS :active 向被激活的元素添加样式。 1 :focus 向拥有键盘输入焦点的元素添加样式。 2 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 1 :link 向未被访问的链接添加样式。 1 :visited 向已被访问的链接添加样式。 1 :first-child 向元素的第一个子元素添加样式。 2 :lang 向带有指定 lang 属性的元素添加样式。 2]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[行元素和块元素]]></title>
    <url>%2Fyear%2F06%2F05%2F23125%2F</url>
    <content type="text"><![CDATA[块级元素是单独占一行，有宽高可以修改。行元素不会自动换行，并且元素没有宽和高。行内块元素不会自动换行，但可以设置宽和高。 1. 先说下 display属性功能：规定元素显示的类型。1display: block; display 的各种显示类型 值 描述 none 此元素不会被显示 block 此元素将显示为块级元素，此元素前后带有换行符 inline 此元素将显示为内联元素，此元素前后没有换行符 inline-block 此元素会被显示为行内块元素 list-item 此元素会作为列表显示 run-in 此元素会根据上下文作为块级元素或内联元素显示。 compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 table 此元素会作为块级表格来显示（类似 table ），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似 table），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似 tbody）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似 thead）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似 tfoot）。 table-row 此元素会作为一个表格行显示（类似 tr）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似 colgroup）。 table-column 此元素会作为一个单元格列显示（类似 col） table-cell 此元素会作为一个表格单元格显示（类似 td 和 th） table-caption 此元素会作为一个表格标题显示（类似 caption） inherit 规定应该从父元素继承 display 属性的值。 通过display 属性改变标签展示类型，标签会拥有相应类型的标签特点。 2.根据标签默认 display 属性划分类别2.1 块元素 块元素具备如下特性: 1.默认独占父级的一行，不能够与其他元素处于同一行；2. 能够设置宽高(换言之:设置宽高无效)；3.外边距设置生效。 常见的块元素包括 网页、框架等基本结构块: html,body,iframe. 网页标题块: title. 表单结构块: form,fieldset,legend. 布局结构块: div 标题段落结构块: h1~h6,p 列表结构块: dl,dt,dd,ul,ol 结构装饰块: hr 2.2 行元素 行元素具备如下特性:1. 默认由内容撑开高度，与其他行元素能够处于同一行；2. 不能够设置宽高(换言之:设置宽高无效)；3. 纵向外边距失效，横向外边距生效。 常见行元素包括: 行内包含框： span 超链接: a 图像: img 各类文本修饰类标签: abbr,acronym,b,bdo,big,cite,code,del,dfn,em,i,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,u,var等 表单对象包含框: select,button,label,textarea 可执行对象包含框: object 2.3 第三类元素除了行元素和块元素之外，还存在不少种类的元素，在这里统称为第三类元素 display:none; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head,link,meta,style.script等 display:list-item; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; li, display:table; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table display: table-row; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tr display: table-header-group; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thead display: table-row-group; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbody display: table-footer-group; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tfoot display: table-column; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col display: table-column-group; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colgroup display: table-cell; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; td,th display: table-caption; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; caption display: inline-block; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input,option,optgroup 各类元素都可以使用display属性进行元素类型的转换,例如，行和块元素之间可以通过 display:block; 和 display:inline; 命令相互转换。 display:none; 和 visibility:hidden; 均能够实现元素的隐藏，所不同的是，设置display:none; 的元素并不会占据任何物理空间，而设置 visibility: hidden;的元素，虽然视觉上看不到，但依旧会占据物理空间。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内容的超出处理————overflow]]></title>
    <url>%2Fyear%2F06%2F04%2F20894%2F</url>
    <content type="text"><![CDATA[1.基本语法1overflow: hidden; overflow 的属性值 值 描述 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 从父元素继承overflow 属性 x 和 y 两个方向的控制:overflow 属性的设置是针对水平、垂直两个方向的，如果只想针对其中一个方向设置，可以使用 overflow-x 或 overflow-y ,取值与overflow 一样。 2. 实现文本超出隐藏使用CSS实现元素的文本超出隐藏，通常有两种方式，一种是直接隐藏内容，另一种是超出显示为省略号。超出隐藏比较简单，只需要为一个有固定宽高的元素设置为 overflow:hidden;。 下面演示超出文本显示为省略号123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .text-overflow&#123; width: 400px; height: 40px; border: 2px solid black; line-height: 40px; overflow: hidden; text-overflow: ellipsis; word-break: keep-all; white-space: nowrap; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="text-overflow"&gt; 这个电影让我想起了一年前我和家人闹矛盾，被断生活费的那段日子了。 被房东赶出来，落难了身边大部分朋友都变路人，寄宿在一个很肮脏的屋子里过了4个多月。 我还清楚地记得去年的圣诞节那晚我在打工的地方工伤切伤了左手拇指，一个人捂着满是血的 左手在车站侯座上坐了很久很久……明天一定会变好的！&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 样式的最后4行代码是显示省略号的“核心代码”。text-overflow:ellipsis; 表示当对象内文本溢出时显示省略号；它必须与hidden:overflow; 一起使用； word-break:keep-all; 和 white-space: nowarp; 的作用一致，都是让对象内的文本不换行。 3. 多行文本超出显示为省略号多行文本超出显示为省略号的需求，可以由后台直接截取相应数据量的文字，后面加上“…”，再作为实际数据呈现在前端。如果单纯由前端来实现，就有点复杂，仅使用 HTML 和 CSS很难实现，通常借助Javascript 来辅助实现。123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .text-overflow&#123; width: 400px; border: 2px solid black; line-height: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="text-overflow" id="con"&gt; 这个电影让我想起了一年前我和家人闹矛盾，被断生活费的那段日子了。 被房东赶出来，落难了身边大部分朋友都变路人，寄宿在一个很肮脏的屋子里过了4个多月。 我还清楚地记得去年的圣诞节那晚我在打工的地方工伤切伤了左手拇指，一个人捂着满是血的 左手在车站侯座上坐了很久很久……明天一定会变好的！&lt;/div&gt;&lt;script&gt; var con = document.getElementById('con'); var textcon = con.innerHTML; con.innerHTML = textcon.substring(0,49) + '...';&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4. 关于 overflow 问题区 overflow:scroll; 与 overflow:auto; 的区别 ？当文本超出时，overflow: scroll 与 overflow: auto 都会出现滚动条。当文本没有超出元素区域时，overflow:auto 并不会出现滚动条，而 overflow: scroll 依旧会显示滚动条。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【转】2018-6次面试阿里，持续一个多月，终于有offer了!]]></title>
    <url>%2Fyear%2F06%2F03%2F43284%2F</url>
    <content type="text"><![CDATA[从3月开始准备，一直到5月22号，终于拿到阿里的实习offer，这一路，真的是一把辛酸泪！下面细说之！在这一路上，坎坎坷坷，跌跌宕宕，期间，面了阿里，腾讯，百度，今日头条，小米，笔试网易，美团，携程，爱奇艺….不得不说，阿里是持续周期最长的，从3.28直到5.10，但所幸，也是第一个录取我的公司，也是我最想要的一个结果，在此，先说一句：感谢阿里！ 阿里一面2018-3-28 8:03-10:06（面试官，很和蔼可亲，不会的，会举例子对你引导） 面试官 先做下自我介绍吧？ 对后端有了解吗？node之类的 那我就针对你的项目问一些基础能力？（好的） 我看你接触前端两年多，能告诉我你是怎么入行前端的吗？ 我引导了一下说之后会做一些可视化的东西，引导偏了。 我看您对ES6，js知道比较多吧 你个人觉得，你html，css，js哪方面比较强啊？（面试官还是挺好的，给我机会选择，我竟然说了js，但是面试官还是问html和css东西） 过去学，html，css有没有比较印象深刻的一些点啊？ 有没有用html和css做出来什么作品啊？ 移动端适配是响应式，还是通过其他方案？ 能给我细讲一下rem和其他单位之间的区别吗？ flex布局和传统布局有什么区别？ 说了下双飞翼布局 双飞翼布局怎么保证三列的高度一致呢？ 双飞翼布局具体怎么实现的？ 假设用flex实现双飞翼布局，让三列等高？ 下面问一下js方面的问题 说一下原型链吧（proto，prototype）？ 知道拷贝对象吧，拷贝一个对象能做吗（浅拷贝，深拷贝）？ 讲讲，怎么上手的vue，以及为啥用vue而不用其他框架？ 你对vue的源码了解吗，给我讲讲双向绑定原理怎么实现的，详细描述什么时候监听变化的，什么时候触发变化的？ Vue双向绑定？ Vuex整个触发过程（actions，state，view）？ Vue和Vuex有什么差别？ 项目 为什么你们的页面要用到vue-router呢?，如果没有vue-router，你们还会做单页面应用吗？ 说说性能优化？具体哪些优化的收益较大？ 传输模型：浏览器输入url到整个页面显示出来经历的过程？能介绍多细就多细？ 最常问的问题：项目中遇到的难点，怎么解决的？ 说说，基于NLP的汇款单自动生成APP这个项目？ node端有做过什么吗？ 学前端，比较精彩的点？ 阿里二面（面试官真的真的非常忙，4月12号晚上太忙，约13号晚上9点，10点接电话，不过声音挺好听的，说周六周日，再聊下） 简单自我介绍一下？ 有什么比较复杂的项目，有些什么样的亮点？，有什么难点？ 做的微信小程序有些什么样的亮点？，有什么难点？ 你觉得你在这个团队，你的优势是什么呢，尤其是技术上？ https说一下过程？ 移动端300毫秒延迟，怎么解决的？ 移动端点击穿透？ 304状态码是怎么样，怎么产生的？–》Etag值怎么产生的？ 异步的处理方式，都是怎么处理的？（Promise）–》ES7中你知道用什么方法吗？（async和await）–》Generator 有了解吗？（没有耶） cookie和session了解吗？ 跨域怎么处理的呢？都知道什么方法？–&gt; jsonp和CORS那个更安全？ nodejs用过吗？ 微信扫一扫二维码网页上登陆前后端过程？ 说下生命周期？ Vue中Compile过程说一下？ 箭头函数和普通函数的区别？ 你今后有什么想法？ 阿里三面（5月3日晚上9点，43分钟吧） 有想法出来实习吗？当然了 你前端哪个框架更熟悉？介绍下双向绑定的原理？ 你做前端开发移动端多一点，PC端多一点，你遇到有什么难解的兼容性问题？ rem和em有什么去区别啊？ 事件委托的概念你了解吗？您知道这个概念是怎样的？ 事件委托主要解决什么问题呢？ 用原生JS处理事件绑定？比如一个列表，然后，怎么监听每一个li的点击事件？—&gt; 如果新加了一些li，怎么办呢？（回答不好） null和undefined有什么区别？ 你一般情况下怎么判断基本的数据类型？ 怎么判断数组？ 对数组的浅拷贝？—&gt;深浅拷贝有什么区别？—&gt;深拷贝一个数组怎么做呢 闭包你是怎么理解？—-&gt;项目中用过吗？ 原型继承了解吗？我给你个场景，有一个FUNA，FUNB，让B继承A，用原型链怎么B继承A的属性？ 普通函数和构造函数的区别？ 不同选择器权重是怎么计算的？ 前端性能优化？ position定位？ position和float的区别？ 设计模式有了解吗？（比如观察者模式）？ 跨域了解多少？ CORS原理是什么？ 你对算法了解怎么样？常用的排序算法？—&gt;快速排序的思路大概是什么样的？—&gt;快速排序的时间复杂度 阿里四面（25min） 原型链和作用域链你的理解？ 前端的设计模式你可以说下吗？ 事件模型您介绍下吗？ 同一个对象节点上绑定多个事件，执行的顺序是怎样的？ 你知道有没有什么事件不支持冒泡，捕获的？ 正则表达式（字符串格式成金额（欧美，三个，）的）？ JS有没有了解过函数式编程？ 您今后前端的职业规划？ 整体的职业生涯规划？ 你理解的前端专家需要掌握哪些东西？ 前端架构你有了解吗？ 阿里五面（5.9晚上7点） 计算机相关的专业课您学过那些？ OSI七层协议？ http和https有什么区别？ https使用上有什么注意点？ https和http性能有什么区别？ 常见的排序方法，你都熟悉那些？ 说下希尔排序的过程？ 希尔排序的时间复杂度和空间复杂度多少？（ 希尔排序的时间复杂度是：O（nlogn）～O（n2），平均时间复杂度大致是O(n√n)） 时间复杂度怎么推测的？ 数据结构你对那些比较熟悉？ 二叉树是什么啊？ 平衡二叉树（AVL）有什么特点？ 平衡二叉树（AVL）有什么好处？ 平衡二叉树（AVL）和红黑树的区别？ 平衡树的插入和删除的时间复杂度？ 那个项目是你投入比较多的？ 这个项目主要为了解决什么问题啊？ 项目怎么分工，你主要负责那一块？ 项目过程中有遇到什么问题吗？ 项目中对你挑战比较大的，有吗？ Vue的设计思路你了解吗？ 整个什么生命周期？ Vue的响应式是怎么实现的？（一脸懵，其实就是双向绑定，然后很好地打出来了） JS闭包有什么作用？ 你的职业规划是怎么考虑的？ 如果能来实习，大概是什么时候？时间周期？ 阿里六面（HR面）5.10今晚，8点多10分，HR，打电话过来，哇，心里高兴坏了，来说说HR问我的问题吧？ 我想问下，您为什么喜欢前端啊？ 物联网专业主要是学什么的啊？（计算机，自动化，通信的结合体） 计算机你主要学到是什么语言啊？ 前端您是自学的吗？ 开始学前端到能够做项目大概花多长时间的？ 您遇到的困难是怎么解决的？ 你在做项目过程中遇到最大的挑战是什么啊？ 你每天做项目花费的时间多吗？ 平时都是几点休息啊？（hr：这么晚啊） 你自己的未来职业规划是什么的啊？ 你对自己以后进入什么样的领域，行业有什么想法？ 平常你看电影吗？ 你下载过淘票票的APP吗？（没有，支付宝有入口） 你觉得通过购票有什么评价吗，从技术角度？ 你是哪人啊？（尴尬） 你对工作地点有选择吗？ 家里除了你，还有其他孩子吗？ 平时跟姐姐交流嘛？ 有女朋友吗？（没有）—&gt;你父母有问过女朋友的事？（hr:为什么没有女朋友啊？都大三了）尴尬 我看学习成绩还可以，技术花怎么多时间，那你功课能够这么好，主要原因是什么，怎么提高自己的成绩？ 我看到你得到的荣誉，没有一等奖学金吗？（那个…,有国家励志奖学金） 你还有什么问题吗？（入职有什么要求吗？） 5月10号，HR面试之后，一直在焦急的等待中，一周之后还没有消息，感觉有点心灰意冷了，但所幸10多天后，也就是5月21号，一位女士打电话给我确认offer，心里真的很高兴（当时因为劳累过度住院了，但也难掩喜悦嘛），然后22号给我发邮件正式实习生录取，开心。 越努力，越幸运！大家一起加油！顺便说下我最喜欢的一首诗：“力学如力耕，勤惰尔自如。但使书种多，会有岁稔时。”共勉！！！ 好了，以上就是我的面经，欢迎大家讨论，有什么不懂得可以问我，但我不保证我会哈（害羞）！ 作者：朝露昙花小庆 链接：https://www.imooc.com/article/31676 来源：慕课网]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[每个Linux 新手都应该知道的10个命令]]></title>
    <url>%2Fyear%2F06%2F03%2F19137%2F</url>
    <content type="text"><![CDATA[通过这 10 个基础命令开始掌握 Linux 命令行。 你可能认为你是 Linux 新手，但实际上并不是。全球互联网用户有 3.74 亿，他们都以某种方式使用 Linux，因为 Linux 服务器占据了互联网的 90%。大多数现代路由器运行 Linux 或 Unix，TOP500 超级计算机 也依赖于 Linux。如果你拥有一台 Android 智能手机，那么你的操作系统就是由 Linux 内核构建的。 换句话说，Linux 无处不在。 但是使用基于 Linux 的技术和使用 Linux 本身是有区别的。如果你对 Linux 感兴趣，但是一直在使用 PC 或者 Mac 桌面，你可能想知道你需要知道什么才能使用 Linux 命令行接口（CLI），那么你来到了正确的地方。 下面是你需要知道的基本的 Linux 命令。每一个都很简单，也很容易记住。换句话说，你不必成为比尔盖茨就能理解它们。 1、 ls你可能会想：“这是（is）什么东西？”不，那不是一个印刷错误 —— 我真的打算输入一个小写的 l。ls，或者说 “list”， 是你需要知道的使用 Linux CLI 的第一个命令。这个 list 命令在 Linux 终端中运行，以显示在存放在相应文件系统下的所有主要目录。例如，这个命令：1ls /applications 显示存储在 applications 文件夹下的每个文件夹，你将使用它来查看文件、文件夹和目录。 显示所有隐藏的文件都可以使用命令 ls -a。 2、 cd这个命令是你用来跳转（或“更改”）到一个目录的。它指导你如何从一个文件夹导航到另一个文件夹。假设你位于 Downloads 文件夹中，但你想到名为 Gym Playlist 的文件夹中，简单地输入 cd Gym Playlist 将不起作用，因为 shell 不会识别它，并会报告你正在查找的文件夹不存在（LCTT 译注：这是因为目录名中有空格）。要跳转到那个文件夹，你需要包含一个反斜杠。改命令如下所示：1cd Gym\ Playlist 要从当前文件夹返回到上一个文件夹，你可以在该文件夹输入 cd ..。把这两个点想象成一个后退按钮。 3、 mv该命令将文件从一个文件夹转移到另一个文件夹；mv 代表“移动”。你可以使用这个简单的命令，就像你把一个文件拖到 PC 上的一个文件夹一样。 例如，如果我想创建一个名为 testfile 的文件来演示所有基本的 Linux 命令，并且我想将它移动到我的 Documents 文件夹中，我将输入这个命令：1mv /home/sam/testfile /home/sam/Documents/ 命令的第一部分（mv）说我想移动一个文件，第二部分（home/sam/testfile）表示我想移动的文件，第三部分（/home/sam/Documents/）表示我希望传输文件的位置。 4、 快捷键好吧，这不止一个命令，但我忍不住把它们都包括进来。为什么？因为它们能节省时间并避免经历头痛。 CTRL+K 从光标处剪切文本直至本行结束 CTRL+Y 粘贴文本 CTRL+E 将光标移到本行的末尾 CTRL+A 将光标移动到本行的开头 ALT+F 跳转到下一个空格处 ALT+B 回到前一个空格处 ALT+Backspace 删除前一个词 CTRL+W 剪切光标前一个词 Shift+Insert 将文本粘贴到终端中 Ctrl+D 注销这些命令在许多方面都能派上用场。例如，假设你在命令行文本中拼错了一个单词：1sudo apt-get intall programname 你可能注意到 install 拼写错了，因此该命令无法工作。但是快捷键可以让你很容易回去修复它。如果我的光标在这一行的末尾，我可以按下两次 ALT+B 来将光标移动到下面用 ^ 符号标记的地方：1sudo apt-get^intall programname 现在，我们可以快速地添加字母 s 来修复 install，十分简单！ 5、 mkdir这是你用来在 Linux 环境下创建目录或文件夹的命令。例如，如果你像我一样喜欢 DIY，你可以输入 mkdir DIY 为你的 DIY 项目创建一个目录。 6、 at如果你想在特定时间运行 Linux 命令，你可以将 at 添加到语句中。语法是 at 后面跟着你希望命令运行的日期和时间，然后命令提示符变为 at&gt;，这样你就可以输入在上面指定的时间运行的命令。 例如：123at 4:08 PM Satat&gt; cowsay 'hello'at&gt; CTRL+D 这将会在周六下午 4:08 运行 cowsay 程序。 7、 rmdir这个命令允许你通过 Linux CLI 删除一个目录。例如：1rmdir testdirectory 请记住，这个命令不会删除里面有文件的目录。这只在删除空目录时才起作用。 8、 rm如果你想删除文件，rm 命令就是你想要的。它可以删除文件和目录。要删除一个文件，键入 rm testfile，或者删除一个目录和里面的文件，键入 rm -r。 9、 touchtouch 命令，也就是所谓的 “make file 的命令”，允许你使用 Linux CLI 创建新的、空的文件。很像 mkdir 创建目录，touch 会创建文件。例如，touch testfile 将会创建一个名为 testfile 的空文件。 10、 locate这个命令是你在 Linux 系统中用来查找文件的命令。就像在 Windows 中搜索一样，如果你忘了存储文件的位置或它的名字，这是非常有用的。 例如，如果你有一个关于区块链用例的文档，但是你忘了标题，你可以输入 locate -blockchain 或者通过用星号分隔单词来查找 “blockchain use cases”，或者星号（*）。例如：1locate -i*blockchain*use*cases* 还有很多其他有用的 Linux CLI 命令，比如 pkill 命令，如果你开始关机但是你意识到你并不想这么做，那么这条命令很棒。但是这里描述的 10 个简单而有用的命令是你开始使用 Linux 命令行所需的基本知识。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[清除浮动的几种方法]]></title>
    <url>%2Fyear%2F06%2F02%2F36587%2F</url>
    <content type="text"><![CDATA[当既希望实现子元素的浮动布局，又希望父级元素由内容撑开高度时；或既希望实现元素的浮动布局，又不希望浮动元素对其他兄弟级元素产生影响时，就需要针对浮动元素或相关元素进行一些操作，这些操作放入主要目的是“清除掉浮动元素对其他元素的影响”。 注意:清除浮动，并不是把浮动元素删掉，而是取消掉“浮动元素浮动效果”对其他元素造成的影响。 1. 浮动———— clear属性用于清除浮动，规定元素的哪一侧不允许存在其他浮动元素。基本语法1clear: both; clear 属性的属性值 值 描述 left 在左侧不允许浮动元素 right 在右侧不允许浮动元素 both 在左右两侧不允许浮动元素 none 默认值。允许浮动元素出现在两侧 inherit 规定应该从父元素继承clear属性的值 2. 清除浮动的不同类型根据清除浮动的目的，可以分为以下两大类 防止浮动元素引起的兄弟级元素布局受到影响。 防止浮动元素引起的父级高度塌陷。 3. 为兄弟元素设置clear样式假设父级元素当中存在3个div， 第二个div发生了浮动，这个时候第三个div元素有可能受到影响，只需要为第三个div元素设置clear属性即可. 需要注意两点：1.并非浮动元素的所有兄弟级元素都需要清除浮动，只需要针对浮动元素的下一个兄弟级元素设置清除浮动，后面所有元素的布局都会恢复。2.如果希望在第二个div(浮动元素)与第三个div之间有一定间距，为浮动元素后的一个兄弟级元素设置顶部外边距时会失效，此时，可以为浮动元素设置下边距。 4.空标签清除浮动操作: 在浮动元素的后面，增加一个新标签，这个新标签是浮动元素的兄弟级元素，之后为这个标签设置clear属性。优点: 通俗易懂，操作方便。缺点: 会添加大量无语义空标签，结构与表现未分离，不利于维护。如下代码1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .wrap&#123; border: 1px solid #000000; &#125; .con&#123; float: left; height: 200px; background: #cccccc; &#125; .clear&#123; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;div class="con"&gt;第一个div&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5. br标签清除浮动操作： br标签清除浮动的方法类似空标签清除浮动，在浮动元素后面添加一个br标签，在br标签中设置clear属性，并赋值all. 如下代码：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .wrap&#123; border: 1px solid #000000; &#125; .con&#123; float: left; height: 200px; background: #cccccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;div class="con"&gt;第一个div&lt;/div&gt; &lt;br clear="all"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6. 父元素浮动操作: 为当前浮动元素的父级元素设置浮动。缺点： 父元素的相邻元素布局受影响————于是需要继续为其父级的父级设置浮动操作，直到 body 为止。如下代码：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .wrap&#123; float: left; border: 1px solid #000000; &#125; .con&#123; float: left; height: 200px; background: #cccccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;div class="con"&gt;第一个div&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7. 父元素设置 overflow: hidden或 auto操作： 为当前浮动元素的父级元素设置 overflow: hidden或 auto .缺点： 内容多的时候，会被隐藏，无法显示需要溢出的元素，也可能会对以后的js的一些动态效果操作造成影响。如下代码：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .wrap&#123; overflow: hidden; border: 1px solid #000000; &#125; .con&#123; float: left; height: 200px; background: #cccccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;div class="con"&gt;第一个div&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8. 利用 after 伪元素清除浮动操作： 为当前浮动元素的父级元素添加 after 伪元素，为after伪元素设置清除浮动的功能代码。 缺点: 如果使用不合理，有可能造成代码量增加；另外，IE6/7不支持after伪元素，需要使用zoom:1触发hasLayout来清理浮动。如下代码1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .wrap&#123; border: 1px solid #000000; &#125; .con&#123; float: left; height: 200px; background: #cccccc; &#125; .wrap:after&#123; content: '\200B'; clear: both; display: block; height: 0; &#125; .wrap&#123; *zoom:1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;div class="con"&gt;第一个div&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码解析: content: ‘\200B’;中content表示内容 ，’\200B’表示一个零宽度的空格。对于伪元素来说，如果没有内容，则不会显示在页面当中，因此需要设置内容。display: block; 将伪元素设置为”块状元素”，也就是让其具备div元素的特点。 height: 0;是将伪元素的高度设置为0,目的在于防止高度对布局造成影响。 通常情况下，使用最为频繁的是after 伪元素清除浮动，它是空标签清除浮动的“升级版”，该方法能够让代码量变得简单，更便于操作。123456789.clearfix:after&#123; content: '\200B'; clear: both; display: block; height: 0; &#125; .clearfix&#123; *zoom:1; &#125; 只需要将需要清除浮动的类名加上 clearfix 即可。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 安装MySQL 和可视化工具Workbench]]></title>
    <url>%2Fyear%2F06%2F01%2F53258%2F</url>
    <content type="text"><![CDATA[1.可以直接在官方下载.deb包安装:https://dev.mysql.com/downloads/ 不过更推荐用命令行安装 2.Terminal 命令行安装123sudo apt-get install mysql-server //安装过程中需要设置密码sudo apt-get install mysql-client //可以省略，第一步中已经安装了mysql-clientsudo apt-get install libmysqlclient-dev 然后使用如下命令检查是否安装成功：1sudo netstat -tap | grep mysql 3.安装 MySQL workbench下载地址: https://dev.mysql.com/downloads/workbench/123sudo dpkg -i mysql*.deb //下载好后安装sudo apt-get install -f //安装依赖包sudo dpkg -i mysql*.deb //再次运行安装包即可完成安装]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解盒模型]]></title>
    <url>%2Fyear%2F05%2F30%2F11775%2F</url>
    <content type="text"><![CDATA[这篇文章帮助你深入理解 盒模型。 1.生活中的“盒模型”————鱼缸假设一个“卖鱼缸”的商家，当前新进了两个鱼缸，需要存放在库房中。库房存放基本要求： 鱼缸大小： 100×100 包装纸箱容量： 110×110 包装纸箱厚度： 5（4个方向） 放入纸箱与鱼缸之间的泡沫：5（4个方向） 纸箱与墙壁、其他纸箱间隔：5（4个方向） 2.盒模型基本知识在HTML当中，每个元素在浏览器中的解析，都可以被看作一个“盒子”。完整的盒模型是由width,height,border,padding,margin这几部分属性组成 3.盒模型————width与height属性width用于设置元素的宽度；height用于设置元素的高度。123// 基本语法width: 100px;height: 100px; width属性的属性值 值 描述 auto 默认值。浏览器可计算出实际的宽度/高度 length 使用px,em,cm等单位定义宽度/高度 % 定义基于包含块（父元素）宽度的百分比宽度/高度 inherit 规定应该从父元素继承 width/height 属性的值 4. 盒模型————margin属性设置一个元素外边距的宽度。外边距，可以理解为当前元素与父级或其他兄弟级元素之间的距离。12//基本语法margin: 5px 5px 5px 5px; 4个属性值分别表示 “上-右-下-左”，3个属性值时分别表示“上-右左-下”；2个属性值分别表示“上下-右左”；1个属性值表示4个方向。也可以写成下面形式1234margin-top: 5px;margin-right: 5px;margin-bottom: 5px;margin-left: 5px; margin的特殊应用： 将元素的水平方向 margin 值设置为 auto， 能够让块元素在父级当中水平居中。 5. 盒模型————padding 属性padding ,内边距，可以理解为当前元素与元素边框之间的距离。基本用法与margin 类似。 注意：(1) padding 值与 margin 值类似，都有1～4个值，计算的方式方法也相同。(2) padding值也有padding-left等4个方向的分写方法，分写方式使用很少。 (3) padding 值并没有负值，设置负值时相当于0.(4) padding 值的单位设置为百分比时，也是按照父级宽度进行计算的。 6. 盒模型————border 属性border 是一个复合属性，一个边框包括边框的宽度、边框的颜色以及边框的类型。123边框宽度： 以px等为单位。边框颜色： 十六进制颜色值或单词。边框类型： solid,dotted,dashed等 border 属性可分写:1border-left-width: 10px; 大部分情况下是用缩写方法 值 描述 border-width 设置边框宽度 border-style 设置边框宽度 border-color 设置边框颜色 border-left right top bottom 设置左/右/上/下边框，需要包含边框宽度、边框样式、边框颜色 border 设置4个方向的边框宽度、样式、颜色 7. 盒模型的问题区(1) margin: 0 auto中的auto是什么含义？auto 表示横向的外边距自动，此时，左右外边距的具体的值为：（父级元素内容区宽度-含边框内边距的当前元素宽度）/2.(2) 只有块状元素才能通过 auto 实现在父级元素中水平居中。(3) 如果不为div元素设置宽度，默认这个div 会占据父级内容区的100%.(4) margin 值可以设置为负值。(5) 设置边框宽度、颜色、样式中的任意两种，会是什么效果？默认的边框颜色为黑色，默认边框粗细为3像素，必须设置“边框样式”属性，才能触发边框效果。(6) border: 0;与 border: none; 的区别;border: 0; 表示设置边框，但是边框的宽度为0,此时浏览器会正常渲染元素的边框效果，会占用内存空间并且，所有浏览器均能够正常使用。border: none; 表示不设置边框，浏览器不会进行任何渲染，不会占用内存空间；IE6、7不兼容。(7) 盒模型单位选择： PC端 px使用居多；移动端 百分比、em、rem这种相对度量单位使用居多。(8) 盒模型大小与元素实际宽高值并不相同。盒模型的宽度/高度 = 左右外边距 + 左右边距 + 左右内边距 + width/height (9) 父子之间用 padding ，兄弟之间用 margin (10) 纵向外边距会叠加。（原因是最初HTML的p标签）两个外边距值取较大的那个。(11) 使用背景颜色而非边框标识元素的原因。在实现模块具体操作之后，这个边框是需要被删除的，如果仅删除了边框而没有调整width和height的大小，就会导致盒模型大小发生变化。如果采用背景颜色，并不会占据盒模型的空间大小，再实现页面之后将背景颜色删掉，不需要针对当前元素进行任何其他操作，相对方便简单。(12) 当子元素的盒模型大小超出了父级元素的内容区大小，会引发问题。(13)试试以下代码123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;border 的特殊效果&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="reset.css"&gt; &lt;style&gt; .box &#123; width: 0px; height: 0px; border-width: 450px; border-style: solid; border-color: red black green yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;1&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式重置]]></title>
    <url>%2Fyear%2F05%2F29%2F58849%2F</url>
    <content type="text"><![CDATA[下列是日常开发中常用的样式重置表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@charset"UTF-8";html&#123; color: #000; background: #FFF; font-family: 'Microsoft YaHei',sans-serif,"Arial Narrow";&#125;body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td,strong&#123; padding: 0; margin: 0; font-family: 'Microsoft YaHei',sans-serif,"Arial Narrow";&#125;table&#123; border-collapse: collapse; border-spacing: 0;&#125;img&#123;border: 0;&#125;a&#123; text-decoration: none; color: #333; outline: none;&#125;a:hover&#123; text-decoration: underline;&#125;var,em,strong&#123;font-style: normal;&#125;em,strong,th,var&#123;font-style: inherit;font-weight: inherit;&#125;li&#123;list-style: none;&#125;caption,th&#123;text-align: left;&#125;h1,h2,h3,h4,h5,h6&#123;font-size: 100%;font-weight: normal;&#125;input,button,textarea,select,optgroup,option&#123; font-family: inherit; font-size: inherit; font-style: inherit; font-weight: inherit;&#125;input,button,textarea,select&#123;*font-size:100%;&#125; 具体使用看网站需求，这些一般需求可以概括到。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux 通过VNC连接 Raspberry pi]]></title>
    <url>%2Fyear%2F05%2F26%2F52173%2F</url>
    <content type="text"><![CDATA[玩 Raspberry pi 没有显示器 ？那就试试用你的电脑屏幕来显示啊。 1. 通过SSH 登录 Raspberry pi12~$ ssh pi@192.168.1.103pi@192.168.1.103's password: 2. 在 Raspberry pi端安装 VNC server1pi@raspberrypi:~ $ sudo apt-get install tightvncserver 3. 开启 Raspberry pi 端 VNC server(首次需要设置密码)12345678pi@raspberrypi:~ $ sudo vncserver :2 You will require a password to access your desktops.Password: Verify: Would you like to enter a view-only password (y/n)? nA VNC server is already running as :2 4. 在Linux 端安装 VNC viewer 客户端 我的 Ubuntu 16.04 默认有这个软件 1sudo apt-get install xtightvncviewer 5. 在Linux 端开启 VNC viewer 并连接Raspberry pi 1vncviewer 我的是弹出图形界面， 输入 Raspberry pi IP地址和服务端口号，比如我的 1192.168.1.103:2 OK了.]]></content>
      <categories>
        <category>Raspberry pi</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux下代码敲累了几个放松的小命令]]></title>
    <url>%2Fyear%2F05%2F26%2F22667%2F</url>
    <content type="text"><![CDATA[敲代码敲累了想放松一下？OK，试试下面的几个命令，你会很惊喜的… 12sudo apt-get install sl sl 123sudo apt-get install onekooneko并慢慢移动鼠标 12sudo apt-get install cmatrixcmatrix 12sudo apt-get install toilettoilet mylinuxbook 12sudo apt-get install figletfiglet mylinuxbook 12sudo apt-get install fortunefortune 12sudo apt-get install linuxlogo linuxlogo -L ubuntu 怎么样，有没有很惊喜。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构--栈]]></title>
    <url>%2Fyear%2F05%2F26%2F24846%2F</url>
    <content type="text"><![CDATA[栈和队列是两种重要的线性结构。从数据结构角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表的子集，它们是操作受限的线性表，因此可称为限定性的数据结构。 1.栈和队列的定义和特点1.1 栈的定义和特点栈是限定仅在表尾进行插入或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶，相应地，表头端称为栈底。不含元素的空表称为空栈。假设栈 S=(a1,a2,a3,…,an),则称a1为栈底元素，an为栈顶元素。进栈的第一个元素为栈底元素，退栈的第一个元素为栈顶元素。栈的修改是按后进先出的原则进行的，因此，栈又称为后进先出的线性表。在程序设计中，如果需要按照保存数据时相反的顺序来使用数据，则可以利用栈来实现。 1.2 队列的定义和特点和栈相反，队列是一种先进先出的线性表。它只允许在表的一端进行插入，而在另一端删除元素。这和生活中的排队是一致的，最早进入队列的元素最早离开。在队列中，允许插入的一端称为队尾，允许删除的一端称为队头。 2. 栈的表示和操作的实现顺序栈的表示和实现顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。另设指针base指示栈底元素在顺序栈中的位置。当top 和 base 的值相等时，表示空栈。顺序栈的定义如下:12345678//-------顺序栈的存储结构------#define MAXSIZE 100 //顺序栈存储空间的初始分配量typedef struct&#123; SElemType *base; //栈底指针 SElemType *top; //栈顶指针 int stacksize; //栈可用的最大容量&#125;SqStack; base为栈底指针，初始化完成后，栈底指针 base 始终指向栈底的位置，若base 的值为NULL，则表明栈结构不存在。 top 为栈顶指针，其初值指向栈底。每当插入新的栈顶元素时，指针top增1；删除栈顶元素时，指针 top减1.因此，栈空时， top 和 base 的值相等，都指向栈底；栈非空时，top始终指向栈顶元素的上一个位置。 2.1 初始化顺序栈的初始化操作就是为顺序栈动态分配一个预定义大小的数组空间。 算法2.1 顺序栈的初始化[算法步骤] 为顺序栈动态分配一个最大容量为MAXSIZE的数组空间，使base指向这段空间的基地址，即栈底。 栈顶指针top 初始为 base，表示栈为空。 stacksize 置为栈的最大容量MAXSIZE [算法描述]12345678Status InitStack(SqStack &amp;S)&#123;//构造一个空栈S S.base=new SElemType[MAXSIZE]; //为顺序栈动态分配一个最大容量为MAXSIZE的数组空间 if(!S.base) exit(OVERFLOW); //存储分配失败 S.top=S.base; // top初始为base,空栈 S.stacksize=MAXSIZE; //stacksize置为栈的最大容量MACSIZE return OK;&#125; 2.2 入栈入栈操作是指在栈顶插入一个新的元素。 算法2.2 顺序栈的入栈[算法步骤] 判断栈是否满，若满则返回ERROR。 将新元素压入栈顶，栈顶指针加1. [算法描述]123456Status Push(SqStack &amp;S, SElemType e)&#123;//插入元素e为新的栈顶元素 if (S.top-S.base==S.stacksize) return ERROR; //栈满 *S.top++=e; //元素e压入栈顶，栈顶元素加1 rturn OK;&#125; 2.3 出栈出栈操作是将栈顶元素删除 算法2.3 顺序栈的出栈[算法描述] 判断栈是否为空，若空则返回ERROR。 栈顶指针减1,栈顶元素出栈。 [算法描述]123456Status Pop(SqStack &amp;S,SElemType &amp;e)&#123;// 删除S的栈顶元素，用e返回其值 if(S.top==S.base) return ERROR; //栈空 e=*--S.top; // 栈顶指针减1,将栈顶元素赋给e return OK;&#125; 2.3 取栈顶元素当栈非空时，此操作返回当前栈顶元素的值，栈顶指针保持不变 算法2.4 取顺序栈的栈顶元素[算法描述]12345SElemType GetTop(SqStack S)&#123;//返回S的栈顶元素，不修改栈顶指针 if(S.top!=S.base) //栈非空 return *(S.top-1); //返回S的栈顶元素，不修改栈顶指针&#125; 3.链栈的表示和实现链栈是指采用链式存储结构实现的栈。通常链栈用单链表来表示。链栈的结点结构与单链表的结构相同，定义如下：123456//------链栈的存储结构--------tyoedef struct StackNode&#123; ElemType data; struct StackNode *next;&#125;StackNode,*LinkStack; 由于栈的主要操作是在栈顶插入和删除，显然以链表的头部作为栈顶是最方便的。 3.1 初始化链栈的初始化操作就是构造一个空栈，因为没必要设头结点，所以直接将栈顶指针置空即可。 算法 3.1 链栈的初始化[算法描述]12345Stack InitStack(LinkStack &amp;S)&#123;//构造一个空栈，栈顶指针置空 S=NULL; return OK;&#125; 3.2 入栈链栈在入栈前不需要判断栈是否满，只需要为入栈元素动态分配一个结点空间 算法 3.2 链栈的入栈[算法步骤] 为入栈元素e分配空间，用指针p指向 将新结点数据域置为e 将新结点插入栈顶 修改栈顶指针为p [算法描述]12345678Status Push(LinkStack &amp;S.SelemType e)&#123;//在栈顶插入元素e p=new StackNode; //生成新结点 p-&gt;data=e; //将新结点数据域置为e p-&gt;next=S; //将新结点插入栈顶 S=p; //修改栈顶指针为p return OK;&#125; 3.3 出栈和顺序栈一样，链栈在出栈前也需要判断栈是否为空，不同的是，链栈在出栈后需要释放出栈元素的栈顶空间 算法 3.3 链栈的出栈[算法步骤] 判断栈是否为空，若空则返回ERROR 将栈顶元素赋给e 临时保存栈顶元素的空间，以备释放 修改栈顶指针，指向新的栈顶元素 释放原栈顶元素的空间 [算法描述]123456789StATUS Pop(LinkSTack &amp;S,SElemType &amp;e)&#123; if (S==NULL) return ERROR; e=S-&gt;data; p=S; S=S-&gt;next; delete p; return OK;&#125; 算法 3.4 取链栈的栈顶元素[算法描述]12345SElemType GetTop(LinkStack S)&#123; if(S!=NULL) return S-&gt;data;&#125;]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构--练习 第8章 排序]]></title>
    <url>%2Fyear%2F05%2F25%2F20434%2F</url>
    <content type="text"><![CDATA[1．选择题 （1）从未排序序列中依次取出元素与已排序序列中的元素进行比较，将其放入已排序序列的正确位置上的方法，这种排序方法称为（ ）。 A．归并排序 B．冒泡排序 C．插入排序 D．选择排序 答案：C （2）从未排序序列中挑选元素，并将其依次放入已排序序列（初始时为空）的一端的方法，称为（ ）。 A．归并排序 B．冒泡排序 C．插入排序 D．选择排序 答案：D （3）对n个不同的关键字由小到大进行冒泡排序，在下列（ ）情况下比较的次数最多。 A．从小到大排列好的 B．从大到小排列好的 C．元素无序 D．元素基本有序 答案：B 解释：对关键字进行冒泡排序，关键字逆序时比较次数最多。 （4）对n个不同的排序码进行冒泡排序，在元素无序的情况下比较的次数最多为（ ）。 A．n+1 B．n C．n-1 D．n(n-1)/2 答案：D 解释：比较次数最多时，第一次比较n-1次，第二次比较n-2次……最后一次比较1次，即(n-1)+(n-2)+…+1= n(n-1)/2。 （5）快速排序在下列（ ）情况下最易发挥其长处。 A．被排序的数据中含有多个相同排序码 B．被排序的数据已基本有序 C．被排序的数据完全无序 D．被排序的数据中的最大值和最小值相差悬殊 答案：C 解释：B选项是快速排序的最坏情况。 （6）对n个关键字作快速排序，在最坏情况下，算法的时间复杂度是（ ）。 A．O(n) B．O(n2) C．O(nlog2n) D．O(n3) 答案：B 解释：快速排序的平均时间复杂度为O(nlog2n)，但在最坏情况下，即关键字基本排好序的情况下，时间复杂度为O(n2)。 （7）若一组记录的排序码为（46, 79，56，38，40，84），则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为（ ）。 A．38，40，46，56，79，84 B．40，38，46，79，56，84 C．40，38，46，56，79，84 D．40，38，46，84，56，79 答案：C （8）下列关键字序列中，（ ）是堆。 A．16，72，31，23，94，53 B．94，23，31，72，16，53 C．16，53，23，94，31，72 D．16，23，53，31，94，72 答案：D 解释：D选项为小根堆 （9）堆是一种（ ）排序。 A．插入 B．选择 C．交换 D．归并 答案：B （10）堆的形状是一棵（ ）。 A．二叉排序树 B．满二叉树 C．完全二叉树 D．平衡二叉树 答案：C （11）若一组记录的排序码为（46，79，56，38，40，84），则利用堆排序的方法建立的初始堆为（ ）。 A．79，46，56，38，40，84 B．84，79，56，38，40，46 C．84，79，56，46，40，38 D．84，56，79，40，46，38 答案：B （12）下述几种排序方法中，要求内存最大的是（ ）。 A．希尔排序 B．快速排序 C．归并排序 D．堆排序 答案：C 解释：堆排序、希尔排序的空间复杂度为O(1)，快速排序的空间复杂度为O(log2n)，归并排序的空间复杂度为O(n)。 （13）下述几种排序方法中，（ ）是稳定的排序方法。 A．希尔排序 B．快速排序 C．归并排序 D．堆排序 答案：C 解释：不稳定排序有希尔排序、简单选择排序、快速排序、堆排序；稳定排序有直接插入排序、折半插入排序、冒泡排序、归并排序、基数排序。 （14）数据表中有10000个元素，如果仅要求求出其中最大的10个元素，则采用( )算法最节省时间。 A．冒泡排序 B．快速排序 C．简单选择排序 D．堆排序 答案：D （15）下列排序算法中，（ ）不能保证每趟排序至少能将一个元素放到其最终的位置上。 A．希尔排序 B．快速排序 C．冒泡排序 D．堆排序 答案：A 解释：快速排序的每趟排序能将作为枢轴的元素放到最终位置；冒泡排序的每趟排序能将最大或最小的元素放到最终位置；堆排序的每趟排序能将最大或最小的元素放到最终位置。 2．应用题 （1）设待排序的关键字序列为{12，2，16，30，28，10，16*，20，6，18}，试分别写出使用以下排序方法，每趟排序结束后关键字序列的状态。 ① 直接插入排序 ② 折半插入排序 ③ 希尔排序（增量选取5，3，1） ④ 冒泡排序 ⑤ 快速排序 ⑥ 简单选择排序 ⑦ 堆排序 ⑧ 二路归并排序 答案： ①直接插入排序 [2 12] 16 30 28 10 16* 20 6 18 [2 12 16] 30 28 10 16* 20 6 18 [2 12 16 30] 28 10 16* 20 6 18 [2 12 16 28 30] 10 16* 20 6 18 [2 10 12 16 28 30] 16* 20 6 18 [2 10 12 16 16* 28 30] 20 6 18 [2 10 12 16 16* 20 28 30] 6 18 [2 6 10 12 16 16* 20 28 30] 18 [2 6 10 12 16 16* 18 20 28 30] ② 折半插入排序 排序过程同① ③ 希尔排序（增量选取5，3，1） 10 2 16 6 18 12 16* 20 30 28 （增量选取5） 6 2 12 10 18 16 16* 20 30 28 （增量选取3） 2 6 10 12 16 16* 18 20 28 30 （增量选取1） ④ 冒泡排序 2 12 16 28 10 16* 20 6 18 [30] 2 12 16 10 16* 20 6 18 [28 30] 2 12 10 16 16* 6 18 [20 28 30] 2 10 12 16 6 16* [18 20 28 30] 2 10 12 6 16 [16* 18 20 28 30] 2 10 6 12 [16 16* 18 20 28 30] 2 6 10 [12 16 16* 18 20 28 30] 2 6 10 12 16 16* 18 20 28 30] ⑤ 快速排序 12 [6 2 10] 12 [28 30 16* 20 16 18] 6 [2] 6 [10] 12 [28 30 16* 20 16 18 ] 28 2 6 10 12 [18 16 16* 20 ]28 [30 ] 18 2 6 10 12 [16* 16] 18 [20] 28 30 16* 2 6 10 12 16* [16] 18 20 28 30 左子序列递归深度为1，右子序列递归深度为3 ⑥ 简单选择排序 2 [12 16 30 28 10 16* 20 6 18] 2 6 [16 30 28 10 16* 20 12 18] 2 6 10 [30 28 16 16* 20 12 18] 2 6 10 12 [28 16 16* 20 30 18] 2 6 10 12 16 [28 16* 20 30 18] 2 6 10 12 16 16* [28 20 30 18] 2 6 10 12 16 16* 18 [20 30 28] 2 6 10 12 16 16* 18 20 [28 30] 2 6 10 12 16 16* 18 20 28 [30] ⑧ 二路归并排序 2 12 16 30 10 28 16 * 20 6 18 2 12 16 30 10 16* 20 28 6 18 2 10 12 16 16* 20 28 30 6 18 2 6 10 12 16 16* 18 20 28 30 （2）给出如下关键字序列｛321，156，57，46，28，7，331，33，34，63｝，试按链式基数排序方法，列出每一趟分配和收集的过程。 答案： 按最低位优先法 →321→156→57→46→28→7→331→33→34→63 分配 [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] 321 33 34 156 57 28 331 63 46 7 收集 →321→331→33→63→34→156→46→57→7→28 （3）对输入文件（101，51，19，61，3，71，31，17，19，100，55，20，9，30，50，6，90）；当k=6时，使用置换-选择算法，写出建立的初始败者树及生成的初始归并段。 答案： 初始归并段：R1:3,19,31,51,61,71,100,101 R2:9,17,19,20,30,50,55,90 R3:6 3．算法设计题 （1）试以单链表为存储结构，实现简单选择排序算法。 [算法描述]：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103voidLinkedListSelectSort(LinkedList head)//本算法一趟找出一个关键字最小的结点，其数据和当前结点进行交换;若要交换指针，则须记下//当前结点和最小结点的前驱指针p=head-&gt;next;while(p!=null) &#123;q=p-&gt;next; r=p; //设r是指向关键字最小的结点的指针 while (q!=null) &#123;if(q-&gt;data&lt;r-&gt;data) r=q; q:=q-&gt;next;&#125; if(r!=p) r-&gt;data&lt;--&gt;p-&gt;data; p=p-&gt;next; &#125;``` （2）有n个记录存储在带头结点的双向链表中，现用双向冒泡排序法对其按上升序进行排序，请写出这种排序的算法。（注：双向冒泡排序即相邻两趟排序向相反方向冒泡）。 [算法描述]：```shtypedef struct node &#123; ElemType data; struct node *prior,*next; &#125;node，*DLinkedList;void TwoWayBubbleSort(DLinkedList la)//对存储在带头结点的双向链表la中的元素进行双向起泡排序。&#123;intexchange=1; //设标记 DLinkedList p,temp,tail; head=la //双向链表头，算法过程中是向下起泡的开始结点 tail=null; //双向链表尾，算法过程中是向上起泡的开始结点while (exchange)&#123;p=head-&gt;next; //p是工作指针，指向当前结点exchange=0; //假定本趟无交换 while (p-&gt;next!=tail) // 向下（右）起泡，一趟有一最大元素沉底 if (p-&gt;data&gt;p-&gt;next-&gt;data) //交换两结点指针，涉及6条链&#123;temp=p-&gt;next; exchange=1;//有交换p-&gt;next=temp-&gt;next;temp-&gt;next-&gt;prior=p //先将结点从链表上摘下temp-&gt;next=p; p-&gt;prior-&gt;next=temp; //将temp插到p结点前temp-&gt;prior=p-&gt;prior; p-&gt;prior=temp;&#125; else p=p-&gt;next; //无交换，指针后移 tail=p; //准备向上起泡 p=tail-&gt;prior;while (exchange &amp;&amp; p-&gt;prior!=head) //向上（左）起泡，一趟有一最小元素冒出 if (p-&gt;data&lt;p-&gt;prior-&gt;data) //交换两结点指针，涉及6条链&#123;temp=p-&gt;prior; exchange=1; //有交换p-&gt;prior=temp-&gt;prior;temp-&gt;prior-&gt;next=p； //先将temp结点从链表上摘下temp-&gt;prior=p; p-&gt;next-&gt;prior=temp; //将temp插到p结点后（右）temp-&gt;next=p-&gt;next; p-&gt;next=temp;&#125; else p=p-&gt;prior; //无交换，指针前移 head=p; //准备向下起泡 &#125;//while (exchange)&#125; //算法结束 （3）设有顺序放置的n个桶，每个桶中装有一粒砾石，每粒砾石的颜色是红，白，蓝之一。要求重新安排这些砾石，使得所有红色砾石在前，所有白色砾石居中，所有蓝色砾石居后，重新安排时对每粒砾石的颜色只能看一次，并且只允许交换操作来调整砾石的位置。 [题目分析]利用快速排序思想解决。由于要求“对每粒砾石的颜色只能看一次”，设3个指针i，j和k，分别指向红色、白色砾石的后一位置和待处理的当前元素。从k=n开始，从右向左搜索，若该元素是兰色，则元素不动，指针左移（即k-1）；若当前元素是红色砾石，分i&gt;=j（这时尚没有白色砾石）和i&lt;j两种情况。前一情况执行第i个元素和第k个元素交换，之后i+1；后一情况，i所指的元素已处理过（白色），j所指的元素尚未处理，应先将i和j所指元素交换，再将i和k所指元素交换。对当前元素是白色砾石的情况，也可类似处理。 为方便处理，将三种砾石的颜色用整数1、2和3表示。 [算法描述]：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void QkSort(rectype r[],int n) &#123;// r为含有n个元素的线性表，元素是具有红、白和兰色的砾石，用顺序存储结构存储，//本算法对其排序，使所有红色砾石在前，白色居中，兰色在最后。int i=1,j=1,k=n,temp;while (k!=j)&#123;while (r[k].key==3) k--;//当前元素是兰色砾石，指针左移 if (r[k].key==1) //当前元素是红色砾石 if (i&gt;=j)&#123;temp=r[k];r[k]=r[i];r[i]=temp; i++;&#125;//左侧只有红色砾石，交换r[k]和r[i] else &#123;temp=r[j];r[j]=r[i];r[i]=temp; j++; //左侧已有红色和白色砾石，先交换白色砾石到位 temp=r[k];r[k]=r[i];r[i]=temp; i++;//白色砾石（i所指）和待定砾石（j所指）&#125; //再交换r[k]和r[i]，使红色砾石入位。if (r[k].key==2) if (i&lt;=j) &#123; temp=r[k];r[k]=r[j];r[j]=temp; j++;&#125;//左侧已有白色砾石，交换r[k]和r[j] else &#123; temp=r[k];r[k]=r[i];r[i]=temp; j=i+1;&#125;//i、j分别指向红、白色砾石的后一位置 &#125;//while if (r[k]==2) j++; /*处理最后一粒砾石 else if (r[k]==1) &#123; temp=r[j];r[j]=r[i];r[i]=temp; i++; j++; &#125; //最后红、白、兰色砾石的个数分别为: i-1;j-i;n-j+1&#125;//结束QkSor算法 [算法讨论]若将j（上面指向白色）看作工作指针，将r[1..j-1]作为红色，r[j..k-1]为白色，r[k..n]为兰色。从j=1开始查看，若r[j]为白色，则j=j+1；若r[j]为红色，则交换r[j]与r[i]，且j=j+1，i=i+1；若r[j]为兰色，则交换r[j]与r[k];k=k-1。算法进行到j&gt;k为止。 算法片段如下：12345678910111213inti=1,j=1,k=n;while(j&lt;=k) if (r[j]==1) //当前元素是红色 &#123;temp=r[i]; r[i]=r[j]; r[j]=temp; i++;j++; &#125; else if (r[j]==2) j++; //当前元素是白色else //(r[j]==3 当前元素是兰色 &#123;temp=r[j]; r[j]=r[k]; r[k]=temp; k--; &#125; 对比两种算法，可以看出，正确选择变量（指针）的重要性。 （4）编写算法，对n个关键字取整数值的记录序列进行整理，以使所有关键字为负值的记录排在关键字为非负值的记录之前，要求： ① 采用顺序存储结构，至多使用一个记录的辅助存储空间； ② 算法的时间复杂度为O(n)。 [算法描述]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void process (int A[n])&#123;low = 0;high = n-1;while ( low&lt;high )&#123;while (low&lt;high &amp;&amp; A[low]&lt;0)low++;while (low&lt;high &amp;&amp; A[high]&gt;0)high++;if (low&lt;high)&#123; x=A[low];A[low]=A[high];A[high]=x;low++;high--;&#125;&#125; return;&#125;``` （5）借助于快速排序的算法思想，在一组无序的记录中查找给定关键字值等于key的记录。设此组记录存放于数组r[l..n]中。若查找成功，则输出该记录在r数组中的位置及其值，否则显示“not find”信息。请简要说明算法思想并编写算法。[题目分析]把待查记录看作枢轴，先由后向前依次比较，若小于枢轴，则从前向后，直到查找成功返回其位置或失败返回0为止。[算法描述]```shint index (RecType R[],int l,h,datatype key)&#123;int i=l,j=h; while (i&lt;j) &#123; while (i&lt;=j &amp;&amp; R[j].key&gt;key) j--; if (R[j].key==key) return j; while (i&lt;=j &amp;&amp; R[i].key&lt;key) i++; if (R[i].key==key) return i; &#125; cout&lt;&lt;“Not find”; return 0; &#125;//index （6）有一种简单的排序算法，叫做计数排序。这种排序算法对一个待排序的表进行排序，并将排序结果存放到另一个新的表中。必须注意的是，表中所有待排序的关键字互不相同，计数排序算法针对表中的每个记录，扫描待排序的表一趟，统计表中有多少个记录的关键字比该记录的关键字小。假设针对某一个记录，统计出的计数值为c，那么，这个记录在新的有序表中的合适的存放位置即为c。 ① 给出适用于计数排序的顺序表定义； ② 编写实现计数排序的算法； ③ 对于有n个记录的表，关键字比较次数是多少？ ④ 与简单选择排序相比较，这种方法是否更好？为什么？ [算法描述]1234567① typedef struct&#123;int key;datatype info&#125;RecType 123456789101112131415②void CountSort(RecType a[],b[],int n) //计数排序算法，将a中记录排序放入b中&#123;for(i=0;i&lt;n;i++)//对每一个元素&#123;for(j=0,cnt=0;j&lt;n;j++)if(a[j].key&lt;a[i].key) cnt++;//统计关键字比它小的元素个数b[cnt]=a[i];&#125;&#125;//Count_Sort ③ 对于有n个记录的表，关键码比较n2次。 ④ 简单选择排序算法比本算法好。简单选择排序比较次数是n(n-1)/2,且只用一个交换记录的空间；而这种方法比较次数是n2，且需要另一数组空间。 [算法讨论]因题目要求“针对表中的每个记录，扫描待排序的表一趟”，所以比较次数是n2次。若限制“对任意两个记录之间应该只进行一次比较”，则可把以上算法中的比较语句改为：1234567for(i=0;i&lt;n;i++) a[i].count=0;//各元素再增加一个计数域，初始化为0for(i=0;i&lt;n;i++) for(j=i+1;j&lt;n;j++) if(a[i].key&lt;a[j].key) a[j].count++; else a[i].count++;]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构--练习 第7章 查找]]></title>
    <url>%2Fyear%2F05%2F25%2F2101%2F</url>
    <content type="text"><![CDATA[1．选择题 （1）对n个元素的表做顺序查找时，若查找每个元素的概率相同，则平均查找长度为（ ）。 A．(n-1)/2 B． n/2 C．(n+1)/2 D．n 答案：C 解释：总查找次数N=1+2+3+…+n=n(n+1)/2，则平均查找长度为N/n=(n+1)/2。 （2）适用于折半查找的表的存储方式及元素排列要求为（ ）。 A．链接方式存储，元素无序 B．链接方式存储，元素有序 C．顺序方式存储，元素无序 D．顺序方式存储，元素有序 答案：D 解释：折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 （3）如果要求一个线性表既能较快的查找，又能适应动态变化的要求，最好采用( )查找法。 A．顺序查找 B．折半查找 C．分块查找 D．哈希查找 答案：C 解释：分块查找的优点是：在表中插入和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。 （4）折半查找有序表（4，6，10，12，20，30，50，70，88，100）。若查找表中元素58，则它将依次与表中（ ）比较大小，查找结果是失败。 A．20，70，30，50 B．30，88，70，50 C．20，50 D．30，88，50 答案：A 解释：表中共10个元素，第一次取ë(1+10)/2û=5，与第五个元素20比较，58大于20，再取ë(6+10)/2û=8，与第八个元素70比较，依次类推再与30、50比较，最终查找失败。 （5）对22个记录的有序表作折半查找，当查找失败时，至少需要比较（ ）次关键字。 A．3 B．4 C．5 D．6 答案：B 解释：22个记录的有序表，其折半查找的判定树深度为 ëlog222û + 1=5，且该判定树不是满二叉树，即查找失败时至多比较5次，至少比较4次。 （6）折半搜索与二叉排序树的时间性能（ ）。 A．相同 B．完全不同 C．有时不相同 D．数量级都是O(log2n) 答案：C （7）分别以下列序列构造二叉排序树，与用其它三个序列所构造的结果不同的是（ ）。 A．（100，80， 90， 60， 120，110，130） B．（100，120，110，130，80， 60， 90） C．（100，60， 80， 90， 120，110，130） D．(100，80， 60， 90， 120，130，110) 答案：C 解释：A、B、C、D四个选项构造二叉排序树都以100为根，易知A、B、D三个序列中第一个比100小的关键字为80，即100的左孩子为80，而C选项中100的左孩子为60，故选C。 （8）在平衡二叉树中插入一个结点后造成了不平衡，设最低的不平衡结点为A，并已知A的左孩子的平衡因子为0右孩子的平衡因子为1，则应作（ ）型调整以使其平衡。 A．LL B．LR C．RL D．RR 答案：C （9）下列关于m阶B-树的说法错误的是（ ）。 A．根结点至多有m棵子树 B．所有叶子都在同一层次上 C．非叶结点至少有m/2 (m为偶数)或m/2+1（m为奇数）棵子树 D．根结点中的数据是有序的 答案：D （10）下面关于B-和B+树的叙述中，不正确的是（ ）。 A．B-树和B+树都是平衡的多叉树 B．B-树和B+树都可用于文件的索引结构 C．B-树和B+树都能有效地支持顺序检索 D．B-树和B+树都能有效地支持随机检索 答案：C （11）m阶B-树是一棵（ ）。 A．m叉排序树 B．m叉平衡排序树 C．m-1叉平衡排序树 D．m+1叉平衡排序树 答案：B （12）下面关于哈希查找的说法，正确的是（ ）。 A．哈希函数构造的越复杂越好，因为这样随机性好，冲突小 B．除留余数法是所有哈希函数中最好的 C．不存在特别好与坏的哈希函数，要视情况而定 D．哈希表的平均查找长度有时也和记录总数有关 答案：C （13）下面关于哈希查找的说法，不正确的是（ ）。 A．采用链地址法处理冲突时，查找一个元素的时间是相同的 B．采用链地址法处理冲突时，若插入规定总是在链首，则插入任一个元素的时间是相同的 C．用链地址法处理冲突，不会引起二次聚集现象 D．用链地址法处理冲突，适合表长不确定的情况 答案：A 解释：在同义词构成的单链表中，查找该单链表表中不同元素，所消耗的时间不同。 （14）设哈希表长为14，哈希函数是H(key)=key%11，表中已有数据的关键字为15，38，61，84共四个，现要将关键字为49的元素加到表中，用二次探测法解决冲突，则放入的位置是（ ）。 A．8 B．3 C．5 D．9 答案：D 解释：关键字15放入位置4，关键字38放入位置5，关键字61放入位置6，关键字84放入位置7，再添加关键字49，计算得到地址为5，冲突，用二次探测法解决冲突得到新地址为6，仍冲突，再用用二次探测法解决冲突，得到新地址为4，仍冲突，再用用二次探测法解决冲突，得到新地址为9，不冲突，即将关键字49放入位置9。 （15）采用线性探测法处理冲突，可能要探测多个位置，在查找成功的情况下，所探测的这些位置上的关键字 ( )。 A．不一定都是同义词 B．一定都是同义词 C．一定都不是同义词 D．都相同 答案：A 解释：所探测的这些关键字可能是在处理其它关键字冲突过程中放入该位置的。 2．应用题 参考这里3．算法设计题 （1）试写出折半查找的递归算法。 [算法描述]12345678910111213141516171819int BinSrch（rectype r[ ]，int k，low，high）//在长为n的有序表中查找关键字k，若查找成功，返回k所在位置，查找失败返回0。&#123;if（low≤high） //low和high分别是有序表的下界和上界 &#123;mid=（low+high）/2； if（r[mid].key==k）return （mid）； else if（r[mid].key&gt;k）return （BinSrch（r,k，mid+1，high））; else return （BinSrch（r,k，low，mid-1））; &#125; else return （0）；//查找失败。&#125;//算法结束 （2）试写一个判别给定二叉树是否为二叉排序树的算法。 [题目分析] 根据二叉排序树中序遍历所得结点值为增序的性质，在遍历中将当前遍历结点与其前驱结点值比较，即可得出结论，为此设全局指针变量pre（初值为null）和全局变量flag，初值为true。若非二叉排序树，则置flag为false。 [算法描述]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define true 1#define false 0typedef struct node&#123;datatype data; struct node *lchild,*rchild;&#125; *BTree;void JudgeBST（BTree T,int flag）// 判断二叉树是否是二叉排序树，本算法结束后，在调用程序中由flag得出结论。&#123; if（T!=null &amp;&amp; flag） &#123; Judgebst（T-&gt;lchild,flag）；// 中序遍历左子树 if（pre==null）pre=T；// 中序遍历的第一个结点不必判断 else if（pre-&gt;data&lt;T-&gt;data）pre=T；//前驱指针指向当前结点 else&#123;flag=flase；&#125; //不是完全二叉树 Judgebst （T-&gt;rchild,flag）；// 中序遍历右子树&#125;//JudgeBST算法结束``` （3）已知二叉排序树采用二叉链表存储结构，根结点的指针为T，链结点的结构为（lchild,data,rchild），其中lchild，rchild分别指向该结点左、右孩子的指针，data域存放结点的数据信息。请写出递归算法，从小到大输出二叉排序树中所有数据值&gt;=x的结点的数据。要求先找到第一个满足条件的结点后，再依次输出其他满足条件的结点。[题目分析]本题算法之一是如上题一样，中序遍历二叉树，在“访问根结点”处判断结点值是否≥x，如是则输出，并记住第一个≥x值结点的指针。这里给出另一个算法，利用二叉排序树的性质，如果根结点的值&gt;=x,则除左分枝中可能有&lt;x的结点外都应输出。所以从根结点开始查找，找到结点值&lt;x的结点后，将其与双亲断开输出整棵二叉排序树。如果根结点的值&lt;x,则沿右子树查找第一个≥x的结点，找到后，与上面同样处理。```sh void Print（BSTree t） // 中序输出以t为根的二叉排序树的结点 &#123;if（t）&#123;Print（t-&gt;lchild）； Cout&lt;&lt;t-data； Print（t-&gt;rchild）； &#125; &#125; void PrintAllx(BSTree bst，datatype x） //在二叉排序树bst中，查找值≥x的结点并输出&#123;p=bst；if（p） &#123;while（p &amp;&amp; p-&gt;data&lt;x）p=p-&gt;rchild；//沿右分枝找第一个值≥x的结点 bst=p; //bst所指结点是值≥x的结点的树的根 if（p） &#123;f=p; p=p-&gt;lchild ；//找第一个值&lt;x的结点 while（p &amp;&amp; p-&gt;data≥x）//沿左分枝向下，找第一个值&lt;x的结点 &#123;f=p；p=p-&gt;lchild ；&#125; //f是p的双亲结点的指针，指向第一个值≥x的结点 if(p) f-&gt;lchild=null; //双亲与找到的第一个值&lt;x的结点断开Print(bst)；//输出以bst为根的子树 &#125;//while &#125;//内层if（p） &#125;//第一层if（p） &#125;//PrintAllx （4）已知二叉树T的结点形式为（lling,data,count,rlink），在树中查找值为X的结点，若找到，则记数（count）加1，否则，作为一个新结点插入树中，插入后仍为二叉排序树，写出其非递归算法。 [算法描述]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void SearchBST(BiTree &amp;T,int target)&#123;BiTree s,q,f; //以数据值target,新建结点ss=new BiTNode;s-&gt;data.x=target;s-&gt;data.count=0;s-&gt;lchild=s-&gt;rchild=NULL;if(!T)&#123;T=s;return ;&#125; //如果该树为空则跳出该函数f=NULL;q=T;while (q)&#123;if (q-&gt;data.x==target)&#123;q-&gt;data.count++;return ;&#125; //如果找到该值则计数加一f=q;if (q-&gt;data.x&gt;target) //如果查找值比目标值大，则为该树左孩子q=q-&gt;lchild;else //否则为右孩子q=q-&gt;rchild;&#125; //将新结点插入树中if(f-&gt;data.x&gt;target)f-&gt;lchild=s;elsef-&gt;rchild=s;&#125; （5）假设一棵平衡二叉树的每个结点都表明了平衡因子b，试设计一个算法，求平衡二叉树的高度。 [题目分析] 因为二叉树各结点已标明了平衡因子b，故从根结点开始记树的层次。根结点的层次为1，每下一层，层次加1，直到层数最大的叶子结点，这就是平衡二叉树的高度。当结点的平衡因子b为0时，任选左右一分枝向下查找，若b不为0，则沿左（当b=1时）或右（当b=-1时）向下查找。 [算法描述]123456789101112131415161718192021 int Height（BSTree t） // 求平衡二叉树t的高度 &#123;level=0；p=t； while（p） &#123;level++； // 树的高度增1if（p-&gt;bf&lt;0）p=p-&gt;rchild；//bf=-1 沿右分枝向下//bf是平衡因子，是二叉树t结点的一个域，因篇幅所限，没有写出其存储定义 else p=p-&gt;lchild； //bf&gt;=0 沿左分枝向下&#125;//while return （level）；//平衡二叉树的高度&#125; //算法结束 （6）分别写出在散列表中插入和删除关键字为K的一个记录的算法，设散列函数为H，解决冲突的方法为链地址法。 [算法描述]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667bool insert()&#123;int data;cin&gt;&gt;data;int ant=hash(data);LinkList p=HT[ant]; //初始化散列表while (p-&gt;next)&#123;if(p-&gt;next-&gt;data==data)return false; p=p-&gt;next;&#125; //找到插入位置LinkList s;s=new LNode;s-&gt;data=data;s-&gt;next=p-&gt;next;p-&gt;next=s; //插入该结点return true;&#125; bool deletes()&#123;int data;cin&gt;&gt;data;int ant=hash(data);LinkList p=HT[ant]; //初始化散列表while (p-&gt;next)&#123;if(p-&gt;next-&gt;data==data)&#123;LinkList s=p-&gt;next;p-&gt;next=s-&gt;next;delete s; //删除该结点return true;&#125; //找到删除位置p=p-&gt;next； //遍历下一个结点&#125;return false;&#125;]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构--练习 第6章 图]]></title>
    <url>%2Fyear%2F05%2F25%2F15593%2F</url>
    <content type="text"><![CDATA[1．选择题 （1）在一个图中，所有顶点的度数之和等于图的边数的（ ）倍。 A．1/2 B．1 C．2 D．4 答案：C （2）在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（ ）倍。 A．1/2 B．1 C．2 D．4 答案：B 解释：有向图所有顶点入度之和等于所有顶点出度之和。 （3）具有n个顶点的有向图最多有（ ）条边。 A．n B．n(n-1) C．n(n+1) D．n2 答案：B 解释：有向图的边有方向之分，即为从n个顶点中选取2个顶点有序排列，结果为n(n-1)。 （4）n个顶点的连通图用邻接距阵表示时，该距阵至少有（ ）个非零元素。 A．n B．2(n-1) C．n/2 D．n2 答案：B （5）G是一个非连通无向图，共有28条边，则该图至少有（ ）个顶点。 A．7 B．8 C．9 D．10 答案：C 解释：8个顶点的无向图最多有8*7/2=28条边，再添加一个点即构成非连通无向图，故至少有9个顶点。 （6）若从无向图的任意一个顶点出发进行一次深度优先搜索可以访问图中所有的顶点，则该图一定是（ ）图。 A．非连通 B．连通 C．强连通 D．有向 答案：B 解释：即从该无向图任意一个顶点出发有到各个顶点的路径，所以该无向图是连通图。 （7）下面（ ）算法适合构造一个稠密图G的最小生成树。 A． Prim算法 B．Kruskal算法 C．Floyd算法 D．Dijkstra算法 答案：A 解释：Prim算法适合构造一个稠密图G的最小生成树，Kruskal算法适合构造一个稀疏图G的最小生成树。 （8）用邻接表表示图进行广度优先遍历时，通常借助（ ）来实现算法。 A．栈 B. 队列 C. 树 D．图 答案：B 解释：广度优先遍历通常借助队列来实现算法，深度优先遍历通常借助栈来实现算法。 （9）用邻接表表示图进行深度优先遍历时，通常借助（ ）来实现算法。 A．栈 B. 队列 C. 树 D．图 答案：A 解释：广度优先遍历通常借助队列来实现算法，深度优先遍历通常借助栈来实现算法。 （10）深度优先遍历类似于二叉树的（ ）。 A．先序遍历 B．中序遍历 C．后序遍历 D．层次遍历 答案：A （11）广度优先遍历类似于二叉树的（ ）。 A．先序遍历 B．中序遍历 C．后序遍历 D．层次遍历 答案：D （12）图的BFS生成树的树高比DFS生成树的树高（ ）。 A．小 B．相等 C．小或相等 D．大或相等 答案：C 解释：对于一些特殊的图，比如只有一个顶点的图，其BFS生成树的树高和DFS生成树的树高相等。一般的图，根据图的BFS生成树和DFS树的算法思想，BFS生成树的树高比DFS生成树的树高小。 （13）已知图的邻接矩阵如图6.30所示，则从顶点v0出发按深度优先遍历的结果是（ ）。 （14）已知图的邻接表如图6.31所示，则从顶点v0出发按广度优先遍历的结果是（ ），按深度优先遍历的结果是（ ）。 图6.31 邻接表 A．0 1 3 2 B．0 2 3 1 C．0 3 2 1 D．0 1 2 3 答案：D、D （15）下面（ ）方法可以判断出一个有向图是否有环。 A．深度优先遍历 B．拓扑排序 C．求最短路径 D．求关键路径 答案：B 2．应用题 参考这里3．算法设计题 （1）分别以邻接矩阵和邻接表作为存储结构，实现以下图的基本操作： ① 增加一个新顶点v，InsertVex(G, v)； ② 删除顶点v及其相关的边，DeleteVex(G, v); ③ 增加一条边&lt;v，w&gt;，InsertArc(G, v, w); ④ 删除一条边&lt;v，w&gt;，DeleteArc(G, v, w)。 [算法描述] 假设图G为有向无权图，以邻接矩阵作为存储结构四个算法分别如下： ① 增加一个新顶点v1234567891011Status Insert_Vex(MGraph &amp;G, char v)//在邻接矩阵表示的图G上插入顶点v&#123;if(G.vexnum+1)&gt;MAX_VERTEX_NUM return INFEASIBLE;G.vexs[++G.vexnum]=v;return OK;&#125;//Insert_Vex ② 删除顶点v及其相关的边，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Status Delete_Vex(MGraph &amp;G,char v)//在邻接矩阵表示的图G上删除顶点v&#123;n=G.vexnum;if((m=LocateVex(G,v))&lt;0) return ERROR;G.vexs[m]&lt;-&gt;G.vexs[n]; //将待删除顶点交换到最后一个顶点for(i=0;i&lt;n;i++)&#123;G.arcs[m]=G.arcs[n];G.arcs[m]=G.arcs[n]; //将边的关系随之交换&#125;G.arcs[m][m].adj=0;G.vexnum--;return OK;&#125;//Delete_Vex分析:如果不把待删除顶点交换到最后一个顶点的话,算法将会比较复杂,而伴随着大量元素的移动,时间复杂度也会大大增加。``` ③ 增加一条边&lt;v，w&gt;```shStatus Insert_Arc(MGraph &amp;G,char v,char w)//在邻接矩阵表示的图G上插入边(v,w)&#123;if((i=LocateVex(G,v))&lt;0) return ERROR;if((j=LocateVex(G,w))&lt;0) return ERROR;if(i==j) return ERROR;if(!G.arcs[j].adj)&#123;G.arcs[j].adj=1;G.arcnum++;&#125;return OK;&#125;//Insert_Arc ④ 删除一条边&lt;v，w&gt;123456789101112131415161718192021Status Delete_Arc(MGraph &amp;G,char v,char w)//在邻接矩阵表示的图G上删除边(v,w)&#123;if((i=LocateVex(G,v))&lt;0) return ERROR;if((j=LocateVex(G,w))&lt;0) return ERROR;if(G.arcs[j].adj)&#123;G.arcs[j].adj=0;G.arcnum--;&#125;return OK;&#125;//Delete_Arc 以邻接表作为存储结构，本题只给出Insert_Arc算法.其余算法类似。12345678910111213141516171819202122232425262728293031Status Insert_Arc(ALGraph &amp;G,char v,char w)//在邻接表表示的图G上插入边(v,w)&#123;if((i=LocateVex(G,v))&lt;0) return ERROR;if((j=LocateVex(G,w))&lt;0) return ERROR;p=new ArcNode;p-&gt;adjvex=j;p-&gt;nextarc=NULL;if(!G.vertices.firstarc) G.vertices.firstarc=p;else&#123;for(q=G.vertices.firstarc;q-&gt;q-&gt;nextarc;q=q-&gt;nextarc)if(q-&gt;adjvex==j) return ERROR; //边已经存在q-&gt;nextarc=p;&#125;G.arcnum++;return OK;&#125;//Insert_Arc （2）一个连通图采用邻接表作为存储结构，设计一个算法，实现从顶点v出发的深度优先遍历的非递归过程。 [算法描述]1234567891011121314151617181920212223242526272829303132333435Void DFSn(Graph G,int v)&#123; //从第v个顶点出发非递归实现深度优先遍历图GStack s;SetEmpty(s);Push(s,v);While(!StackEmpty(s))&#123; //栈空时第v个顶点所在的连通分量已遍历完Pop(s,k);If(!visited[k])&#123; visited[k]=TRUE;VisitFunc(k); //访问第k个顶点//将第k个顶点的所有邻接点进栈for(w=FirstAdjVex(G,k);w;w=NextAdjVex(G,k,w))&#123;if(!visited[w]&amp;&amp;w!=GetTop(s)) Push(s,w); //图中有环时w==GetTop(s)&#125;&#125;&#125; （3）设计一个算法，求图G中距离顶点v的最短路径长度最大的一个顶点，设v可达其余各个顶点。 [题目分析] 利用Dijkstra算法求v0到其它所有顶点的最短路径，分别保存在数组D[i]中，然后求出D[i]中值最大的数组下标m即可。 [算法描述]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int ShortestPath_MAX(AMGraph G, int v0)&#123; //用Dijkstra算法求距离顶点v0的最短路径长度最大的一个顶点m n=G.vexnum; //n为G中顶点的个数 for(v = 0; v&lt;n; ++v)&#123; //n个顶点依次初始化 S[v] = false; //S初始为空集 D[v] = G.arcs[v0][v]; //将v0到各个终点的最短路径长度初始化 if(D[v]&lt; MaxInt) Path [v]=v0; //如果v0和v之间有弧，则将v的前驱置为v0 else Path [v]=-1; //如果v0和v之间无弧，则将v的前驱置为-1 &#125;//for S[v0]=true; //将v0加入S D[v0]=0; //源点到源点的距离为0 /*开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集*/ for(i=1;i&lt;n; ++i)&#123; //对其余n−1个顶点，依次进行计算 min= MaxInt; for(w=0;w&lt;n; ++w) if(!S[w]&amp;&amp;D[w]&lt;min) &#123;v=w; min=D[w];&#125; //选择一条当前的最短路径，终点为v S[v]=true; //将v加入S for(w=0;w&lt;n; ++w) //更新从v0到V−S上所有顶点的最短路径长度 if(!S[w]&amp;&amp;(D[v]+G.arcs[v][w]&lt;D[w]))&#123; D[w]=D[v]+G.arcs[v][w]; //更新D[w] Path [w]=v; //更改w的前驱为v &#125;//if &#125;//for/*最短路径求解完毕，设距离顶点v0的最短路径长度最大的一个顶点为m */ Max=D[0];m=0;for(i=1;i&lt;n;i++)if(Max&lt;D[i]) m=i;return m;&#125; （4）试基于图的深度优先搜索策略写一算法，判别以邻接表方式存储的有向图中是否存在由顶点vi到顶点vj的路径（i≠j）。 [题目分析] 引入一变量level来控制递归进行的层数 [算法描述]123456789101112131415161718192021222324252627282930313233int visited[MAXSIZE]; //指示顶点是否在当前路径上int level＝1;//递归进行的层数int exist_path_DFS(ALGraph G,int i,int j)//深度优先判断有向图G中顶点i到顶点j是否有路径,是则返回1,否则返回0&#123; if(i==j) return 1; //i就是j else &#123; visited[i]=1; for(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc，level--) &#123; level++; k=p-&gt;adjvex; if(!visited[k]&amp;&amp;exist_path(k,j)) return 1;//i下游的顶点到j有路径&#125;//for &#125;//elseif (level==1) return 0;&#125;//exist_path_DFS （5）采用邻接表存储结构，编写一个算法，判别无向图中任意给定的两个顶点之间是否存在一条长度为为k的简单路径。 [算法描述]1234567891011121314151617181920212223242526272829int visited[MAXSIZE];int exist_path_len(ALGraph G,int i,int j,int k)//判断邻接表方式存储的有向图G的顶点i到j是否存在长度为k的简单路径&#123;if(i==j&amp;&amp;k==0) return 1; //找到了一条路径,且长度符合要求 else if(k&gt;0) &#123;visited[i]=1; for(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc) &#123;l=p-&gt;adjvex; if(!visited[l]) if(exist_path_len(G,l,j,k-1)) return 1; //剩余路径长度减一 &#125;//for visited[i]=0; //本题允许曾经被访问过的结点出现在另一条路径中 &#125;//else return 0; //没找到&#125;//exist_path_len]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构--练习 第5章 树和二叉树]]></title>
    <url>%2Fyear%2F05%2F25%2F41403%2F</url>
    <content type="text"><![CDATA[1．选择题 （1）把一棵树转换为二叉树后，这棵二叉树的形态是（ ）。 A．唯一的 Ｂ．有多种 C．有多种，但根结点都没有左孩子 Ｄ．有多种，但根结点都没有右孩子 答案：A 解释：因为二叉树有左孩子、右孩子之分，故一棵树转换为二叉树后，这棵二叉树的形态是唯一的。 （2）由3个结点可以构造出多少种不同的二叉树？（ ） A．2 B．3 C．4 D．5 答案：D （3）一棵完全二叉树上有1001个结点，其中叶子结点的个数是（ ）。 A．250 B． 500 C．254 D．501 答案：D 解释：设度为0结点（叶子结点）个数为A，度为1的结点个数为B，度为2的结点个数为C，有A=C+1，A+B+C=1001，可得2C+B=1000，由完全二叉树的性质可得B=0或1，又因为C为整数，所以B=0，C=500，A=501，即有501个叶子结点。 （4）一个具有1025个结点的二叉树的高h为（ ）。 A．11 B．10 C．11至1025之间 D．10至1024之间 答案：C 解释：若每层仅有一个结点，则树高h为1025；且其最小树高为 ëlog21025û + 1=11，即h在11至1025之间。 （5）深度为h的满m叉树的第k层有（ ）个结点。(1=&lt;k=&lt;h) A．mk-1 B．mk-1 C．mh-1 D．mh-1 答案：A 解释：深度为h的满m叉树共有mh-1个结点，第k层有mk-1个结点。 （6）利用二叉链表存储树，则根结点的右指针是（ ）。 A．指向最左孩子 B．指向最右孩子 C．空 D．非空 答案：C 解释：利用二叉链表存储树时，右指针指向兄弟结点，因为根节点没有兄弟结点，故根节点的右指针指向空。 （7）对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左右孩子中，其左孩子的编号小于其右孩子的编号，可采用（ ）遍历实现编号。 A．先序 B. 中序 C. 后序 D. 从根开始按层次遍历 答案：C 解释：根据题意可知按照先左孩子、再右孩子、最后双亲结点的顺序遍历二叉树，即后序遍历二叉树。 （8）若二叉树采用二叉链表存储结构，要交换其所有分支结点左、右子树的位置，利用（ ）遍历方法最合适。 A．前序 B．中序 C．后序 D．按层次 答案：C 解释：后续遍历和层次遍历均可实现左右子树的交换，不过层次遍历的实现消耗比后续大，后序遍历方法最合适。 （9）在下列存储形式中，（ ）不是树的存储形式？ A．双亲表示法 B．孩子链表表示法 C．孩子兄弟表示法 D．顺序存储表示法 答案：D 解释：树的存储结构有三种：双亲表示法、孩子表示法、孩子兄弟表示法，其中孩子兄弟表示法是常用的表示法，任意一棵树都能通过孩子兄弟表示法转换为二叉树进行存储。 （10）一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（ ）。 A．所有的结点均无左孩子 B．所有的结点均无右孩子 C．只有一个叶子结点 D．是任意一棵二叉树 答案：C 解释：因为先序遍历结果是“中左右”，后序遍历结果是“左右中”，当没有左子树时，就是“中右”和“右中”；当没有右子树时，就是“中左”和“左中”。则所有的结点均无左孩子或所有的结点均无右孩子均可，所以A、B不能选，又所有的结点均无左孩子与所有的结点均无右孩子时，均只有一个叶子结点，故选C。 （11）设哈夫曼树中有199个结点，则该哈夫曼树中有（ ）个叶子结点。 A．99 B．100 C．101 D．102 答案：B 解释：在哈夫曼树中没有度为1的结点，只有度为0（叶子结点）和度为2的结点。设叶子结点的个数为n0，度为2的结点的个数为n2，由二叉树的性质n0=n2+1，则总结点数n= n0+n2=2*n0-1，得到n0=100。 （12）若X是二叉中序线索树中一个有左孩子的结点，且X不为根，则X的前驱为（ ）。 A．X的双亲 B．X的右子树中最左的结点 C．X的左子树中最右结点 D．X的左子树中最右叶结点 答案：C （13）引入二叉线索树的目的是（ ）。 A．加快查找结点的前驱或后继的速度 B．为了能在二叉树中方便的进行插入与删除 C．为了能方便的找到双亲 D．使二叉树的遍历结果唯一 答案：A （14）设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有（ ）个。 A．n−1 B．n C．n + 1 D．n + 2 答案：C （15）n（n≥2）个权值均不相同的字符构成哈夫曼树，关于该树的叙述中，错误的是（ ）。 A．该树一定是一棵完全二叉树 B．树中一定没有度为1的结点 C．树中两个权值最小的结点一定是兄弟结点 D．树中任一非叶结点的权值一定不小于下一层任一结点的权值 答案：A 解释：哈夫曼树的构造过程是每次都选取权值最小的树作为左右子树构造一棵新的二叉树，所以树中一定没有度为1的结点、两个权值最小的结点一定是兄弟结点、任一非叶结点的权值一定不小于下一层任一结点的权值。 2．应用题 （1）试找出满足下列条件的二叉树 ① 先序序列与后序序列相同 ②中序序列与后序序列相同 ③ 先序序列与中序序列相同 ④中序序列与层次遍历序列相同 答案：先序遍历二叉树的顺序是“根—左子树—右子树”，中序遍历“左子树—根—右子树”，后序遍历顺序是：“左子树—右子树―根＂，根据以上原则有 ① 或为空树，或为只有根结点的二叉树 ② 或为空树，或为任一结点至多只有左子树的二叉树． ③ 或为空树，或为任一结点至多只有右子树的二叉树． ④ 或为空树，或为任一结点至多只有右子树的二叉树 （2）设一棵二叉树的先序序列： A B D F C E G H ，中序序列： B F D A G E H C ①画出这棵二叉树。 ②画出这棵二叉树的后序线索树。 ③将这棵二叉树转换成对应的树（或森林）。 答案： （3） 假设用于通信的电文仅由8个字母组成，字母在电文中出现的频率分别为0.07，0.19，0.02，0.06，0.32，0.03，0.21，0.10。 ① 试为这8个字母设计赫夫曼编码。 ② 试设计另一种由二进制表示的等长编码方案。 ③ 对于上述实例，比较两种方案的优缺点。 答案：方案1；哈夫曼编码 先将概率放大100倍，以方便构造哈夫曼树。 w={7,19,2,6,32,3,21,10}，按哈夫曼规则：【[（2,3），6], (7,10)】, ……19, 21, 32 （100） （40） （60） 19 21 32 （28） （17） （11） 7 10 6 （5） 2 3 方案比较： 方案1的WPL＝2(0.19+0.32+0.21)+4(0.07+0.06+0.10)+5(0.02+0.03)=1.44+0.92+0.25=2.61 方案2的WPL＝3(0.19+0.32+0.21+0.07+0.06+0.10+0.02+0.03)=3 结论：哈夫曼编码优于等长二进制编码 （4）已知下列字符A、B、C、D、E、F、G的权值分别为3、12、7、4、2、8，11，试填写出其对应哈夫曼树HT的存储结构的初态和终态。 答案： 初态: 终态： 3．算法设计题 以二叉链表作为二叉树的存储结构，编写以下算法： （1）统计二叉树的叶结点个数。 [题目分析]如果二叉树为空，返回0，如果二叉树不为空且左右子树为空，返回1，如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数。 [算法描述]1234567891011121314151617int LeafNodeCount(BiTree T)&#123;if(T==NULL)return 0; //如果是空树，则叶子结点个数为0else if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL)return 1; //判断结点是否是叶子结点（左孩子右孩子都为空），若是则返回1elsereturn LeafNodeCount(T-&gt;lchild)+LeafNodeCount(T-&gt;rchild);&#125; （2）判别两棵树是否相等。 [题目分析]先判断当前节点是否相等(需要处理为空、是否都为空、是否相等)，如果当前节点不相等，直接返回两棵树不相等;如果当前节点相等，那么就递归的判断他们的左右孩子是否相等。 [算法描述]12345678910111213141516171819202122232425262728293031323334353637int compareTree(TreeNode* tree1, TreeNode* tree2)//用分治的方法做，比较当前根，然后比较左子树和右子树&#123;bool tree1IsNull = (tree1==NULL);bool tree2IsNull = (tree2==NULL);if(tree1IsNull != tree2IsNull)&#123;return 1;&#125;if(tree1IsNull &amp;&amp; tree2IsNull)&#123;//如果两个都是NULL，则相等return 0;&#125;//如果根节点不相等，直接返回不相等，否则的话，看看他们孩子相等不相等if(tree1-&gt;c != tree2-&gt;c)&#123; return 1;&#125;return (compareTree(tree1-&gt;left,tree2-&gt;left)&amp;compareTree(tree1-&gt;right,tree2-&gt;right)) (compareTree(tree1-&gt;left,tree2-&gt;right)&amp;compareTree(tree1-&gt;right,tree2-&gt;left));&#125;//算法结束 （3）交换二叉树每个结点的左孩子和右孩子。 [题目分析]如果某结点左右子树为空，返回，否则交换该结点左右孩子，然后递归交换左右子树。 [算法描述]123456789101112131415161718192021222324252627void ChangeLR(BiTree &amp;T)&#123;BiTree temp;if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL)return;else&#123;temp = T-&gt;lchild;T-&gt;lchild = T-&gt;rchild;T-&gt;rchild = temp;&#125;//交换左右孩子ChangeLR(T-&gt;lchild); //递归交换左子树ChangeLR(T-&gt;rchild); //递归交换右子树&#125; （4）设计二叉树的双序遍历算法（双序遍历是指对于二叉树的每一个结点来说，先访问这个结点，再按双序遍历它的左子树，然后再一次访问这个结点，接下来按双序遍历它的右子树）。 [题目分析]若树为空，返回；若某结点为叶子结点，则仅输出该结点；否则先输出该结点，递归遍历其左子树，再输出该结点，递归遍历其右子树。 [算法描述]123456789101112131415161718192021222324252627void DoubleTraverse(BiTree T)&#123;if(T == NULL)return;else if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL)cout&lt;&lt;T-&gt;data; //叶子结点输出else&#123;cout&lt;&lt;T-&gt;data;DoubleTraverse(T-&gt;lchild); //递归遍历左子树cout&lt;&lt;T-&gt;data; DoubleTraverse(T-&gt;rchild); //递归遍历右子树&#125;&#125; （5）计算二叉树最大的宽度（二叉树的最大宽度是指二叉树所有层中结点个数的最大值）。 [题目分析] 求二叉树高度的算法见上题。求最大宽度可采用层次遍历的方法，记下各层结点数，每层遍历完毕，若结点数大于原先最大宽度，则修改最大宽度。 [算法描述]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115int Width(BiTree bt)//求二叉树bt的最大宽度&#123;if (bt==null) return (0); //空二叉树宽度为0else&#123;BiTree Q[];//Q是队列，元素为二叉树结点指针，容量足够大front=1;rear=1;last=1;//front队头指针,rear队尾指针,last同层最右结点在队列中的位置temp=0; maxw=0; //temp记局部宽度, maxw记最大宽度Q[rear]=bt; //根结点入队列while(front&lt;=last)&#123;p=Q[front++]; temp++; //同层元素数加1if (p-&gt;lchild!=null) Q[++rear]=p-&gt;lchild; //左子女入队if (p-&gt;rchild!=null) Q[++rear]=p-&gt;rchild; //右子女入队if (front&gt;last) //一层结束， &#123;last=rear;if(temp&gt;maxw) maxw=temp;//last指向下层最右元素, 更新当前最大宽度 temp=0; &#125;//if &#125;//whilereturn (maxw);&#125;//结束width``` （6）用按层次顺序遍历二叉树的方法，统计树中具有度为1的结点数目。[题目分析]若某个结点左子树空右子树非空或者右子树空左子树非空，则该结点为度为1的结点[算法描述]```shint Level(BiTree bt) //层次遍历二叉树，并统计度为1的结点的个数&#123;int num=0; //num统计度为1的结点的个数 if(bt)&#123;QueueInit(Q); QueueIn(Q,bt);//Q是以二叉树结点指针为元素的队列while(!QueueEmpty(Q))&#123;p=QueueOut(Q); cout&lt;&lt;p-&gt;data; //出队,访问结点if(p-&gt;lchild &amp;&amp; !p-&gt;rchild ||!p-&gt;lchild &amp;&amp; p-&gt;rchild)num++;//度为1的结点if(p-&gt;lchild) QueueIn(Q,p-&gt;lchild); //非空左子女入队if(p-&gt;rchild) QueueIn(Q,p-&gt;rchild); //非空右子女入队&#125; // while(!QueueEmpty(Q))&#125;//if(bt) return(num);&#125;//返回度为1的结点的个数 ``` （7）求任意二叉树中第一条最长的路径长度，并输出此路径上各结点的值。[题目分析]因为后序遍历栈中保留当前结点的祖先的信息，用一变量保存栈的最高栈顶指针，每当退栈时，栈顶指针高于保存最高栈顶指针的值时，则将该栈倒入辅助栈中，辅助栈始终保存最长路径长度上的结点，直至后序遍历完毕，则辅助栈中内容即为所求。[算法描述]```shvoid LongestPath(BiTree bt)//求二叉树中的第一条最长路径长度&#123;BiTree p=bt,l[],s[];//l, s是栈，元素是二叉树结点指针，l中保留当前最长路径中的结点int i，top=0,tag[],longest=0;while(p || top&gt;0)&#123;while(p) &#123;s[++top]=p；tag[top]=0; p=p-&gt;Lc;&#125; //沿左分枝向下if(tag[top]==1) //当前结点的右分枝已遍历&#123;if(!s[top]-&gt;Lc &amp;&amp; !s[top]-&gt;Rc) //只有到叶子结点时，才查看路径长度if(top&gt;longest)&#123;for(i=1;i&lt;=top;i++) l[i]=s[i]; longest=top; top--;&#125;//保留当前最长路径到l栈，记住最高栈顶指针，退栈&#125;else if(top&gt;0) &#123;tag[top]=1; p=s[top].Rc;&#125; //沿右子分枝向下&#125;//while(p!=null||top&gt;0)&#125;//结束LongestPath （8）输出二叉树中从每个叶子结点到根结点的路径。 [题目分析]采用先序遍历的递归方法，当找到叶子结点b时，由于b叶子结点尚未添加到path中，因此在输出路径时还需输出b-&gt;data值。 [算法描述]123456789101112131415161718192021222324252627282930313233void AllPath(BTNode *b,ElemType path[],int pathlen)&#123;int i; if (b!=NULL)&#123;if (b-&gt;lchild==NULL &amp;&amp; b-&gt;rchild==NULL) //*b为叶子结点&#123;cout &lt;&lt; " " &lt;&lt; b-&gt;data &lt;&lt; "到根结点路径:" &lt;&lt; b-&gt;data; for (i=pathlen-1;i&gt;=0;i--) cout &lt;&lt; endl;&#125; else &#123;path[pathlen]=b-&gt;data; //将当前结点放入路径中 pathlen++; //路径长度增1 AllPath(b-&gt;lchild,path,pathlen); //递归扫描左子树 AllPath(b-&gt;rchild,path,pathlen); //递归扫描右子树 pathlen--; //恢复环境 &#125; &#125;// if (b!=NULL)&#125;//算法结束]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构--练习第4章 串、数组和广义表]]></title>
    <url>%2Fyear%2F05%2F23%2F24871%2F</url>
    <content type="text"><![CDATA[1．选择题 （1）串是一种特殊的线性表，其特殊性体现在（ ）。 A．可以顺序存储 B．数据元素是一个字符 C．可以链式存储 D．数据元素可以是多个字符若 答案：B （2）串下面关于串的的叙述中，（ ）是不正确的？ A．串是字符的有限序列 B．空串是由空格构成的串 C．模式匹配是串的一种重要运算 D．串既可以采用顺序存储，也可以采用链式存储 答案：B 解释：空格常常是串的字符集合中的一个元素，有一个或多个空格组成的串成为空格串，零个字符的串成为空串，其长度为零。 （3）串“ababaaababaa”的next数组为（ ）。 A．012345678999 B．012121111212 C．011234223456 D．0123012322345 答案：C （4）串“ababaabab”的nextval为（ ）。 A．010104101 B．010102101 C．010100011 D．010101011 答案：A （5）串的长度是指（ ）。 A．串中所含不同字母的个数 B．串中所含字符的个数 C．串中所含不同字符的个数 D．串中所含非空格字符的个数 答案：B 解释：串中字符的数目称为串的长度。 （6）假设以行序为主序存储二维数组A=array[1..100,1..100]，设每个数据元素占2个存储单元，基地址为10，则LOC[5,5]=（ ）。 A．808 B．818 C．1010 D．1020 答案：B 解释：以行序为主，则LOC[5,5]=[（5-1）100+（5-1）]2+10=818。 （7）设有数组A[i,j]，数组的每个元素长度为3字节，i的值为1到8，j的值为1到10，数组从内存首地址BA开始顺序存放，当用以列为主存放时，元素A[5,8]的存储首地址为（ ）。 A．BA+141 B．BA+180 C．BA+222 D．BA+225 答案：B 解释：以列序为主，则LOC[5,8]=[（8-1）8+（5-1）]3+BA=BA+180。 （8）设有一个10阶的对称矩阵A，采用压缩存储方式，以行序为主存储，a11为第一元素，其存储地址为1，每个元素占一个地址空间，则a85的地址为（ ）。 A．13 B．32 C．33 D．40 答案：C （9）若对n阶对称矩阵A以行序为主序方式将其下三角形的元素(包括主对角线上所有元素)依次存放于一维数组B[1..(n(n+1))/2]中，则在B中确定aij（i&lt;j）的位置k的关系为（ ）。 A．i(i-1)/2+j B．j(j-1)/2+i C．i(i+1)/2+j D．j(j+1)/2+i 答案：B （10）二维数组A的每个元素是由10个字符组成的串，其行下标i=0,1,…,8,列下标j=1,2,…,10。若A按行先存储，元素A[8,5]的起始地址与当A按列先存储时的元素（ ）的起始地址相同。设每个字符占一个字节。 A．A[8,5] B．A[3,10] C. A[5,8] D．A[0,9] 答案：B 解释：设数组从内存首地址M开始顺序存放，若数组按行先存储，元素A[8,5]的起始地址为：M+[（8-0）10+（5-1）]1=M+84；若数组按列先存储，易计算出元素A[3,10]的起始地址为：M+[（10-1）9+（3-0）]1=M+84。故选B。 （11）设二维数组A[1.. m，1.. n]（即m行n列）按行存储在数组B[1.. m*n]中，则二维数组元素A[i,j]在一维数组B中的下标为（ ）。 A．(i-1)n+j B．(i-1)n+j-1 C．i(j-1) D．jm+i-1 答案：A 解释：特殊值法。取i=j=1，易知A[1,1]的的下标为1，四个选项中仅有A选项能确定的值为1，故选A。 （12）数组A[0..4,-1..-3,5..7]中含有元素的个数（ ）。 A．55 B．45 C．36 D．16 答案：B 解释：共有533=45个元素。 （13）广义表A=(a,b,(c,d),(e,(f,g)))，则Head(Tail(Head(Tail(Tail(A)))))的值为（ ）。 A．(g) B．(d) C．c D．d 答案：D 解释：Tail(A)=(b,(c,d),(e,(f,g)))；Tail(Tail(A))=( (c,d),(e,(f,g)))； Head(Tail(Tail(A)))= (c,d)；Tail(Head(Tail(Tail(A))))=(d)；Head(Tail(Head(Tail(Tail(A)))))=d。 （14）广义表((a,b,c,d))的表头是（ ），表尾是（ ）。 A．a B．( ) C．(a,b,c,d) D．(b,c,d) 答案：C、B 解释：表头为非空广义表的第一个元素，可以是一个单原子，也可以是一个子表，((a,b,c,d))的表头为一个子表(a,b,c,d)；表尾为除去表头之外，由其余元素构成的表，表为一定是个广义表，((a,b,c,d))的表尾为空表( )。 （15）设广义表L=((a,b,c))，则L的长度和深度分别为（ ）。 A．1和1 B．1和3 C．1和2 D．2和3 答案：C 解释：广义表的深度是指广义表中展开后所含括号的层数，广义表的长度是指广义表中所含元素的个数。根据定义易知L的长度为1，深度为2。 2．应用题 （1）已知模式串t=‘abcaabbabcab’写出用KMP法求得的每个字符对应的next和nextval函数值。 答案： 模式串t的next和nextval值如下： j 1 2 3 4 5 6 7 8 9 10 11 12 t串 a b c a a b b a b c a b next[j] 0 1 1 1 2 2 3 1 2 3 4 5 nextval[j] 0 1 1 0 2 1 3 0 1 1 0 5 （2）设目标为t=“abcaabbabcabaacbacba”,模式为p=“abcabaa” ① 计算模式p的naxtval函数值； ② 不写出算法,只画出利用KMP算法进行模式匹配时每一趟的匹配过程。 答案： ① p的nextval函数值为0110132。（p的next函数值为0111232）。 ② 利用KMP(改进的nextval)算法，每趟匹配过程如下： 第一趟匹配： abcaabbabcabaacbacba abcab(i=5,j=5) 第二趟匹配： abcaabbabcabaacbacba abc(i=7,j=3) 第三趟匹配： abcaabbabcabaacbacba a(i=7,j=1) 第四趟匹配： abcaabbabcabaac bacba (成功) abcabaa(i=15,j=8) （3）数组A中，每个元素A[i,j]的长度均为32个二进位,行下标从-1到9，列下标从1到11，从首地址S开始连续存放主存储器中，主存储器字长为16位。求： ① 存放该数组所需多少单元？ ② 存放数组第4列所有元素至少需多少单元？ ③ 数组按行存放时，元素A[7,4]的起始地址是多少？ ④ 数组按列存放时，元素A[4,7]的起始地址是多少？ 答案： 每个元素32个二进制位，主存字长16位，故每个元素占2个字长，行下标可平移至1到11。 （1）242 （2）22 （3）s+182 （4）s+142 (4)请将香蕉banana用工具 H( )—Head( )，T( )—Tail( )从L中取出。 L=(apple,(orange,(strawberry,(banana)),peach),pear) 答案：H（H（T（H（T（H（T（L））））））） 3．算法设计题 （1）写一个算法统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符为A-Z这26个字母和0-9这10个数字）。 [题目分析] 由于字母共26个，加上数字符号10个共36个，所以设一长36的整型数组，前10个分量存放数字字符出现的次数，余下存放字母出现的次数。从字符串中读出数字字符时，字符的ASCII代码值减去数字字符 ‘0’的ASCII代码值，得出其数值(0..9)，字母的ASCII代码值减去字符‘A’的ASCII代码值加上10，存入其数组的对应下标分量中。遇其它符号不作处理，直至输入字符串结束。 [算法描述]12345678910111213141516171819202122232425void Count（）//统计输入字符串中数字字符和字母字符的个数。｛int i，num[36]；char ch； for（i＝0；i&lt;36；i++）num[i]＝０；// 初始化 while（（ch＝getchar（））!=‘#’） //‘#’表示输入字符串结束。 if（‘0’&lt;=ch&lt;=‘9’）｛i=ch－48;num[i]++；｝ // 数字字符 else if（‘A’&lt;=ch&lt;=‘Z’）｛i=ch-65+10;num[i]++；｝// 字母字符 for（i=0；i&lt;10；i++） // 输出数字字符的个数cout&lt;&lt;“数字”&lt;&lt;i&lt;&lt; “的个数=”&lt;&lt;num[i]&lt;&lt;endl; for（i＝10；i&lt;36；i++）// 求出字母字符的个数cout&lt;&lt;“字母字符”&lt;&lt;i+55&lt;&lt; “的个数=”&lt;&lt;num[i]&lt;&lt;endl;｝ （2）写一个递归算法来实现字符串逆序存储，要求不另设串存储空间。 [题目分析]实现字符串的逆置并不难，但本题“要求不另设串存储空间”来实现字符串逆序存储，即第一个输入的字符最后存储，最后输入的字符先存储，使用递归可容易做到。 [算法描述]123456789101112131415161718192021void InvertStore(char A[])//字符串逆序存储的递归算法。&#123;char ch;static int i = 0;//需要使用静态变量cin&gt;&gt;ch;if (ch!= '.') //规定'.'是字符串输入结束标志&#123;InvertStore(A); A[i++] = ch;//字符串逆序存储&#125;A[i] = '\0'; //字符串结尾标记&#125; （3）编写算法，实现下面函数的功能。函数void insert(chars,chart,int pos)将字符串t插入到字符串s中，插入位置为pos。假设分配给字符串s的空间足够让字符串t插入。（说明：不得使用任何库函数） [题目分析]本题是字符串的插入问题，要求在字符串s的pos位置，插入字符串t。首先应查找字符串s的pos位置，将第pos个字符到字符串s尾的子串向后移动字符串t的长度，然后将字符串t复制到字符串s的第pos位置后。 对插入位置pos要验证其合法性，小于1或大于串s的长度均为非法，因题目假设给字符串s的空间足够大，故对插入不必判溢出。 [算法描述]12345678910111213141516171819202122232425void insert(char *s,char *t,int pos)//将字符串t插入字符串s的第pos个位置。&#123;int i=1,x=0; char *p=s,*q=t; //p，q分别为字符串s和t的工作指针 if(pos&lt;1) &#123;cout&lt;&lt;“pos参数位置非法”&lt;&lt;endl;exit(0);&#125;while(*p!=’\0’&amp;&amp;i&lt;pos) &#123;p++;i++;&#125; //查pos位置 //若pos小于串s长度，则查到pos位置时，i=pos。 if(*p == '/0') &#123; cout&lt;&lt;pos&lt;&lt;"位置大于字符串s的长度";exit(0);&#125; else //查找字符串的尾 while(*p!= '/0') &#123;p++; i++;&#125; //查到尾时，i为字符‘\0’的下标，p也指向‘\0’。 while(*q!= '\0') &#123;q++; x++; &#125; //查找字符串t的长度x，循环结束时q指向'\0'。 for(j=i;j&gt;=pos ;j--)&#123;*(p+x)=*p; p--;&#125;//串s的pos后的子串右移，空出串t的位置。 q--; //指针q回退到串t的最后一个字符 for(j=1;j&lt;=x;j++) *p--=*q--; //将t串插入到s的pos位置上 [算法讨论] 串s的结束标记(‘\0’)也后移了，而串t的结尾标记不应插入到s中。 （4）已知字符串S1中存放一段英文，写出算法format(s1,s2,s3,n),将其按给定的长度n格式化成两端对齐的字符串S2, 其多余的字符送S3。 [题目分析]本题要求字符串s1拆分成字符串s2和字符串s3，要求字符串s2“按给定长度n格式化成两端对齐的字符串”，即长度为n且首尾字符不得为空格字符。算法从左到右扫描字符串s1，找到第一个非空格字符，计数到n，第n个拷入字符串s2的字符不得为空格，然后将余下字符复制到字符串s3中。 [算法描述]1234567891011121314151617181920212223242526272829303132333435363738394041void format (char *s1,*s2,*s3)//将字符串s1拆分成字符串s2和字符串s3，要求字符串s2是长n且两端对齐&#123;char *p=s1, *q=s2;int i=0;while(*p!= '\0' &amp;&amp; *p== ' ') p++;//滤掉s1左端空格if(*p== '\0') &#123;cout&lt;&lt;"字符串s1为空串或空格串"&lt;&lt;endl;exit(0); &#125;while( *p!='\0' &amp;&amp; i&lt;n)&#123;*q=*p; q++; p++; i++;&#125;//字符串s1向字符串s2中复制if(*p =='\0')&#123;cout&lt;&lt;"字符串s1没有"&lt;&lt;n&lt;&lt;"个有效字符"&lt;&lt;endl; exit(0);&#125;if(*(--q)==' ' ) //若最后一个字符为空格，则需向后找到第一个非空格字符 &#123;p-- ; //p指针也后退 while(*p==' '&amp;&amp;*p!='\0') p++;//往后查找一个非空格字符作串s2的尾字符 if(*p=='\0')&#123;cout&lt;&lt;"s1串没有"&lt;&lt;n&lt;&lt;"个两端对齐的字符串"&lt;&lt;endl; exit(0);&#125; *q=*p; //字符串s2最后一个非空字符 *(++q)='\0'; //置s2字符串结束标记 &#125;*q=s3;p++; //将s1串其余部分送字符串s3。while (*p!= '\0') &#123;*q=*p; q++; p++;&#125;*q='\0'; //置串s3结束标记&#125; （5）设二维数组a[1..m, 1..n] 含有m*n 个整数。 ① 写一个算法判断a中所有元素是否互不相同?输出相关信息(yes/no)； ② 试分析算法的时间复杂度。 ① [题目分析]判断二维数组中元素是否互不相同，只有逐个比较,找到一对相等的元素，就可结论为不是互不相同。如何达到每个元素同其它元素比较一次且只一次？在当前行，每个元素要同本行后面的元素比较一次（下面第一个循环控制变量p的for循环），然后同第i+1行及以后各行元素比较一次，这就是循环控制变量k和p的二层for循环。 [算法描述]12345678910111213141516171819202122232425int JudgEqual(ing a[m][n],int m,n) //判断二维数组中所有元素是否互不相同，如是，返回1；否则，返回0。&#123;for(i=0;i&lt;m;i++) for(j=0;j&lt;n-1;j++) &#123;for(p=j+1;p&lt;n;p++) //和同行其它元素比较 if(a[i][j]==a[i][p]) &#123;cout&lt;&lt;“no”; return(0); &#125; //只要有一个相同的，就结论不是互不相同 for(k=i+1;k&lt;m;k++) //和第i+1行及以后元素比较 for(p=0;p&lt;n;p++) if(a[i][j]==a[k][p]) &#123; cout&lt;&lt;“no”; return(0); &#125; &#125;// for(j=0;j&lt;n-1;j++)cout&lt;&lt;“yes”; return(1); //元素互不相同&#125;//算法JudgEqual结束 ②二维数组中的每一个元素同其它元素都比较一次，数组中共mn个元素，第1个元素同其它mn-1个元素比较，第2个元素同其它mn-2 个元素比较，……，第mn-1个元素同最后一个元素(mn)比较一次,所以在元素互不相等时总的比较次数为 (mn-1)+(mn-2)+…+2+1=（mn）(mn-1)/2。在有相同元素时,可能第一次比较就相同,也可能最后一次比较时相同,设在(mn-1)个位置上均可能相同,这时的平均比较次数约为（mn）(mn-1)/4，总的时间复杂度是O(n4)。 (6)设任意n个整数存放于数组A(1:n)中，试编写算法，将所有正数排在所有负数前面（要求算法复杂度为0(n)）。 [题目分析]本题属于排序问题，只是排出正负，不排出大小。可在数组首尾设两个指针i和j，i自小至大搜索到负数停止，j自大至小搜索到正数停止。然后i和j所指数据交换，继续以上过程，直到 i=j为止。 [算法描述]1234567891011121314151617void Arrange(int A[],int n)//n个整数存于数组A中，本算法将数组中所有正数排在所有负数的前面&#123;int i=0,j=n-1,x; //用类C编写，数组下标从0开始 while(i&lt;j)&#123;while(i&lt;j &amp;&amp; A[i]&gt;0) i++;while(i&lt;j &amp;&amp; A[j]&lt;0) j--; if(i&lt;j) &#123;x=A[i]; A[i++]=A[j]; A[j--]=x; &#125;//交换A[i] 与A[j]&#125;// while(i&lt;j) &#125;//算法Arrange结束. [算法讨论]对数组中元素各比较一次，比较次数为n。最佳情况(已排好,正数在前,负数在后)不发生交换，最差情况(负数均在正数前面)发生n/2次交换。用类c编写，数组界偶是0..n-1。空间复杂度为O(1).]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构--练习第3章 栈和队列]]></title>
    <url>%2Fyear%2F05%2F23%2F30850%2F</url>
    <content type="text"><![CDATA[1．选择题 （1）若让元素1，2，3，4，5依次进栈，则出栈次序不可能出现在（ ）种情况。 A．5，4，3，2，1 B．2，1，5，4，3 C．4，3，1，2，5 D．2，3，5，4，1 答案：C 解释：栈是后进先出的线性表，不难发现C选项中元素1比元素2先出栈，违背了栈的后进先出原则，所以不可能出现C选项所示的情况。 （2）若已知一个栈的入栈序列是1，2，3，…，n，其输出序列为p1，p2，p3，…，pn，若p1=n，则pi为（ ）。 A．i B．n-i C．n-i+1 D．不确定 答案：C 解释：栈是后进先出的线性表，一个栈的入栈序列是1，2，3，…，n，而输出序列的第一个元素为n，说明1，2，3，…，n一次性全部进栈，再进行输出，所以p1=n，p2=n-1，…，pi=n-i+1。 （3）数组Ｑ［ｎ］用来表示一个循环队列，ｆ为当前队列头元素的前一位置，ｒ为队尾元素的位置，假定队列中元素的个数小于ｎ，计算队列中元素个数的公式为（ ）。 A．r-f B．(n+f-r)%n C．n+r-f D．（n+r-f)%n 答案：D 解释：对于非循环队列，尾指针和头指针的差值便是队列的长度，而对于循环队列，差值可能为负数，所以需要将差值加上MAXSIZE（本题为n），然后与MAXSIZE（本题为n）求余，即（n+r-f)%n。 （4）链式栈结点为：(data,link)，top指向栈顶.若想摘除栈顶结点，并将删除结点的值保存到x中,则应执行操作（ ）。 A．x=top-&gt;data;top=top-&gt;link； B．top=top-&gt;link;x=top-&gt;link； C．x=top;top=top-&gt;link； D．x=top-&gt;link； 答案：A 解释：x=top-&gt;data将结点的值保存到x中，top=top-&gt;link栈顶指针指向栈顶下一结点，即摘除栈顶结点。 （5）设有一个递归算法如下 int fact(int n) { //n大于等于0 if(n&lt;=0) return 1; else return n*fact(n-1); } 则计算fact(n)需要调用该函数的次数为（ ）。 A． n+1 B． n-1 C． n D． n+2 答案：A 解释：特殊值法。设n=0，易知仅调用一次fact(n)函数，故选A。 （6）栈在 （ ）中有所应用。 A．递归调用 B．函数调用 C．表达式求值 D．前三个选项都有 答案：D 解释：递归调用、函数调用、表达式求值均用到了栈的后进先出性质。 （7）为解决计算机主机与打印机间速度不匹配问题，通常设一个打印数据缓冲区。主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是（ ）。 A．队列 B．栈 C． 线性表 D．有序表 答案：A 解释：解决缓冲区问题应利用一种先进先出的线性表，而队列正是一种先进先出的线性表。 （8）设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5和e6依次进入栈S，一个元素出栈后即进入Q，若6个元素出队的序列是e2、e4、e3、e6、e5和e1，则栈S的容量至少应该是（ ）。 A．2 B．3 C．4 D． 6 答案：B 解释：元素出队的序列是e2、e4、e3、e6、e5和e1，可知元素入队的序列是e2、e4、e3、e6、e5和e1，即元素出栈的序列也是e2、e4、e3、e6、e5和e1，而元素e1、e2、e3、e4、e5和e6依次进入栈，易知栈S中最多同时存在3个元素，故栈S的容量至少为3。 （9）若一个栈以向量V[1..n]存储，初始栈顶指针top设为n+1，则元素x进栈的正确操作是( )。 A．top++; V[top]=x; B．V[top]=x; top++; C．top–; V[top]=x; D．V[top]=x; top–; 答案：C 解释：初始栈顶指针top为n+1，说明元素从数组向量的高端地址进栈，又因为元素存储在向量空间V[1..n]中，所以进栈时top指针先下移变为n，之后将元素x存储在V[n]。 （10）设计一个判别表达式中左，右括号是否配对出现的算法，采用（ ）数据结构最佳。 A．线性表的顺序存储结构 B．队列 C. 线性表的链式存储结构 D. 栈 答案：D 解释：利用栈的后进先出原则。 （11）用链接方式存储的队列，在进行删除运算时（ ）。 A. 仅修改头指针 B. 仅修改尾指针 C. 头、尾指针都要修改 D. 头、尾指针可能都要修改 答案：D 解释：一般情况下只修改头指针，但是，当删除的是队列中最后一个元素时，队尾指针也丢失了，因此需对队尾指针重新赋值。 （12）循环队列存储在数组A[0..m]中，则入队时的操作为（ ）。 A. rear=rear+1 B. rear=(rear+1)%(m-1) C. rear=(rear+1)%m D. rear=(rear+1)%(m+1) 答案：D 解释：数组A[0..m]中共含有m+1个元素，故在求模运算时应除以m+1。 （13）最大容量为n的循环队列，队尾指针是rear，队头是front，则队空的条件是（ ）。 A. (rear+1)%n==front B. rear==front C．rear+1==front D. (rear-l)%n==front 答案：B 解释：最大容量为n的循环队列，队满条件是(rear+1)%n==front，队空条件是rear==front。 （14）栈和队列的共同点是（ ）。 A. 都是先进先出 B. 都是先进后出 C. 只允许在端点处插入和删除元素 D. 没有共同点 答案：C 解释：栈只允许在栈顶处进行插入和删除元素，队列只允许在队尾插入元素和在队头删除元素。 （15）一个递归算法必须包括（ ）。 A. 递归部分 B. 终止条件和递归部分 C. 迭代部分 D. 终止条件和迭代部分 答案：B 2．算法设计题 （1）将编号为0和1的两个栈存放于一个数组空间V[m]中，栈底分别处于数组的两端。当第0号栈的栈顶指针top[0]等于-1时该栈为空，当第1号栈的栈顶指针top[1]等于m时该栈为空。两个栈均从两端向中间增长。试编写双栈初始化，判断栈空、栈满、进栈和出栈等算法的函数。双栈数据结构的定义如下： Typedef struct {int top[2],bot[2]; //栈顶和栈底指针 SElemType *V; //栈数组 int m; //栈最大可容纳元素个数 }DblStack [题目分析] 两栈共享向量空间，将两栈栈底设在向量两端，初始时，左栈顶指针为-1，右栈顶为m。两栈顶指针相邻时为栈满。两栈顶相向、迎面增长，栈顶指针指向栈顶元素。 [算法描述] (1) 栈初始化123456789int Init() &#123;S.top[0]=-1; S.top[1]=m; return 1; //初始化成功&#125; (2) 入栈操作：1234567891011121314151617int push(stk S ,int i,int x)∥i为栈号，i=0表示左栈，i=1为右栈，x是入栈元素。入栈成功返回1，失败返回0&#123;if(i&lt;0||i&gt;1)&#123; cout&lt;&lt;“栈号输入不对”&lt;&lt;endl;exit(0);&#125;if(S.top[1]-S.top[0]==1) &#123;cout&lt;&lt;“栈已满”&lt;&lt;endl;return(0);&#125;switch(i) &#123;case 0: S.V[++S.top[0]]=x; return(1); break;case 1: S.V[--S.top[1]]=x; return(1);&#125;&#125;∥push (3) 退栈操作123456789101112131415161718192021ElemType pop(stk S,int i)∥退栈。i代表栈号，i=0时为左栈，i=1时为右栈。退栈成功时返回退栈元素∥否则返回-1&#123;if(i&lt;0 || i&gt;1)&#123;cout&lt;&lt;“栈号输入错误”&lt;&lt;endl；exit(0);&#125; switch(i)&#123;case 0: if(S.top[0]==-1) &#123;cout&lt;&lt;“栈空”&lt;&lt;endl；return（-1）；&#125;else return(S.V[S.top[0]--]);case 1: if(S.top[1]==m &#123; cout&lt;&lt;“栈空”&lt;&lt;endl; return(-1);&#125;else return(S.V[S.top[1]++]); &#125;∥switch &#125;∥算法结束 (4) 判断栈空12345int Empty();&#123;return (S.top[0]==-1 &amp;&amp; S.top[1]==m);&#125; [算法讨论] 请注意算法中两栈入栈和退栈时的栈顶指针的计算。左栈是通常意义下的栈，而右栈入栈操作时，其栈顶指针左移（减1），退栈时，栈顶指针右移（加1）。 （2）回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。试写一个算法判定给定的字符向量是否为回文。(提示：将一半字符入栈) [题目分析] 将字符串前一半入栈，然后，栈中元素和字符串后一半进行比较。即将第一个出栈元素和后一半串中第一个字符比较，若相等，则再出栈一个元素与后一个字符比较，……，直至栈空，结论为字符序列是回文。在出栈元素与串中字符比较不等时，结论字符序列不是回文。 [算法描述]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#define StackSize 100 //假定预分配的栈空间最多为100个元素typedef char DataType;//假定栈元素的数据类型为字符typedef struct&#123;DataType data[StackSize];int top;&#125;SeqStack; int IsHuiwen( char *t)&#123;//判断t字符向量是否为回文，若是，返回1，否则返回0SeqStack s;int i , len;char temp;InitStack( &amp;s);len=strlen(t); //求向量长度for ( i=0; i&lt;len/2; i++)//将一半字符入栈Push( &amp;s, t[i]);while( !EmptyStack( &amp;s))&#123;// 每弹出一个字符与相应字符比较temp=Pop (&amp;s);if( temp!=S[i]) return 0 ;// 不等则返回0else i++;&#125; return 1 ; // 比较完毕均相等则返回 1&#125; （3）设从键盘输入一整数的序列：a1, a2, a3，…，an，试编写算法实现：用栈结构存储输入的整数，当ai≠-1时，将ai进栈；当ai=-1时，输出栈顶整数并出栈。算法应对异常情况（入栈满等）给出相应的信息。 [算法描述]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#define maxsize 栈空间容量void InOutS(int s[maxsize])//s是元素为整数的栈，本算法进行入栈和退栈操作。&#123;int top=0; //top为栈顶指针，定义top=0时为栈空。 for(i=1; i&lt;=n; i++) //n个整数序列作处理。 &#123;cin&gt;&gt;x); //从键盘读入整数序列。 if(x!=-1) // 读入的整数不等于-1时入栈。 ｛if(top==maxsize-1)&#123;cout&lt;&lt;“栈满”&lt;&lt;endl;exit(0);&#125;else s[++top]=x; //x入栈。｝ else //读入的整数等于-1时退栈。 &#123;if(top==0)&#123; cout&lt;&lt;“栈空”&lt;&lt;endl;exit(0);&#125;else cout&lt;&lt;“出栈元素是”&lt;&lt; s[top--]&lt;&lt;endl;&#125; &#125;&#125;//算法结束。``` （4）从键盘上输入一个后缀表达式，试编写算法计算表达式的值。规定：逆波兰表达式的长度不超过一行，以$符作为输入结束，操作数之间用空格分隔,操作符只可能有+、-、*、/四种运算。例如：234 34+2*$。[题目分析]逆波兰表达式(即后缀表达式)求值规则如下：设立运算数栈OPND,对表达式从左到右扫描(读入)，当表达式中扫描到数时，压入OPND栈。当扫描到运算符时，从OPND退出两个数，进行相应运算，结果再压入OPND栈。这个过程一直进行到读出表达式结束符$，这时OPND栈中只有一个数，就是结果。[算法描述]```shfloat expr( )//从键盘输入逆波兰表达式，以‘$’表示输入结束，本算法求逆波兰式表达式的值。｛float OPND[30]; // OPND是操作数栈。init(OPND); //两栈初始化。float num=0.0; //数字初始化。cin&gt;&gt;x;//x是字符型变量。while(x!=’$’) &#123;switch &#123;case‘0’&lt;=x&lt;=’9’:while((x&gt;=’0’&amp;&amp;x&lt;=’9’)||x==’.’) //拼数if(x!=’.’) //处理整数&#123;num=num*10+（ord(x)-ord(‘0’)）; cin&gt;&gt;x;&#125;else //处理小数部分。&#123;scale=10.0; cin&gt;&gt;x;while(x&gt;=’0’&amp;&amp;x&lt;=’9’)&#123;num=num+(ord(x)-ord(‘0’)/scale;scale=scale*10; cin&gt;&gt;x; &#125;&#125;//elsepush(OPND,num); num=0.0;//数压入栈，下个数初始化 case x=‘ ’:break; //遇空格，继续读下一个字符。 case x=‘+’:push(OPND,pop(OPND)+pop(OPND));break; case x=‘-’:x1=pop(OPND);x2=pop(OPND);push(OPND,x2-x1);break; case x=‘*’:push(OPND,pop(OPND)*pop(OPND));break; case x=‘/’:x1=pop(OPND);x2=pop(OPND);push(OPND,x2/x1);break; default: //其它符号不作处理。 &#125;//结束switch cin&gt;&gt;x;//读入表达式中下一个字符。 &#125;//结束while（x！=‘$’）cout&lt;&lt;“后缀表达式的值为”&lt;&lt;pop(OPND);&#125;//算法结束。 [算法讨论]假设输入的后缀表达式是正确的，未作错误检查。算法中拼数部分是核心。若遇到大于等于‘0’且小于等于‘9’的字符，认为是数。这种字符的序号减去字符‘0’的序号得出数。对于整数，每读入一个数字字符，前面得到的部分数要乘上10再加新读入的数得到新的部分数。当读到小数点，认为数的整数部分已完，要接着处理小数部分。小数部分的数要除以10（或10的幂数）变成十分位，百分位，千分位数等等，与前面部分数相加。在拼数过程中，若遇非数字字符，表示数已拼完，将数压入栈中，并且将变量num恢复为0，准备下一个数。这时对新读入的字符进入‘+’、‘-’、‘*’、‘/’及空格的判断，因此在结束处理数字字符的case后，不能加入break语句。 （5）假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，称可以操作的序列为合法序列，否则称为非法序列。 ①下面所示的序列中哪些是合法的？ A. IOIIOIOO B. IOOIOIIO C. IIIOIOIO D. IIIOOIOO ②通过对①的分析，写出一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回false（假定被判定的操作序列已存入一维数组中）。 答案： ①A和D是合法序列，B和C 是非法序列。 ②设被判定的操作序列已存入一维数组A中。12345678910111213141516171819202122232425int Judge(char A[]) //判断字符数组A中的输入输出序列是否是合法序列。如是，返回true，否则返回false。 &#123;i=0; //i为下标。 j=k=0; //j和k分别为I和字母O的的个数。 while(A[i]!=‘\0’) //当未到字符数组尾就作。 &#123;switch(A[i]) &#123;case‘I’: j++; break; //入栈次数增1。 case‘O’: k++; if(k&gt;j)&#123;cout&lt;&lt;“序列非法”&lt;&lt;ednl；exit(0);&#125; &#125;i++; //不论A[i]是‘I’或‘O’，指针i均后移。&#125; if(j!=k) &#123;cout&lt;&lt;“序列非法”&lt;&lt;endl；return(false);&#125; else &#123; cout&lt;&lt;“序列合法”&lt;&lt;endl；return(true);&#125; &#125;//算法结束。 [算法讨论]在入栈出栈序列（即由‘I’和‘O’组成的字符串）的任一位置，入栈次数（‘I’的个数）都必须大于等于出栈次数（即‘O’的个数），否则视作非法序列，立即给出信息，退出算法。整个序列（即读到字符数组中字符串的结束标记‘\0’），入栈次数必须等于出栈次数（题目中要求栈的初态和终态都为空），否则视为非法序列。 (6）假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素站点(注意不设头指针) ，试编写相应的置空队、判队空 、入队和出队等算法。 [题目分析] 置空队就是建立一个头节点，并把头尾指针都指向头节点，头节点是不存放数据的；判队空就是当头指针等于尾指针时，队空；入队时，将新的节点插入到链队列的尾部，同时将尾指针指向这个节点；出队时，删除的是队头节点，要注意队列的长度大于1还是等于1的情况，这个时候要注意尾指针的修改，如果等于1，则要删除尾指针指向的节点。 [算法描述]123456789101112131415//先定义链队结构:typedef struct queuenode&#123;Datatype data;struct queuenode *next;&#125;QueueNode; //以上是结点类型的定义typedef struct&#123;queuenode *rear;&#125;LinkQueue; //只设一个指向队尾元素的指针 (1) 置空队1234567891011121314151617void InitQueue( LinkQueue *Q)&#123; //置空队：就是使头结点成为队尾元素 QueueNode *s;Q-&gt;rear = Q-&gt;rear-&gt;next;//将队尾指针指向头结点while (Q-&gt;rear!=Q-&gt;rear-&gt;next)//当队列非空，将队中元素逐个出队&#123;s=Q-&gt;rear-&gt;next;Q-&gt;rear-&gt;next=s-&gt;next;delete s; &#125;//回收结点空间&#125; (2) 判队空1234567int EmptyQueue( LinkQueue *Q)&#123; //判队空。当头结点的next指针指向自己时为空队 return Q-&gt;rear-&gt;next-&gt;next==Q-&gt;rear-&gt;next;&#125; (3) 入队12345678910111213void EnQueue( LinkQueue *Q, Datatype x)&#123; //入队。也就是在尾结点处插入元素QueueNode *p=new QueueNode;//申请新结点p-&gt;data=x; p-&gt;next=Q-&gt;rear-&gt;next;//初始化新结点并链入Q-rear-&gt;next=p; Q-&gt;rear=p;//将尾指针移至新结点&#125; (4) 出队1234567891011121314151617181920212223242526272829303132333435Datatype DeQueue( LinkQueue *Q)&#123;//出队,把头结点之后的元素摘下Datatype t;QueueNode *p;if(EmptyQueue( Q ))Error("Queue underflow");p=Q-&gt;rear-&gt;next-&gt;next; //p指向将要摘下的结点x=p-&gt;data; //保存结点中数据if (p==Q-&gt;rear)&#123;//当队列中只有一个结点时，p结点出队后，要将队尾指针指向头结点 Q-&gt;rear = Q-&gt;rear-&gt;next;Q-&gt;rear-&gt;next=p-&gt;next;&#125;else Q-&gt;rear-&gt;next-&gt;next=p-&gt;next;//摘下结点pdelete p;//释放被删结点return x;&#125; （7）假设以数组Q[m]存放循环队列中的元素, 同时设置一个标志tag，以tag == 0和tag == 1来区别在队头指针(front)和队尾指针(rear)相等时，队列状态为“空”还是“满”。试编写与此结构相应的插入(enqueue)和删除(dlqueue)算法。 [算法描述] (1)初始化123456789SeQueue QueueInit(SeQueue Q)&#123;//初始化队列Q.front=Q.rear=0; Q.tag=0;return Q;&#125; (2)入队12345678910111213141516171819SeQueue QueueIn(SeQueue Q,int e)&#123;//入队列if((Q.tag==1) &amp;&amp; (Q.rear==Q.front)) cout&lt;&lt;"队列已满"&lt;&lt;endl;else &#123;Q.rear=(Q.rear+1) % m;Q.data[Q.rear]=e;if(Q.tag==0) Q.tag=1; //队列已不空&#125;return Q;&#125; (3)出队1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071ElemType QueueOut(SeQueue Q)&#123;//出队列if(Q.tag==0) &#123; cout&lt;&lt;"队列为空"&lt;&lt;endl; exit(0);&#125;else&#123;Q.front=(Q.front+1) % m;e=Q.data[Q.front];if(Q.front==Q.rear) Q.tag=0; //空队列&#125;return(e);&#125;``` (8）如果允许在循环队列的两端都可以进行插入和删除操作。要求：① 写出循环队列的类型定义；② 写出“从队尾删除”和“从队头插入”的算法。[题目分析] 用一维数组 v[0..M-1]实现循环队列，其中M是队列长度。设队头指针 front和队尾指针rear，约定front指向队头元素的前一位置，rear指向队尾元素。定义front=rear时为队空，(rear+1)%m=front 为队满。约定队头端入队向下标小的方向发展，队尾端入队向下标大的方向发展。[算法描述]①```sh#define M 队列可能达到的最大长度typedef struct&#123;elemtp data[M];int front,rear;&#125;cycqueue;②elemtp delqueue ( cycqueue Q) //Q是如上定义的循环队列，本算法实现从队尾删除，若删除成功，返回被删除元素，否则给出出错信息。&#123;if (Q.front==Q.rear) &#123; cout&lt;&lt;"队列空"&lt;&lt;endl; exit(0);&#125;Q.rear=(Q.rear-1+M)%M; //修改队尾指针。return(Q.data[(Q.rear+1+M)%M]); //返回出队元素。&#125;//从队尾删除算法结束 void enqueue (cycqueue Q, elemtp x)// Q是顺序存储的循环队列，本算法实现“从队头插入”元素x。&#123;if (Q.rear==(Q.front-1+M)%M) &#123; cout&lt;&lt;"队满"&lt;&lt;endl; exit(0);) Q.data[Q.front]=x; //x 入队列Q.front=(Q.front-1+M)%M; //修改队头指针。&#125;// 结束从队头插入算法。 （9）已知Ackermann函数定义如下: ① 写出计算Ack(m,n)的递归算法，并根据此算法给出出Ack(2,1)的计算过程。 ② 写出计算Ack(m,n)的非递归算法。 [算法描述]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int Ack(int m,n)&#123;if (m==0) return(n+1); else if(m!=0&amp;&amp;n==0) return(Ack(m-1,1)); else return(Ack(m-1,Ack(m,m-1)); &#125;//算法结束① Ack(2,1)的计算过程Ack(2,1)= Ack(1,Ack(2,0)) //因m&lt;&gt;0,n&lt;&gt;0而得= Ack(1,Ack(1,1)) //因m&lt;&gt;0,n=0而得= Ack(1,Ack(0,Ack(1,0))) // 因m&lt;&gt;0,n&lt;&gt;0而得= Ack(1,Ack(0,Ack(0,1))) // 因m&lt;&gt;0,n=0而得= Ack(1,Ack(0,2)) // 因m=0而得= Ack(1,3) // 因m=0而得= Ack(0,Ack(1,2)) //因m&lt;&gt;0,n&lt;&gt;0而得= Ack(0,Ack(0,Ack(1,1))) //因m&lt;&gt;0,n&lt;&gt;0而得= Ack(0,Ack(0,Ack(0,Ack(1,0)))) //因m&lt;&gt;0,n&lt;&gt;0而得= Ack(0,Ack(0,Ack(0,Ack(0,1)))) //因m&lt;&gt;0,n=0而得= Ack(0,Ack(0,Ack(0,2))) //因m=0而得= Ack(0,Ack(0,3)) //因m=0而得= Ack(0,4) //因n=0而得=5 //因n=0而得②int Ackerman(int m, int n)&#123;int akm[M][N];int i,j;for(j=0;j&lt;N;j++) akm[0][j]=j+1;for(i=1;i&lt;m;i++)&#123;akm[i][0]=akm[i-1][1];for(j=1;j&lt;N;j++)akm[i][j]=akm[i-1][akm[i][j-1]];&#125;return(akm[m][n]);&#125;//算法结束 （10）已知f为单链表的表头指针, 链表中存储的都是整型数据，试写出实现下列运算的递归算法： ① 求链表中的最大整数； ② 求链表的结点个数； ③ 求所有整数的平均值。 [算法描述]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263①int GetMax(LinkList p)&#123;if(!p-&gt;next)return p-&gt;data;else&#123;int max=GetMax(p-&gt;next);return p-&gt;data&gt;=max ? p-&gt;data:max;&#125;&#125;②int GetLength(LinkList p)&#123;if(!p-&gt;next)return 1;else&#123;return GetLength(p-&gt;next)+1;&#125;&#125;③double GetAverage(LinkList p , int n)&#123;if(!p-&gt;next)return p-&gt;data;else&#123;double ave=GetAverage(p-&gt;next,n-1);return (ave*(n-1)+p-&gt;data)/n;&#125;&#125;]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构--练习第2章 线性表]]></title>
    <url>%2Fyear%2F05%2F23%2F59462%2F</url>
    <content type="text"><![CDATA[1．选择题 （1）顺序表中第一个元素的存储地址是100，每个元素的长度为2，则第5个元素的地址是（ ）。 A．110 B．108 C．100 D．120 答案：B 解释：顺序表中的数据连续存储，所以第5个元素的地址为：100+2*4=108。 （2）在n个结点的顺序表中，算法的时间复杂度是O(1)的操作是（ ）。 A．访问第i个结点（1≤i≤n）和求第i个结点的直接前驱（2≤i≤n） B．在第i个结点后插入一个新结点（1≤i≤n） C．删除第i个结点（1≤i≤n） D．将n个结点从小到大排序 答案：A 解释：在顺序表中插入一个结点的时间复杂度都是O(n2)，排序的时间复杂度为O(n2)或O(nlog2n)。顺序表是一种随机存取结构，访问第i个结点和求第i个结点的直接前驱都可以直接通过数组的下标直接定位，时间复杂度是O(1)。 （3） 向一个有127个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动 的元素个数为（ ）。 A．8 B．63.5 C．63 D．7 答案：B 解释：平均要移动的元素个数为：n/2。 （4）链接存储的存储结构所占存储空间（ ）。 A．分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针 B．只有一部分，存放结点值 C．只有一部分，存储表示结点间关系的指针 D．分两部分，一部分存放结点值，另一部分存放结点所占单元数 答案：A （5）线性表若采用链式存储结构时，要求内存中可用存储单元的地址（ ）。 A．必须是连续的 B．部分地址必须是连续的 C．一定是不连续的 D．连续或不连续都可以 答案：D （6）线性表Ｌ在（ ）情况下适用于使用链式结构实现。 A．需经常修改Ｌ中的结点值 Ｂ．需不断对Ｌ进行删除插入 C．Ｌ中含有大量的结点 Ｄ．Ｌ中结点结构复杂 答案：B 解释：链表最大的优点在于插入和删除时不需要移动数据，直接修改指针即可。 （7）单链表的存储密度（ ）。 A．大于1 B．等于1 C．小于1 D．不能确定 答案：C 解释：存储密度是指一个结点数据本身所占的存储空间和整个结点所占的存储空间之比，假设单链表一个结点本身所占的空间为D，指针域所占的空间为N，则存储密度为：D/(D+N)，一定小于1。 （8）将两个各有n个元素的有序表归并成一个有序表，其最少的比较次数是（ ）。 A．n B．2n-1 C．2n D．n-1 答案：A 解释：当第一个有序表中所有的元素都小于（或大于）第二个表中的元素，只需要用第二个表中的第一个元素依次与第一个表的元素比较，总计比较n次。 （9）在一个长度为n的顺序表中，在第i个元素（1≤i≤n+1）之前插入一个新元素时须向后移动（ ）个元素。 A．n-i B．n-i+1 C．n-i-1 D．I 答案：B (10)线性表L=(a1，a2,……an)，下列说法正确的是（ ）。 A．每个元素都有一个直接前驱和一个直接后继 B．线性表中至少有一个元素 C．表中诸元素的排列必须是由小到大或由大到小 D．除第一个和最后一个元素外，其余每个元素都有一个且仅有一个直接前驱和直接后继。 答案：D (11)创建一个包括n个结点的有序单链表的时间复杂度是（ ）。 A．O(1) B．O(n) C．O(n2) D．O(nlog2n) 答案：C 解释：单链表创建的时间复杂度是O(n)，而要建立一个有序的单链表，则每生成一个新结点时需要和已有的结点进行比较，确定合适的插入位置，所以时间复杂度是O(n2)。 (12)以下说法错误的是（ ）。 A．求表长、定位这两种运算在采用顺序存储结构时实现的效率不比采用链式存储结构时实现的效率低 B．顺序存储的线性表可以随机存取 C．由于顺序存储要求连续的存储区域，所以在存储管理上不够灵活 D．线性表的链式存储结构优于顺序存储结构 答案：D 解释：链式存储结构和顺序存储结构各有优缺点，有不同的适用场合。 (13)在单链表中，要将s所指结点插入到p所指结点之后，其语句应为（ ）。 A．s-&gt;next=p+1; p-&gt;next=s; B．(p).next=s; (s).next=(*p).next; C．s-&gt;next=p-&gt;next; p-&gt;next=s-&gt;next; D．s-&gt;next=p-&gt;next; p-&gt;next=s; 答案：D (14)在双向链表存储结构中，删除p所指的结点时须修改指针（ ）。 A．p-&gt;next-&gt;prior=p-&gt;prior; p-&gt;prior-&gt;next=p-&gt;next; B．p-&gt;next=p-&gt;next-&gt;next; p-&gt;next-&gt;prior=p; C．p-&gt;prior-&gt;next=p; p-&gt;prior=p-&gt;prior-&gt;prior; D．p-&gt;prior=p-&gt;next-&gt;next; p-&gt;next=p-&gt;prior-&gt;prior; 答案：A (15)在双向循环链表中，在p指针所指的结点后插入q所指向的新结点，其修改指针的操作是（ ）。 A．p-&gt;next=q; q-&gt;prior=p; p-&gt;next-&gt;prior=q; q-&gt;next=q; B．p-&gt;next=q; p-&gt;next-&gt;prior=q; q-&gt;prior=p; q-&gt;next=p-&gt;next; C．q-&gt;prior=p; q-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=q; p-&gt;next=q; D．q-&gt;prior=p; q-&gt;next=p-&gt;next; p-&gt;next=q; p-&gt;next-&gt;prior=q; 答案：C 2．算法设计题 （1）将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间, 不另外占用其它的存储空间。表中不允许有重复的数据。 [题目分析] 合并后的新表使用头指针Lc指向，pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，依次摘取其中较小者重新链接在Lc表的最后。如果两个表中的元素相等，只摘取La表中的元素，删除Lb表中的元素，这样确保合并后表中无重复的元素。当一个表到达表尾结点，为空时，将非空表的剩余元素直接链接在Lc表的最后。 [算法描述]1234567891011121314151617181920212223242526272829303132333435void MergeList(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123;//合并链表La和Lb，合并后的新表使用头指针Lc指向 pa=La-&gt;next; pb=Lb-&gt;next; //pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点 Lc=pc=La; //用La的头结点作为Lc的头结点 while(pa &amp;&amp; pb)&#123;if(pa-&gt;data&lt;pb-&gt;data)&#123;pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;&#125; //取较小者La中的元素，将pa链接在pc的后面，pa指针后移 else if(pa-&gt;data&gt;pb-&gt;data) &#123;pc-&gt;next=pb; pc=pb; pb=pb-&gt;next;&#125; //取较小者Lb中的元素，将pb链接在pc的后面，pb指针后移 else //相等时取La中的元素，删除Lb中的元素&#123;pc-&gt;next=pa;pc=pa;pa=pa-&gt;next; q=pb-&gt;next;delete pb ;pb =q;&#125; &#125; pc-&gt;next=pa?pa:pb; //插入剩余段 delete Lb; //释放Lb的头结点&#125; （2）将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间, 不另外占用其它的存储空间。表中允许有重复的数据。 [题目分析] 合并后的新表使用头指针Lc指向，pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，依次摘取其中较小者重新链接在Lc表的表头结点之后，如果两个表中的元素相等，只摘取La表中的元素，保留Lb表中的元素。当一个表到达表尾结点，为空时，将非空表的剩余元素依次摘取，链接在Lc表的表头结点之后。 [算法描述]1234567891011121314151617181920212223242526272829303132333435363738394041void MergeList(LinkList&amp; La, LinkList&amp; Lb, LinkList&amp; Lc, )&#123;//合并链表La和Lb，合并后的新表使用头指针Lc指向 pa=La-&gt;next; pb=Lb-&gt;next;//pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点 Lc=pc=La; //用La的头结点作为Lc的头结点 Lc-&gt;next=NULL; while(pa||pb )&#123;//只要存在一个非空表，用q指向待摘取的元素 if(!pa) &#123;q=pb; pb=pb-&gt;next;&#125;//La表为空，用q指向pb，pb指针后移 else if(!pb) &#123;q=pa; pa=pa-&gt;next;&#125;//Lb表为空，用q指向pa，pa指针后移 else if(pa-&gt;data&lt;=pb-&gt;data) &#123;q=pa; pa=pa-&gt;next;&#125;//取较小者（包括相等）La中的元素，用q指向pa，pa指针后移 else &#123;q=pb; pb=pb-&gt;next;&#125;//取较小者Lb中的元素，用q指向pb，pb指针后移 q-&gt;next = Lc-&gt;next; Lc-&gt;next = q; //将q指向的结点插在Lc 表的表头结点之后 &#125; delete Lb; //释放Lb的头结点&#125; （3）已知两个链表A和B分别表示两个集合，其元素递增排列。请设计算法求出A与B的交集，并存放于A链表中。 [题目分析] 只有同时出现在两集合中的元素才出现在结果表中,合并后的新表使用头指针Lc指向。pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，如果两个表中相等的元素时，摘取La表中的元素，删除Lb表中的元素；如果其中一个表中的元素较小时，删除此表中较小的元素，此表的工作指针后移。当链表La和Lb有一个到达表尾结点，为空时，依次删除另一个非空表中的所有元素。 [算法描述]12345678910111213141516171819202122232425262728293031voidMix(LinkList&amp; La, LinkList&amp; Lb, LinkList&amp; Lc)&#123; pa=La-&gt;next;pb=Lb-&gt;next; pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点Lc=pc=La; //用La的头结点作为Lc的头结点while(pa&amp;&amp;pb)&#123; if(pa-&gt;data==pb-&gt;data)∥交集并入结果表中。 &#123; pc-&gt;next=pa;pc=pa;pa=pa-&gt;next; u=pb;pb=pb-&gt;next; delete u;&#125; else if(pa-&gt;data&lt;pb-&gt;data) &#123;u=pa;pa=pa-&gt;next; delete u;&#125;else &#123;u=pb; pb=pb-&gt;next;delete u;&#125;&#125;while(pa) &#123;u=pa; pa=pa-&gt;next; delete u;&#125;∥释放结点空间while(pb) &#123;u=pb; pb=pb-&gt;next;delete u;&#125;∥释放结点空间pc-&gt;next=null;∥置链表尾标记。delete Lb; //释放Lb的头结点 &#125; （4）已知两个链表A和B分别表示两个集合，其元素递增排列。请设计算法求出两个集合A和B的差集（即仅由在A中出现而不在B中出现的元素所构成的集合），并以同样的形式存储，同时返回该集合的元素个数。 [题目分析] 求两个集合A和B的差集是指在A中删除A和B中共有的元素，即删除链表中的相应结点,所以要保存待删除结点的前驱，使用指针pre指向前驱结点。pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，如果La表中的元素小于Lb表中的元素，pre置为La表的工作指针pa删除Lb表中的元素；如果其中一个表中的元素较小时，删除此表中较小的元素，此表的工作指针后移。当链表La和Lb有一个为空时，依次删除另一个非空表中的所有元素。 [算法描述]12345678910111213141516171819202122232425voidDifference（LinkList&amp; La, LinkList&amp; Lb,int*n）&#123;∥差集的结果存储于单链表La中，*n是结果集合中元素个数，调用时为0pa=La-&gt;next; pb=Lb-&gt;next; ∥pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点 pre=La; ∥pre为La中pa所指结点的前驱结点的指针 while（pa&amp;&amp;pb）&#123;if（pa-&gt;data&lt;q-&gt;data）&#123;pre=pa;pa=pa-&gt;next;*n++;&#125;∥ A链表中当前结点指针后移else if（pa-&gt;data&gt;q-&gt;data）q=q-&gt;next; ∥B链表中当前结点指针后移 else &#123;pre-&gt;next=pa-&gt;next; ∥处理A，B中元素值相同的结点，应删除 u=pa; pa=pa-&gt;next; delete u;&#125; ∥删除结点&#125;&#125; （5）设计算法将一个带头结点的单链表A分解为两个具有相同结构的链表B、C，其中B表的结点为A表中值小于零的结点，而C表的结点为A表中值大于零的结点（链表A中的元素为非零整数，要求B、C表利用A表的结点）。 [题目分析] B表的头结点使用原来A表的头结点，为C表新申请一个头结点。从A表的第一个结点开始，依次取其每个结点p，判断结点p的值是否小于0，利用前插法，将小于0的结点插入B表,大于等于0的结点插入C表。 [算法描述]123456789101112131415161718192021222324252627void DisCompose(LinkedList A)&#123; B=A;B-&gt;next= NULL; ∥B表初始化 C=newLNode;∥为C申请结点空间 C-&gt;next=NULL; ∥C初始化为空表 p=A-&gt;next; ∥p为工作指针 while(p!= NULL) &#123; r=p-&gt;next; ∥暂存p的后继 if(p-&gt;data&lt;0) &#123;p-&gt;next=B-&gt;next; B-&gt;next=p; &#125;∥将小于0的结点链入B表,前插法 else &#123;p-&gt;next=C-&gt;next; C-&gt;next=p; &#125;∥将大于等于0的结点链入C表,前插法 p=r;∥p指向新的待处理结点。 &#125;&#125; （6）设计一个算法，通过一趟遍历在单链表中确定值最大的结点。 [题目分析] 假定第一个结点中数据具有最大值，依次与下一个元素比较，若其小于下一个元素，则设其下一个元素为最大值，反复进行比较，直到遍历完该链表。 [算法描述]1234567891011121314151617ElemType Max (LinkList L )&#123;if(L-&gt;next==NULL) return NULL;pmax=L-&gt;next; //假定第一个结点中数据具有最大值p=L-&gt;next-&gt;next;while(p != NULL )&#123;//如果下一个结点存在if(p-&gt;data &gt; pmax-&gt;data) pmax=p;//如果p的值大于pmax的值，则重新赋值p=p-&gt;next;//遍历链表&#125;return pmax-&gt;data; （7）设计一个算法，通过遍历一趟，将链表中所有结点的链接方向逆转，仍利用原表的存储空间。 [题目分析] 从首元结点开始，逐个地把链表L的当前结点p插入新的链表头部。 [算法描述]12345678910111213141516171819void inverse(LinkList &amp;L)&#123;// 逆置带头结点的单链表 L p=L-&gt;next; L-&gt;next=NULL; while ( p) &#123; q=p-&gt;next; // q指向*p的后继 p-&gt;next=L-&gt;next; L-&gt;next=p; // *p插入在头结点之后 p = q; &#125;&#125; （8）设计一个算法，删除递增有序链表中值大于mink且小于maxk的所有元素（mink和maxk是给定的两个参数，其值可以和表中的元素相同，也可以不同 ）。 [题目分析] 分别查找第一个值&gt;mink的结点和第一个值 ≥maxk的结点，再修改指针，删除值大于mink且小于maxk的所有元素。 [算法描述]1234567891011121314151617181920212223void delete(LinkList &amp;L, int mink, int maxk) &#123; p=L-&gt;next; //首元结点 while (p &amp;&amp; p-&gt;data&lt;=mink) &#123; pre=p; p=p-&gt;next; &#125; //查找第一个值&gt;mink的结点 if (p)&#123;while (p &amp;&amp; p-&gt;data&lt;maxk) p=p-&gt;next; // 查找第一个值 ≥maxk的结点 q=pre-&gt;next; pre-&gt;next=p; // 修改指针 while (q!=p) &#123; s=q-&gt;next; delete q; q=s; &#125; // 释放结点空间 &#125;//if&#125; （9）已知p指向双向循环链表中的一个结点，其结点结构为data、prior、next三个域，写出算法change(p),交换p所指向的结点和它的前缀结点的顺序。 [题目分析] 知道双向循环链表中的一个结点，与前驱交换涉及到四个结点（p结点，前驱结点，前驱的前驱结点，后继结点）六条链。 [算法描述]12345678910111213141516171819void Exchange（LinkedList p）∥p是双向循环链表中的一个结点，本算法将p所指结点与其前驱结点交换。&#123;q=p-&gt;llink； q-&gt;llink-&gt;rlink=p； ∥p的前驱的前驱之后继为p p-&gt;llink=q-&gt;llink； ∥p的前驱指向其前驱的前驱。 q-&gt;rlink=p-&gt;rlink； ∥p的前驱的后继为p的后继。 q-&gt;llink=p； ∥p与其前驱交换 p-&gt;rlink-&gt;llink=q； ∥p的后继的前驱指向原p的前驱 p-&gt;rlink=q； ∥p的后继指向其原来的前驱&#125;∥算法exchange结束。 （10）已知长度为n的线性表A采用顺序存储结构，请写一时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为item的数据元素。 [题目分析] 在顺序存储的线性表上删除元素，通常要涉及到一系列元素的移动（删第i个元素，第i+1至第n个元素要依次前移）。本题要求删除线性表中所有值为item的数据元素，并未要求元素间的相对位置不变。因此可以考虑设头尾两个指针（i=1，j=n），从两端向中间移动，凡遇到值item的数据元素时，直接将右端元素左移至值为item的数据元素位置。 [算法描述]12345678910111213void Delete（ElemType A[ ]，int n）∥A是有n个元素的一维数组，本算法删除A中所有值为item的元素。&#123;i=1；j=n；∥设置数组低、高端指针（下标）。 while（i&lt;j） &#123;while（i&lt;j &amp;&amp; A[i]!=item）i++； ∥若值不为item，左移指针。 if（i&lt;j）while（i&lt;j &amp;&amp; A[j]==item）j--；∥若右端元素为item，指针左移 if（i&lt;j）A[i++]=A[j--]；&#125;]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构--练习 第1章 绪论]]></title>
    <url>%2Fyear%2F05%2F23%2F45602%2F</url>
    <content type="text"><![CDATA[1．简述下列概念：数据、数据元素、数据项、数据对象、数据结构、逻辑结构、存储结构、抽象数据类型。 答案： 数据：是客观事物的符号表示，指所有能输入到计算机中并被计算机程序处理的符号的总称。如数学计算中用到的整数和实数，文本编辑所用到的字符串，多媒体程序处理的图形、图像、声音、动画等通过特殊编码定义后的数据。 数据元素：是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为元素、结点、记录等。数据元素用于完整地描述一个对象，如一个学生记录，树中棋盘的一个格局（状态）、图中的一个顶点等。 数据项：是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。 数据对象：是性质相同的数据元素的集合，是数据的一个子集。例如：整数数据对象是集合N={0，±1，±2，…}，字母字符数据对象是集合C={‘A’，‘B’，…，‘Z’， ‘a’，‘b’，…，‘z’}，学生基本信息表也可是一个数据对象。 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。 逻辑结构：从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。 存储结构：数据对象在计算机中的存储表示，也称为物理结构。 抽象数据类型：由用户定义的，表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称。具体包括三部分：数据对象、数据对象上关系的集合和对数据对象的基本操作的集合。 2．试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。 答案： 例如有一张学生基本信息表，包括学生的学号、姓名、性别、籍贯、专业等。每个学生基本信息记录对应一个数据元素，学生记录按顺序号排列，形成了学生基本信息记录的线性序列。对于整个表来说，只有一个开始结点(它的前面无记录)和一个终端结点(它的后面无记录)，其他的结点则各有一个也只有一个直接前趋和直接后继。学生记录之间的这种关系就确定了学生表的逻辑结构，即线性结构。 这些学生记录在计算机中的存储表示就是存储结构。如果用连续的存储单元(如用数组表示)来存放这些记录，则称为顺序存储结构；如果存储单元不连续，而是随机存放各个记录，然后用指针进行链接，则称为链式存储结构。 即相同的逻辑结构，可以对应不同的存储结构。 3．简述逻辑结构的四种基本关系并画出它们的关系图。 答案： （1）集合结构 数据元素之间除了“属于同一集合”的关系外，别无其他关系。例如，确定一名学生是否为班级成员，只需将班级看做一个集合结构。 （2）线性结构 数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报到的时间先后顺序进行排列，将组成一个线性结构。 （3）树结构 数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位组长管理多名组员，从而构成树形结构。 （4）图结构或网状结构 数据元素之间存在多对多的关系。例如，多位同学之间的朋友关系，任何两位同学都可以是朋友，从而构成图形结构或网状结构。 其中树结构和图结构都属于非线性结构。 4．存储结构由哪两种基本的存储方法实现？ 答案： （1）顺序存储结构 顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。 （2）链式存储结构 顺序存储结构要求所有的元素依次存放在一片连续的存储空间中，而链式存储结构，无需占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。所以链式存储结构通常借助于程序设计语言的指针类型来描述。 5．选择题 （1）在数据结构中，从逻辑上可以把数据结构分成（ ）。 A．动态结构和静态结构 B．紧凑结构和非紧凑结构 C．线性结构和非线性结构 D．内部结构和外部结构 答案：C （2）与数据元素本身的形式、内容、相对位置、个数无关的是数据的（ ）。 A．存储结构 B．存储实现 C．逻辑结构 D．运算实现 答案：C （3）通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着（ ）。 A．数据具有同一特点 B．不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致 C．每个数据元素都一样 D．数据元素所包含的数据项的个数要相等 答案：B （4）以下说法正确的是（ ）。 A．数据元素是数据的最小单位 B．数据项是数据的基本单位 C．数据结构是带有结构的各数据项的集合 D．一些表面上很不相同的数据可以有相同的逻辑结构 答案：D 解释：数据元素是数据的基本单位，数据项是数据的最小单位，数据结构是带有结构的各数据元素的集合。 （5）算法的时间复杂度取决于（ ）。 A．问题的规模B．待处理数据的初态 C．计算机的配置D．A和B 答案：D 解释：算法的时间复杂度不仅与问题的规模有关，还与问题的其他因素有关。如某些排序的算法，其执行时间与待排序记录的初始状态有关。为此，有时会对算法有最好、最坏以及平均时间复杂度的评价。 （6）以下数据结构中，（ ）是非线性数据结构 A．树 B．字符串 C．队列 D．栈 答案：A 6．试分析下面各程序段的时间复杂度。 （1）123456789x=90; y=100; while(y&gt;0)if(x&gt;100) &#123;x=x-10;y--;&#125;else x++; 答案：O(1) 解释：程序的执行次数为常数阶。 （2）12345for (i=0; i&lt;n; i++)for (j=0; j&lt;m; j++)a[i][j]=0; 答案：O(m*n) 解释：语句a[i][j]=0;的执行次数为m*n。 （3）123456789s=0; for i=0; i&lt;n; i++)for(j=0; j&lt;n; j++) s+=B[i][j];sum=s; 答案：O(n2) 解释：语句s+=B[i][j];的执行次数为n2。 （4）12345i=1; while(i&lt;=n) i=i*3; 答案：O(log3n) 解释：语句i=i*3;的执行次数为 ëlog3nû。 （5）1234567x=0;for(i=1; i&lt;n; i++) for (j=1; j&lt;=n-i; j++)x++; 答案：O(n2) 解释：语句x++;的执行次数为n-1+n-2+……＋1= n(n-1)/2。 （6）1234567x=n; //n&gt;1y=0;while(x≥(y+1)* (y+1)) y++; 答案：O(n^0.5) 解释：语句y++;的执行次数为 ëû。]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构--线性表]]></title>
    <url>%2Fyear%2F05%2F22%2F4781%2F</url>
    <content type="text"><![CDATA[线性表、栈、队列、串和数组都属于线性结构。线性结构的基本特点是除第一个元素无直接前驱，最后一个元素无直接后继之外，其他每个数据都有一个前驱和后继。线性表是最基本且最常用的一种线性结构，同时也是其他数据结构的基础。 1.线性表的定义和特点在日常生活中，线性表的例子比比皆是。例如，26个英文字母的字母表：(A,B,C,…,Z)是一个线性表，表中的数据元素是单个字母。 诸如此类由n个数据特性相同的元素构成的有限序列称为线性表.线性表中元素的个数n (n&gt;=0) 定义为线性表的长度，n=0时称为空表。对于非空的线性表或线性结构，其特点是: 存在唯一的一个被称作“第一个”的数据元素; 存在唯一的一个被称作“最后一个”的数据元素; 除第一个之外，结构中的每个数据元素均只有一个前驱; 除最后一个之外，结构中的每个元素均只有一个后继。 2.线性表的顺序表示和实现2.1 线性表的顺序储存表示线性表的顺序表示指的是用一组地址连续的储存单元依次储存线性表的数据元素，这种表示也称作线性表的顺序储存结构或顺序映像。通常，称这种储存结构的线性表为顺序表。其特点是，逻辑上相邻的数据元素，其物理次序也是相邻的。线性表的顺序储存结构是一种随机存取的储存结构。通常都用数组来描述数据结构中的顺序储存结构。 2.2 顺序表中基本操作的实现1.初始化顺序表的初始化操作就是构造一个空的顺序表。 算法2.1 顺序表的初始化[步骤] 为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。 将表的当前长度设为0. [描述]1234567Status InitList(SqList &amp;L)&#123;//构造一个空的顺序表L L.elem = new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) exit(OVERFLOW); //储存分配失败退出 L.length=0; //空表长度为0 return ok;&#125; 动态分配线性表的储存区域可以更有效地利用系统的资源，当不需要该线性表时，可以使用销毁操作及时释放占用的储存空间。 2.取值取值操作是根据指定的位置序号i，获取顺序表中第i个数据元素的值。由于顺序储存结构具有随机存取的特点，可以直接通过数组下标定位得到，elem[i-1] 单元存储第i 个数据元素。 算法2.2 顺序表的取值[算法步骤] 判断指定的位置序号i值是否合理(1=&lt;i&lt;=L.length), 若不合理，则返回ERROR。 若i值合理，则得到第i个数据元素L.elem[i-1]赋给参数e,通过e返回第i个数据元素的传值。 [算法描述]123456Status GetElem(SqList L,int i, ElemType &amp;e)&#123; if(i&lt;1||i&gt;L.length) return ERROR; //判断i是否合理 e=L.elem[i-1]; //elem[i-1] 单元储存第i个数据元素 return OK;&#125; 时间复杂度为 O(1) 3.查找查找操作是根据指定的元素值e，查找顺序表中第1个与e相等的元素。若查找成功，则返回该元素在表中的位置序号；若查找失败，则返回0. 算法 2.3 顺序表的查找[算法步骤] 从第一个元素起，依次和e相比较，若找到与e相等的元素L.elem[i], 则查找成功，返回该元素的序号i+1. 若查遍整个顺序表都没有找到，则查找失败，返回0. [算法描述]123456int LocateElem(SqList L, ElemType e)&#123;//在顺序表L中查找值为e的数据元素，返回其序号 for(i=0;i&lt;L.length;i++) if(L.elem[i]==e) return i+1; //查找成功，返回序号i+1 return 0; //查找失败，返回0&#125; 时间复杂度为 O(n) 4.插入线性表的插入操作是指在表的第i个位置插入一个新的数据元素e,使长度为n的线性表变成长度为n+1的线性表。一般情况下，在第i(1&lt;=i=&lt;n)个位置插入一个元素时，需从最后一个元素即第n个元素开始，依次向后移动一个位置，直至第i个元素(共n-i+1个元素). 算法2.4 顺序表的插入[算法步骤] 判断插入位置i是否合法(i值的合法范围是1&lt;=i=&lt;n+1),若不合法则返回ERROR。 判断顺序表的存储空间是否已满，若满则返回ERROR。 将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置(i=n+1时无需移动). 将要插入的新元素e放入第i个位置。 表长加1。 [算法描述]12345678910Status ListInsert(SqList &amp;L,int i, ElemType e)&#123;//在顺序表L中第i个位置插入新的元素e,i值的合法范围是1=&lt;i&lt;=L.length+1 if((i&lt;1)||(i&gt;L.length+1)) return ERROR; //i值不合法 if(L.length==MAXSIZE) return ERROR; //当前存储空间已满 for(j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 ++L.length; //表长加1 return OK;&#125; 时间复杂度为 O(n) 5.删除线性表的删除操作是指将表的第i个元素删去，将长度为n的线性表变成为n-1的线性表。一般情况下，删除第i（1=&lt;i&lt;=n)个元素时需将第i+1 个至第n个元素(共n-i个元素） 依次向前移动一个位置（i=n时无需移动）。 算法 2.5 顺序表的删除[算法步骤] 判断删除位置i是否合法（合法值为 1&lt;=i&lt;=n_,若不合法则返回ERROR。 将第 i+1 个至第n个的元素依次向前移动一个位置(i=n 时无需移动)。 表长减1. [算法描述]12345678Status ListDelete(SqList &amp;L,int i)&#123; //在顺序表L中删除第i个元素，i值的合法范围是 1&lt;=i&lt;=L.length if((i&lt;1)||(i&gt;L.length)) return ERROR; //i值不合法 for(j=i;j&lt;=L.length-1;j++) L.elem[j-1]=L.elem[j]; //被删除元素之后的元素前移 --L.length; //表长减1 rturn OK;&#125; 时间复杂度为 O(n) 3.线性表的链式表示和实现3.1单链表的定义和表示线性表链式存储结构的特点是:用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的，也可以是不连续的)。因此，为了表示每个数据元素 ai与其直接后继数据元素 ai+1 之间的逻辑关系，对数据元素 ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素ai的存储映像，称为 结点 (node)。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称作指针或链。n个结点链结成一个链表。又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表。用单链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。换句话说，指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻。 单链表可由头指针唯一确定 在C语言中可用“结构指针”来描述：123456//--------单链表的存储结构------------typedef struct LNode&#123; ElemType data; //结点的数据域 struct LNode *next; //结点的指针域&#125;LNode, *LinkList; // LinkList为指向结构体LNode的指针类型 为了提高程序的可读性，在此对同一结构体指针类型起了两个名称，LinkList与LNode,两者本质上是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针；用LNode 定义指向单链表中任意结点的指针变量。例如，若定义LinkList L,则L为单链表的头指针，若定义LNodep ，则P为指向单链表中某个结点的指针，用p代表该结点。当然也可一使用定义LinkList p，这种定义形式完全等价于LNode p.注意区分指针变量和结点变量两个不同的概念，若定义LinkList p或LNode p,则p为指向某结点的指针变量，表示该结点的地址；而*p为对应的结点变量，表示该结点的名称。 一般情况下，为了处理方便，在单链表的第一个结点之前附设一个结点，称为头结点。 (1) 首元结点是指链表中存储第一个数据元素a1的结点。 (2) 头结点是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可以存储与数据元素类型相同的其他附加信息。 (3) 头指针是指向链表中第一个结点的指针。若链表设有头结点，则头指针所值结点为线性表的头结点；若链表不设头结点，则头指针所指结点为该线性表的首元结点。 链表增加头结点的作用：（1）便于首元结点的处理；（2） 便于空表和非空表的统一处理。假设是指向单链表中第i个数据元素的指针，则 p-&gt;next是指向第i+1个数据元素的指针。若p-&gt;data=ai, 则p-&gt;next-&gt;data=ai+1 3.2 单链表基本操作的实现1.初始化单链表的初始化操作就是构造一个空表。 算法3.1 单链表的初始化[算法步骤] 生成新结点作为头结点，用头指针L指向头结点。 头结点的指针域置空 [算法描述]123456Status InitList(LinkLis &amp;L)&#123;//构造一个空的单链表L L=new LNode; //生成新结点作为头结点，用头指针L指向头结点 L-&gt;next=NULL; //头指针的指针域置空 return OK;&#125; 2.取值和顺序表不同，链表取值只能从链表的首元结点出发，顺着链域 next 逐个结点向下访问。 算法 3.2 单链表的取值[算法步骤] 用指针p指向首元结点，用j做计数器初值赋为1. 从首元结点开始依次顺着链域 next 向下访问，只要指向当前结点的指针 p不为空(NULL),并且没有到达序号为i的结点，则循环执行以下操作: p指向下一个结点； 计数器j相应加1； 退出循环时，如果指针p为空，或者计数器j大于i，说明指定的序号i值不合法，取值失败返回ERROR;否则取值成功，此时j=i时，p所指的结点就是要找的第i个结点，用参数e保存当前结点的数据域，返回OK. [算法描述]123456789101112Status FetElem(LinkList L,int i, ElemType &amp;e)&#123; p = L-&gt;next;j=1; //初始化，p指向首元结点，计数器j初值赋为1 while(p&amp;&amp;j&lt;i) //顺链域向后扫描，直到为空或p指向第i个元素 &#123; p=p-&gt;next; //p指向下一个结点 ++j; //计数器相应加1 &#125; if(!p||j&gt;i) return ERROR; e=p-&gt;data; //取第i个结点的数据域 return OK;&#125; 时间复杂度为 O(n) 3.查找算法3.3 单链表的按值查找[算法步骤] 用指针p指向首元结点 从首元结点开始依次顺着链域 next 向下查找 返回p [算法描述]1234567LNode *LocateElem(LinkList L,ElemType e)&#123;//在带头结点的单链表L中查找值为e的元素 p=L-&gt;next; 初始化，指向首元结点 while(p &amp;&amp; p-&gt;data!=e) //向后扫描 p=p-&gt;next; return p; //查找成功返回值为e的结点地址p，查找失败p为NULL&#125; 时间复杂度为 O(n) 4.插入算法3.4 单链表的插入 [算法步骤] 查找结点 ai-1 并由指针p指向该结点 生成一个新结点*s 将新结点*s的数据域置为e 将新结点*s的指针域指向结点 ai 将结点p的指针域指向新结点s [算法描述] 123456789101112Status ListInsert(LinkList &amp;L,int i, ElemType e)&#123;//在带头结点的单链表L中第i个位置插入值为e的新结点 p=L;j=0; while(p&amp;&amp; (j&lt;i-1)) &#123;p=p-&gt;next;++j;&#125; //查找第i-1个结点，p指向该结点 if(!p||j&gt;i-1) return ERROR; //i&gt;n+1 或 i&lt;1 s=new LNode; //生成新结点 *s s-&gt;data=e; //将新结点数据域置为e s-&gt;next=p-&gt;next; //将新结点*s的指针域指向结点 a&lt;sub&gt;i&lt;/sub&gt; p-&gt;next=s; //将结点*p的指针域指向新结点*s return OK;&#125; 时间复杂度为 O(n) 5. 删除同插入元素一样，首先应该找到该位置的前驱结点 p , p-&gt;next=p-&gt;next-&gt;next; 算法 3.5 单链表的删除[算法步骤] 查找结点 ai-1并由指针p指向该结点 临时保存待删除结点ai的地址在q中，以备释放 将结点*p的指针域指向ai的直接后继结点 释放结点ai的空间 [算法描述]1234567891011Status ListDelete(LinkList &amp;L,int i)&#123;//在带头结点的单链表L中，删除第i个元素 p=L;j=0; while((p-&gt;next) &amp;&amp; (j&lt;i-1)) //查找第i-1个结点，p指向该结点 &#123;p=p-&gt;next;++j;&#125; if(!(p-&gt;next)||(j&gt;i-1)) return ERROR; //当i&gt;n 或i&lt;1时，删除位置不合理 q=p-&gt;next; //临时保存被删除结点的地址以备删除 p-&gt;next=q-&gt;next; //改变删除结点前驱结点的指针域 delete q; //释放删除结点的空间 return OK;&#125; 时间复杂度为 O(n) 6.创建单链表根据结点插入位置的不同，链表的创建方法分为前插法和后插法 算法3.6 前插法创建单链表[算法步骤] 创建一个只有头结点的空链表 根据元素个数n，循环n次一下操作 生成一个新结点 *p 输入元素值赋给新结点*p的数据域 将新结点*p插入到头结点之后 [算法描述]1234567891011void CreateList_H(LinkList &amp;L,int n)&#123; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 for(i=0;i&lt;n;++i) &#123; p=new LNode; //生成新结点 *p cin&gt;&gt;p-&gt;data; //输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //将新结点*p插入到头结点之后 &#125;&#125; 时间复杂度为 O(n) 算法3.7 后插法创建单链表[算法步骤] 创建一个只有头结点的空链表 尾指针r初始化，指向头结点 根据元素个数n，循环n次一下操作 生成一个新结点 *p 输入元素值赋给新结点*p的数据域 将新结点p插入到尾结点r之后 尾指针r指向新的尾结点*p [算法描述]12345678910111213void CreateList_R(LinkList &amp;L,int n)&#123; L=new LNode; L-&gt;next-NULL; r=L; //尾指针r指向头结点 for(i=0;i&lt;n;++i) &#123; p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL;r-&gt;next=p; //将新结点*p插入到尾结点*r之后 r=p; //r指向新的尾结点*p &#125;&#125; 时间复杂度为 O(n) 3.3 双向链表以上讨论的链式存储结构的结点中只有一个指示直接后继的指针域，由此，从某个结点出发只能顺指针向后寻查其他结点。若要寻查结点的直接前驱，则必须从表头指针出发。双向链表可克服这种单向性的缺点。顾名思义，在双向链表的结点中有两个指针域，一个指向直接后继，另一个指向直接前驱。在双向链表中，若d为指向表中某一结点的指针，则有 d-&gt;next-&gt;prior=d-&gt;prior-&gt;next=d 算法3.8 双向链表的插入[算法描述]123456789101112Status ListInsert_DiL(DuLinkList &amp;L,int i,ElemType e)&#123;//在带头结点的双向链表L中第i个位置之前插入元素 if(!(p=GetElem_DuL(L,i))) //在L中确定第i个元素的位置指针p return ERROR; //p为NULL时，第i个元素不存在 s = new DuLNode; //生成新结点*s s-&gt;data=e; //新结点数据域为e s-&gt;prior=p-&gt;prior; //将新结点*s插入L中 p-&gt;prior-&gt;next=s; s-&gt;next=p; p-&gt;prior=s; return OK;&#125; 算法3.9 双向链表的删除[算法描述]123456789Status ListDelete_DuL(DuLinkList &amp;L;int i)&#123;//删除在带头结点的双向链表L中第i个元素 if(!(p=GetElem_DuL(L,i))) //在L中确定第i个元素的位置指针p return ERROR; //p为NULL时，第i个元素不存在 p-&gt;prior-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=p-&gt;prior; delete p; return OK;&#125; 4.顺序表和链表的比较若线性表的主要操作是和元素位置紧密相关的这类取值操作，很少做插入或删除时，宜采用顺序表作为存储结构。对于频繁进行插入或删除操作的线性表，宜采用链表作为存储结构。]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 开机输入密码后一直退回到输入密码界面]]></title>
    <url>%2Fyear%2F05%2F21%2F3185%2F</url>
    <content type="text"><![CDATA[刚才准备写篇博客，开机却发现 输入密码后黑屏一下就退回到输入密码界面。这里先说解决方法:123ctrl+alt+F1 切换到 ttysudo rm -r .Xauthoritysudo reboot 开机后就解决问题了，不过原来配置的桌面没了，需要重新配置一下，其他的东西都还在，不用紧张。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫自动下载微信公众号图片]]></title>
    <url>%2Fyear%2F05%2F15%2F14174%2F</url>
    <content type="text"><![CDATA[爬虫真的是特别好玩的东西，Python是写爬虫最方便的语言。 不知大家有没有这种经历，躺床上刷微信公众号发现一篇特别好的文章，很打动人心，文章里面的配图也特别精美就想下载下来，当然手机可以一张一张保存，但图片比较多的时候就很不方便了，而且写博客、公众号的时候大部分是在电脑上。但是用电脑右击保存图片却是.webp格式，而这种格式不能直接插入文章中，虽然可以把.webp保存为其它格式，但这样效率太低，尤其是你想大量获取图片时。所以，我就想写一个爬虫来自动下载图片，挑选出精致中意的图片以备以后使用。今晚简单写了一个初级爬虫，虽然已经可以满足我的需求，但不够精致，哈哈哈，也就是只能让那个我一个人在我电脑上用。所以，后面两天再修改一下，让每个人都可以简单使用。下面放代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#--coding:utf-8 --import osimport urllib2import reimport requestsfrom datetime import datetime# 保存路径def save_img(): url = str(raw_input("please input url:")) #try: if(os.name == 'Windows'): pass elif os.name == 'posix': if(os.path.exists(r"/home/ubuntu/img")): path = '/home/ubuntu/img/' else: os.makedirs(r"/home/ubuntu/img") path = '/home/ubuntu/img/' html = requests.get(url).text picurl = re.findall('(?&lt;=data-src=").+?(?=")', html, re.S) i = 0 for each in picurl: print each if 'jpeg' in each: piclast = '.jpeg' elif 'jpg' in each: piclast = '.jpg' elif 'gif' in each: piclast = '.gif' else: piclast = '.jpeg' pic = requests.get(each,timeout=10) string = path + datetime.now().strftime('%Y-%M-%d %H:%M:%S') +str(i)+ piclast fp = open(string,'wb') fp.write(pic.content) fp.close() i += 1; if __name__ == '__main__': while(True): save_img() 代码还是有点小问题的，当然这只是初级版本，这两天会修改完善的。 第一次修改后代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#--coding:utf-8 --# python2.7import osimport urllib2import reimport requestsfrom datetime import datetime# 保存路径def save_img(): url = str(raw_input("please input url:")) #try: # 将图片保存在当前文件夹的img文件夹中 filepath = os.getcwd() #parent_path = os.path.dirname(filepath) if(os.name == 'Windows'): path = filepath + '\\img\\' elif os.name == 'posix': path = filepath + '/img/' print "图片保存在" + path + "中" filepath = path if(os.path.isdir(filepath)): pass else: os.makedirs(filepath) path = filepath # 解析网页获取图片url html = requests.get(url).text picurl = re.findall('(?&lt;=data-src=").+?(?=")', html, re.S) # 保存图片 i = 1 print "当前网页一共有 " + str(len(picurl)) + " 张图片" for each in picurl: print "正在下载第 " + str(i) + " 张图片" # 判断图片格式 if 'jpeg' in each: piclast = '.jpeg' elif 'jpg' in each: piclast = '.jpg' elif 'gif' in each: piclast = '.gif' else: piclast = '.jpeg' # 保存图片 pic = requests.get(each,timeout=10) string = path + datetime.now().strftime('%Y-%M-%d %H:%M:%S') +str(i)+ piclast # 图片名为当前时间 with open(string,'wb') as fp: fp.write(pic.content) fp.close() i += 1; if __name__ == '__main__': #while(True): save_img() print "下载完毕"]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python 分析微信好友数据]]></title>
    <url>%2Fyear%2F05%2F13%2F55049%2F</url>
    <content type="text"><![CDATA[最近微信迎来了一次重要的更新，允许用户对”发现”页面进行定制。不知道从什么时候开始，微信朋友圈变得越来越复杂，当越来越多的人选择”仅展示最近三天的朋友圈”，大概连微信官方都是一脸的无可奈何。逐步泛化的好友关系，让微信从熟人社交逐渐过渡到陌生人社交，而朋友圈里亦真亦幻的状态更新，仿佛在努力证明每一个个体的”有趣”。 有人选择在朋友圈里记录生活的点滴，有人选择在朋友圈里展示观点的异同，可归根到底，人们无时无刻不在窥探着别人的生活，唯独怕别人过多地了解自己的生活。人性中交织着的光明与黑暗，像一只浑身长满刺的刺猬，离得太远会感觉到寒冷，而靠得太近则害怕被刺扎到。朋友圈就像过年走亲戚，即便你心中有一万个不痛快，总是不愿意撕破脸，或屏蔽对方，或不给对方看，或仅展示最后三天，于是通讯录里的联系人越来越多，朋友圈越来越大，可再不会有能真正触动你内心的”小红点”出现，人类让一个产品变得越来越复杂，然后说它无法满足人类的需求，这大概是一开始就始料不及的吧！ 有人说，人性远比计算机编程更复杂，因为即使是人类迄今为止最伟大的发明——计算机，在面对人类的自然语言时同样会张惶失措 。人类有多少语言存在着模棱两可的含义，我认为语言是人类最大的误解，人类时常喜欢揣测语言背后隐藏的含义，好像在沟通时表达清晰的含义会让人类没有面子，更不用说网络上流行的猜测女朋友真实意图的案例。金庸先生的武侠小说《射雕英雄传》里，在信息闭塞的南宋时期，江湖上裘千丈的一句鬼话，就搅得整个武林天翻地覆。 其实，一两句话说清楚不好吗？黄药师、全真七子、江南六怪间的种种纠葛，哪一场不是误会？一众儿武功震古烁今的武林高手，怎么没有丝毫的去伪存真的能力，语言造成了多少误会。 可即便人类的语言复杂得像一本无字天书，可人类还是从这些语言中寻觅到蛛丝马迹。古人有文王”拘而演周易”、东方朔测字卜卦，这种带有”迷信”色彩的原始崇拜，就如同今天人们迷信星座运势一般，都是人类在上千年的演变中不断对经验进行总结和训练的结果。如此说起来，我们的人工智能未尝不是一种更加科学化的”迷信”，因为数据和算法让我们在不断地相信，这一切都是真实地。 生活在数字时代的我们，无疑是悲哀的，一面努力地在别人面前隐藏真实地自己，一面不无遗憾地感慨自己无处遁逃，每一根数字神经都紧紧地联系着你和我，你不能渴望任何一部数字设备具备真正的智能，可你生命里的每个瞬间，都在悄然间被数据地折射出来。 今天这篇文章会基于 Python 对微信好友进行数据分析，这里选择的维度主要有：性别、头像、签名、位置，主要采用图表和词云两种形式来呈现结果，其中，对文本类信息会采用词频分析和情感分析两种方法。常言道：工欲善其事，必先利其器也。 在正式开始这篇文章前，简单介绍下本文中使用到的第三方模块： itchat：微信网页版接口封装Python版本，在本文中用以获取微信好友信息。 jieba：结巴分词的 Python 版本，在本文中用以对文本信息进行分词处理。 matplotlib： Python 中图表绘制模块，在本文中用以绘制柱形图和饼图 snownlp：一个 Python 中的中文分词模块，在本文中用以对文本信息进行情感判断。 PIL： Python 中的图像处理模块，在本文中用以对图片进行处理。 numpy： Python中 的数值计算模块，在本文中配合 wordcloud 模块使用。 wordcloud： Python 中的词云模块，在本文中用以绘制词云图片。 TencentYoutuyun：腾讯优图提供的 Python 版本 SDK ，在本文中用以识别人脸及提取图片标签信息。 以上模块均可通过 pip 安装，关于各个模块使用的详细说明，请自行查阅各自文档。 分析微信好友数据的前提是获得好友信息，通过使用 itchat 这个模块，这一切会变得非常简单，我们通过下面两行代码就可以实现：123itchat.auto_login(hotReload = True)friends = itchat.get_friends(update = True) 同平时登录网页版微信一样，我们使用手机扫描二维码就可以登录，这里返回的friends对象是一个集合，第一个元素是当前用户。所以，在下面的数据分析流程中，我们始终取friends[1:]作为原始输入数据，集合中的每一个元素都是一个字典结构，以我本人为例，可以注意到这里有Sex、City、Province、HeadImgUrl、Signature这四个字段，我们下面的分析就从这四个字段入手： 好友性别分析好友性别，我们首先要获得所有好友的性别信息，这里我们将每一个好友信息的Sex字段提取出来，然后分别统计出Male、Female和Unkonw的数目，我们将这三个数值组装到一个列表中，即可使用matplotlib模块绘制出饼图来，其代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637def analyseSex(firends): sexs = list(map(lambda x:x['Sex'],friends[1:])) counts = list(map(lambda x:x[1],Counter(sexs).items())) labels = ['Unknow','Male','Female'] colors = ['red','yellowgreen','lightskyblue'] plt.figure(figsize=(8,5), dpi=80) plt.axes(aspect=1) plt.pie(counts, labels=labels, colors=colors, labeldistance = 1.1, autopct = '%3.1f%%', shadow = False, startangle = 90, pctdistance = 0.6 ) plt.legend(loc='upper right',) plt.title(u'%s的微信好友性别组成' % friends[0]['NickName']) plt.show() 这里简单解释下这段代码，微信中性别字段的取值有Unkonw、Male和Female三种，其对应的数值分别为0、1、2。通过Collection模块中的Counter()对这三种不同的取值进行统计，其items()方法返回的是一个元组的集合，该元组的第一维元素表示键，即0、1、2，该元组的第二维元素表示数目，且该元组的集合是排序过的，即其键按照0、1、2 的顺序排列，所以通过map()方法就可以得到这三种不同取值的数目，我们将其传递给matplotlib绘制即可，这三种不同取值各自所占的百分比由matplotlib计算得出。下图是matplotlib绘制的好友性别分布图： 看到这个结果，我一点都不觉得意外，男女比例严重失衡，这虽然可以解释我单身的原因，可我不觉得通过调整男女比例就能解决问题，好多人认为自己单身是因为社交圈子狭小，那么是不是扩展了社交圈子就能摆脱单身呢？我觉得或许这样会增加脱单的概率，可幸运之神应该不会眷顾我，因为我的好运气早在我24岁以前就消耗完啦。 在知乎上有一个热门的话题：现在的男性是否普遍不再对女性展开追求了？，其实哪里会有人喜欢孤独呢？无非是怕一次又一次的失望罢了。有的人并不是我的花儿，我只是恰好途径了她的绽放。曾经有人说我是一个多情的人，可她永远不会知道，我做出的每一个决定都炽热而悲壮。所谓”慧极必伤，情深不寿；谦谦君子，温润如玉”，世人苦五毒者大抵如此。 好友头像分析好友头像，从两个方面来分析，第一，在这些好友头像中，使用人脸头像的好友比重有多大；第二，从这些好友头像中，可以提取出哪些有价值的关键字。这里需要根据HeadImgUrl字段下载头像到本地，然后通过腾讯优图提供的人脸识别相关的API接口，检测头像图片中是否存在人脸以及提取图片中的标签。其中，前者是分类汇总，我们使用饼图来呈现结果；后者是对文本进行分析，我们使用词云来呈现结果。 关键代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126def analyseHeadImage(frineds): basePath = os.path.abspath('.') baseFolder = basePath + 'HeadImages' if(os.path.exists(baseFolder) == False): os.makedirs(baseFolder) faceApi = FaceAPI() use_face = 0 not_use_face = 0 image_tags = '' for index in range(1,len(friends)): friend = friends[index] imgFile = baseFolder + 'Image%s.jpg' % str(index) imgData = itchat.get_head_img(userName = friend['UserName']) if(os.path.exists(imgFile) == False): with open(imgFile,'wb') as file: file.write(imgData) time.sleep(1) result = faceApi.detectFace(imgFile) if result == True: use_face += 1 else: not_use_face += 1 result = faceApi.extractTags(imgFile) image_tags += ','.join(list(map(lambda x:x['tag_name'],result))) labels = [u'使用人脸头像',u'不使用人脸头像'] counts = [use_face,not_use_face] colors = ['red','yellowgreen','lightskyblue'] plt.figure(figsize=(8,5), dpi=80) plt.axes(aspect=1) plt.pie(counts, labels=labels, colors=colors, labeldistance = 1.1, autopct = '%3.1f%%', shadow = False, startangle = 90, pctdistance = 0.6 ) plt.legend(loc='upper right',) plt.title(u'%s的微信好友使用人脸头像情况' % friends[0]['NickName']) plt.show() image_tags = image_tags.encode('iso8859-1').decode('utf-8') back_coloring = np.array(Image.open('face.jpg')) wordcloud = WordCloud( font_path='simfang.ttf', background_color="white", max_words=1200, mask=back_coloring, max_font_size=75, random_state=45, width=800, height=480, margin=15 ) wordcloud.generate(image_tags) plt.imshow(wordcloud) plt.axis("off") plt.show() 这里我们会在当前目录新建一个HeadImages目录，用以存储所有好友的头像，然后我们这里会用到一个名为FaceApi类，这个类由腾讯优图的SDK封装而来，这里分别调用了人脸检测和图像标签识别两个API接口，前者会统计”使用人脸头像”和”不使用人脸头像”的好友各自的数目，后者会累加每个头像中提取出来的标签。其分析结果如下图所示： 可以注意到，在所有微信好友中，约有接近1/4的微信好友使用了人脸头像， 而有接近3/4的微信好友没有人脸头像，这说明在所有微信好友中对”颜值 “有自信的人，仅仅占到好友总数的25%，或者说75%的微信好友行事风格偏低调为主，不喜欢用人脸头像做微信头像。这是否说明”好看的皮囊”并非是千篇一律，长得好看的人实在是少数中的少数。 所以，当女生的妆容越来越向着”韩式半永久粗平眉”、”瓜子脸”和”大红唇”靠拢的时候，当男生的服饰越来越向着”大背头”、”高领毛衣”和”长款大衣”靠拢的时候，我们能不能真正得个性一次。生命中有太多被世俗绑架着的事情，既要和别人不一样 ，同时还要和大多数人一样，这是人生在世的无可奈何。考虑到腾讯优图并不能真正得识别”人脸”，我们这里对好友头像中的标签再次进行提取，来帮助我们了解微信好友的头像中有哪些 关键词，其分析结果如图所示： 通过词云，我们可以发现：在微信好友中的签名词云中，出现频率相对较高的关键字有：女孩、树木、房屋、文本、截图、卡通、合影、天空、大海。这说明在我的微信好友中，好友选择的微信头像主要有日常、旅游、风景、截图四个来源，好友选择的微信头像中风格以卡通为主，好友选择的微信头像中常见的要素有天空、大海、房屋、树木。 通过观察所有好友头像，我发现在我的微信好友中，使用个人照片作为微信头像的有15人，使用网络图片作为微信头像的有53人，使用动漫图片作为微信头像的有25人，使用合照图片作为微信头像的有3人，使用孩童照片作为微信头像的有5人，使用风景图片作为微信头像的有13人，使用女孩照片作为微信头像的有18人，基本符合图像标签提取的分析结果。 好友签名分析好友签名，签名是好友信息中最为丰富的文本信息，按照人类惯用的”贴标签”的方法论，签名可以分析出某一个人在某一段时间里状态，就像人开心了会笑、哀伤了会哭，哭和笑两种标签，分别表明了人开心和哀伤的状态。 这里我们对签名做两种处理，第一种是使用用结巴分词进行分词后生成词云，目的是了解好友签名中的关键字有哪些，哪一个关键字出现的频率相对较高；第二种是使用SnowNLP分析好友签名中的感情倾向，即好友签名整体上是表现为正面的、负面的还是中立的，各自的比重是多少。这里提取Signature字段即可，其核心代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596def analyseSignature(friends): signatures = '' emotions = [] pattern = re.compile("1fd.+") for friend in friends: signature = friend['Signature'] if(signature != None): signature = signature.strip().replace('span', '').replace('class', '').replace('emoji', '') signature = re.sub(r'1f(d.+)','',signature) if(len(signature)&gt;0): nlp = SnowNLP(signature) emotions.append(nlp.sentiments) signatures += ' '.join(jieba.analyse.extract_tags(signature,5)) with open('signatures.txt','wt',encoding='utf-8') as file: file.write(signatures) back_coloring = np.array(Image.open('flower.jpg')) wordcloud = WordCloud( font_path='simfang.ttf', background_color="white", max_words=1200, mask=back_coloring, max_font_size=75, random_state=45, width=960, height=720, margin=15 ) wordcloud.generate(signatures) plt.imshow(wordcloud) plt.axis("off") plt.show() wordcloud.to_file('signatures.jpg') count_good = len(list(filter(lambda x:x&gt;0.66,emotions))) count_normal = len(list(filter(lambda x:x&gt;=0.33 and x&lt;=0.66,emotions))) count_bad = len(list(filter(lambda x:x&lt;0.33,emotions))) labels = [u'负面消极',u'中性',u'正面积极'] values = (count_bad,count_normal,count_good) plt.rcParams['font.sans-serif'] = ['simHei'] plt.rcParams['axes.unicode_minus'] = False plt.xlabel(u'情感判断') plt.ylabel(u'频数') plt.xticks(range(3),labels) plt.legend(loc='upper right',) plt.bar(range(3), values, color = 'rgb') plt.title(u'%s的微信好友签名信息情感分析' % friends[0]['NickName']) plt.show() 通过词云，我们可以发现： 在微信好友的签名信息中，出现频率相对较高的关键词有：努力、长大、美好、快乐、生活、幸福、人生、远方、时光、散步。果然我的微信好友都是温暖、正直的好青年啊！ :smile:其实，签名这个设定，从某种程度上是在反映人的一种心态，人在年轻时不免”为赋新词强说愁”，等到你真正到了这个精神境界，突然发现年轻时图样图森破，或许这就是我们不愿意让别人了解过去的原因，因为伴随着人的成长，某一种瞬间的状态简直不忍直视，QQ空间陪伴了我们这代人的整个青春，令人印象深刻的”那年今日”功能，有时让我们感到回忆的温暖，有时让我们感到岁月的萧杀，”当时只道是寻常”的物是人非，”回首向来萧瑟处”的淡定从容，”今夕复何夕”的失落惆怅……都在这一行行签名里留下深深浅浅的印记。在知乎上有关于签名的话题讨论，对此感兴趣的朋友不妨找时间看看。:smile: 通过柱状图，我们可以发现： 在微信好友的签名信息中，正面积极的情感判断约占到55.56%，中立的情感判断约占到32.10%，负面消极的情感判断约占到12.35%。 这个结果和我们通过词云展示的结果基本吻合，这说明在微信好友的签名信息中，约有87.66%的签名信息，传达出来都是一种积极向上的态度。朋友圈中基本上有两类用户，第一类用户使用朋友圈记录自己的生活，第二类用户使用朋友圈输出自己的观点。显然，对于第二类用户，它并不介意别人了解它的过去，它更在乎它从始至终输出的观点是否一致。 所以，不管朋友圈里别人在或晒美食、或晒旅游、或秀恩爱、或晒宝宝、或煲鸡汤等等，在我看来这都是一种生活方式，精神层次和物质层次比你高的人群，觉得你朋友圈里的内容”无趣”，这是符合人类一贯的认知方式的，在大多数情况下，反而是那些和你层次差不多的人群，对不熟悉的人或者事物妄加判断，如果你不喜欢我朋友圈里的内容，请直接屏蔽我就好，因为这样我们还可以做朋友；如果你因为喜欢A而在我这里和我说B不好，这就真的是三观不合啦。 我相信没有完全兴趣匹配的两个人，即使是男女朋友或者情侣之间，总之人与人相处嘛，真诚和互相尊重是基本要求。 好友位置分析好友位置，主要通过提取Province和City这两个字段。Python中的地图可视化主要通过Basemap模块，这个模块需要从国外网站下载地图信息，使用起来非常的不便。百度的ECharts在前端使用的比较多，虽然社区里提供了pyecharts项目，可我注意到因为政策的改变，目前Echarts不再支持导出地图的功能，所以地图的定制方面目前依然是一个问题，主流的技术方案是配置全国各省市的JSON数据，这里博主使用的是BDP个人版，这是一个零编程的方案，我们通过Python导出一个CSV文件，然后将其上传到BDP中，通过简单拖拽就可以制作可视化地图，简直不能再简单，这里我们仅仅展示生成CSV部分的代码：123456789101112131415161718192021def analyseLocation(friends): headers = ['NickName','Province','City'] with open('location.csv','w',encoding='utf-8',newline='',) as csvFile: writer = csv.DictWriter(csvFile, headers) writer.writeheader() for friend in friends[1:]: row = &#123;&#125; row['NickName'] = friend['NickName'] row['Province'] = friend['Province'] row['City'] = friend['City'] writer.writerow(row) 下图是BDP中生成的微信好友地理分布图，可以发现：我的微信好友主要集中在宁夏和陕西两个省份。数字时代的神经牵动着每一个社交关系链的人，我们想要竭力去保护的那点隐私，在这些数据中一点点地折射出来。人类或许可以不断地伪装自己，可这些从数据背后抽离出来的规律和联系不会欺骗人类。 数学曾经被人称为最没有用的学科，因为生活中并不需要神圣而纯粹的计算，在不同的学科知识里，经验公式永远比理论公式更为常用。可是此时此刻，你看，这世界就像一只滴滴答答转动着的时钟，每一分每一秒都是严丝合缝的。 写这篇文章的时候，我一直不知道该如何下笔，因为微信是一个神奇的存在，它是一个国民级别的全民APP，所以，微信的产品设计一直都是一个有趣的现象，从最初底部Tab的数目、每个Tab的名称、”发现”页面的定制、小程序入口、朋友圈入口到朋友圈评论等等一系列的设计细节，都是值得我们透过人性和心理去研究的。即使是被人们封神的”张小龙”，在面对结构最为复杂的中国用户群体的时候，他的潇洒中依旧不免充满无奈，从对朋友圈的置之不理就可以看出，这是一个怎么做都不会让人满意的功能，任何一个生态在面对巨大的用户群体的时候，功能的增减就会变成一个难题。 所谓”林子大了什么鸟都有”，知乎面对的是同样的问题，营销类公众号在不断消费社会话题的同时，引导着一批又一批粉丝的价值取向，人类总渴望着别人了解自己，可人类真的了解自己吗？这篇博客是我对数据分析的又一次尝试，主要从性别、头像、签名、位置四个维度，对微信好友进行了一次简单的数据分析，主要采用图表和词云两种形式来呈现结果。 总而言之一句话，”数据可视化是手段而并非目的”，重要的不是我们在这里做了这些图出来，而是从这些图里反映出来的现象，我们能够得到什么本质上的启示，我一位朋友问我怎么什么都想抓取，为什么啊，因为我不懂人类啊！ 作者：飞鸿踏雪 PayneQin 原文：http://blog.csdn.net/qinyuanpei/article/details/79360703]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决Linux java和javac版本不一样问题]]></title>
    <url>%2Fyear%2F05%2F11%2F27171%2F</url>
    <content type="text"><![CDATA[之前写过 Linux安装java 教程，可是今天发现java -version 和 javac -version 版本号不一样。虽然在安装java时设置了系统变量，可系统依旧默认使用自带的 OpenJDK，下面给出解决方法。 注：使用which java 和which javac 可以查看各自路径。 简单来说，就是把这2个文件ln -s 到我们新的jdk下的java和javac上，命令如下: rm -rf /usr/bin/java rm -rf /usr/bin/javac ln -s $JAVA_HOME/bin/java /usr/bin/java ln -s $JAVA_HOME/bin/javac /usr/bin/javac 然后再查看java -version javac -version，问题解决了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS总结]]></title>
    <url>%2Fyear%2F04%2F19%2F31424%2F</url>
    <content type="text"><![CDATA[CSS属性繁多，有些属性用的时候总想不起来，所以就写个记录贴，这样便于记忆和复习。 阴影（shadow)shadow有text-shadow(文本阴影)和box-shadow(框阴影)两种.语法12text-shadow: h-shadow v-shadow blur color;box-shadow: h-shadow v-shadow blur spread color inset; 通过设置shadow属性可以实现很多效果，比如我将导航栏设置为鼠标移动到上面时多出来6px不同颜色的高度。代码如下：12345678910a:link &#123; display: inline-block; height: 90%; width: 18%; position: relative; background-color: #DAD9CC;&#125;a: hover &#123; box-shadow: 0px -8px 0px # 858471;&#125; background: transparent经常会看到这样的代码123* &#123; background: transparent;&#125; 意思就是背景透明。实际上background默认的颜色就是透明的属性，所以写和不写都是一样的。但如果一个元素覆盖在另一个元素之上，而你想显示下面的元素，这时你就需要把上面的这个元素设置为background: transparent;. z-index首先声明： z-index 仅能在定位元素上奏效，即只能在position属性值为relative、absolute或fixed的元素上有效。基本原理是：z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。元素可拥有负的 z-index 属性值。 width: auto 和 width: 100% 区别12345678910width: auto* 子元素（包括content+padding+border+margin）撑满整个父元素的content区域。* 子元素有margin、border、padding时，会减去子元素content区域相对应的width值* 父元素的content = 子元素（content + padding + border + margin )width: 100%* 强制将子元素的content区域 撑满 父元素的content区域* 子元素有margin、border、padding时，不改变子元素content区域的width，而是溢出父盒子，保持原有值* 父元素的content = 子元素的content 来看个例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0;padding: 0; &#125; body &#123; background: #dcdcdc; &#125; .box &#123; width: 400px; border: 3px solid red; padding: 0 50px; &#125; .box1 &#123; width: auto; height: 100px; background: pink; padding: 0 50px; margin: 0 50px; border-width: 0 50px; border-style: solid; border-color: green; &#125; .box2 &#123; width: 100%; height: 100px; background: gold; padding: 0 50px; margin: 0 50px; border-width: 0 50px; border-style: solid; border-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text-transformtext-transform 属性控制文本的大小写。 值 描述 none 默认。定义带有小写字母和大写字母的标准的文本. capitalize 文本中的每个单词以大写字母开头。 uppercase 定义仅有大写字母。 lowercase 定义无大写字母，仅有小写字母。 inherit 规定应该从父元素继承 text-transform 属性的值。 background-size语法:1background-size: length|percentage|cover|contain; 值 描述 length 设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。 percentage 以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。 cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 opacityopacity 属性设置元素的不透明级别。12语法opacity: value|inherit; 值 描述 value 规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）。 inherit 应该从父元素继承 opacity 属性的值。 &lt;video&gt;属性 属性 值 描述 autoplay autoplay 如果出现该属性，则视频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 height pixels 设置视频播放器的高度。 loop loop 如果出现该属性，则当媒介文件完成播放后再次开始播放。 muted muted 规定视频的音频输出应该被静音。 poster URL 规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像. preload preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。 src url 要播放的视频的 URL。 width pixels 设置视频播放器的宽度。 cursorcursor 属性规定要显示的光标的类型(形状)。 值 描述 url 需使用的自定义光标的 URL。注释:请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标 default 默认光标（通常是一个箭头） auto 默认。浏览器设置的光标。 crosshair 光标呈现为十字线。 pointer 光标呈现为指示链接的指针（一只手） move 此光标指示某对象可被移动。 e-resize 此光标指示矩形框的边缘可被向右（东）移动。 ne-resize 此光标指示矩形框的边缘可被向上及向右移动（北/东）。 nw-resize 此光标指示矩形框的边缘可被向上及向左移动（北/西）。 n-resize 此光标指示矩形框的边缘可被向上（北）移动。 se-resize 此光标指示矩形框的边缘可被向下及向右移动（南/东）。 sw-resize 此光标指示矩形框的边缘可被向下及向左移动（南/西）。 s-resize 此光标指示矩形框的边缘可被向下移动（南）。 w-resize 此光标指示矩形框的边缘可被向左移动（西）。 text 此光标指示文本。 wait 此光标指示程序正忙（通常是一只表或沙漏）。 help 此光标指示可用的帮助（通常是一个问号或一个气球）。 transformtransform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。 值 描述 none 定义不进行转换。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y) 定义 2D 转换。 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。 translateY(y) 定义转换，只是用 Y 轴的值。 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n) 为 3D 转换元素定义透视视图。 animationanimation 属性是一个简写属性，用于设置六个动画属性： animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction 注释：请始终规定 animation-duration 属性，否则时长为 0，就不会播放动画了。12语法animation: name duration timing-function delay iteration-count direction; 值 描述 animation-name 规定需要绑定到选择器的 keyframe 名称。(keyframename/none) animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。(n/infinite) animation-direction 规定是否应该轮流反向播放动画。(normal/alternate) animation-timing-function 值 描述 linear 动画从头到尾的速度是相同的。 ease 默认。动画以低速开始，然后加快，在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 cubic-bezier即为贝塞尔曲线中的绘制方法。图上有四点，P0-3，其中P0、P3是默认的点，对应了[0,0], [1,1]。而剩下的P1、P2两点则是我们通过cubic-bezier()自定义的。cubic-bezier(x1, y1, x2, y2) 为自定义，x1,x2,y1,y2的值范围在[0, 1]。 预留的几个特效：123456789ease: cubic-bezier(0.25, 0.1, 0.25, 1.0)linear: cubic-bezier(0.0, 0.0, 1.0, 1.0)ease-in: cubic-bezier(0.42, 0, 1.0, 1.0)ease-out: cubic-bezier(0, 0, 0.58, 1.0)ease-in-out: cubic-bezier(0.42, 0, 0.58, 1.0) CSS选择器在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。 选择器 例子 例子描述 .class .intro 选择 class=”intro” 的所有元素。 #id #firstname 选择 id=”firstname” 的所有元素。 * * 选择所有元素 element p 选择所有 &lt;p&gt; 元素。 element,element div,p 选择所有&lt;div&gt; 元素和所有 &lt;p&gt; 元素。 element element div p 选择 &lt;div&gt; 元素内部的所有 p&lt;&gt; 元素。 element&gt;element div&gt;p 选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。 element+element div+p 选择紧接在 &lt;div&gt; 元素之后的所有&lt;p&gt; 元素。 [attribute] [target] 选择带有 target 属性所有元素。 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素。 [attribute]~=value] [titlr~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 [attribute]=value] [lang]=en] 选择 lang 属性值以 “en” 开头的所有元素。 :link a:link 选择所有未被访问的链接。 :visited a:visited 选择所有已被访问的链接。 :active a:active 选择活动链接。 :hover a:hover 选择鼠标指针位于其上的链接。 :focus input:focus 选择获得焦点的 input 元素。 :first-letter p:first-letter 选择每个 &lt;p&gt; 元素的首字母。 :first-line p:first-line 选择每个 &lt;p&gt; 元素的首行。 :first-child p:first-child 选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。 :before p:before 在每个 &lt;p&gt; 元素的内容之前插入内容。 :after p:after 在每个 &lt;p&gt; 元素的内容之后插入内容。 :lang(language) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 &lt;p&gt; 元素。 element1~element2 p~ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。 [attribute^=value] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 &lt;a&gt; 元素。 [attribute$=value] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素。 [attribute*=value] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 &lt;a&gt; 元素。 :first-of-type p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :last-of-type p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :only-of-type p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个&lt;p&gt; 元素。 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 :last-child p:last-child 选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素。 :root :root 选择文档的根元素。 :empty p:empty 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点）。 :target #news:target 选择当前活动的 #news 元素。 :enabled input:enabled 选择每个启用的 &lt;input&gt; 元素。 :disabled input:disabled 选择每个禁用的 &lt;input&gt; 元素 :checked input:checked 选择每个被选中的 &lt;input&gt; 元素。 :not(selector) :not(p) 选择非 &lt;p&gt; 元素的每个元素。 ::selection ::selection 选择被用户选取的元素部分。 @keyframes 规则通过 @keyframes 规则，您能够创建动画。 创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。 在动画过程中，您能够多次改变这套 CSS 样式。 以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。 0% 是动画的开始时间，100% 动画的结束时间。 为了获得最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 注释：请使用动画属性来控制动画的外观，同时将动画与选择器绑定。 值 描述 animationname 必需。定义动画的名称。 keyframes-selector 必需。动画时长的百分比。合法的值： 0-100%;from（与 0% 相同;to（与 100% 相同） css-styles 必需。一个或多个合法的 CSS 样式属性。 看个例子就明白了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:red;position:relative;animation:mymove 5s infinite;-moz-animation:mymove 5s infinite; /* Firefox */-webkit-animation:mymove 5s infinite; /* Safari and Chrome */-o-animation:mymove 5s infinite; /* Opera */&#125;@keyframes mymove&#123;0% &#123;top:0px; left:0px; background:red;&#125;25% &#123;top:0px; left:100px; background:blue;&#125;50% &#123;top:100px; left:100px; background:yellow;&#125;75% &#123;top:100px; left:0px; background:green;&#125;100% &#123;top:0px; left:0px; background:red;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123;0% &#123;top:0px; left:0px; background:red;&#125;25% &#123;top:0px; left:100px; background:blue;&#125;50% &#123;top:100px; left:100px; background:yellow;&#125;75% &#123;top:100px; left:0px; background:green;&#125;100% &#123;top:0px; left:0px; background:red;&#125;&#125;@-webkit-keyframes mymove /* Safari and Chrome */&#123;0% &#123;top:0px; left:0px; background:red;&#125;25% &#123;top:0px; left:100px; background:blue;&#125;50% &#123;top:100px; left:100px; background:yellow;&#125;75% &#123;top:100px; left:0px; background:green;&#125;100% &#123;top:0px; left:0px; background:red;&#125;&#125;@-o-keyframes mymove /* Opera */&#123;0% &#123;top:0px; left:0px; background:red;&#125;25% &#123;top:0px; left:100px; background:blue;&#125;50% &#123;top:100px; left:100px; background:yellow;&#125;75% &#123;top:100px; left:0px; background:green;&#125;100% &#123;top:0px; left:0px; background:red;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 目前浏览器都不支持 @keyframes 规则。 Firefox 支持替代的 @-moz-keyframes 规则。 Opera 支持替代的 @-o-keyframes 规则。 Safari 和 Chrome 支持替代的 @-webkit-keyframes 规则。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG之Animation]]></title>
    <url>%2Fyear%2F04%2F18%2F64093%2F</url>
    <content type="text"><![CDATA[&lt;animate&gt;元素用于实现动画效果（动画截图比较麻烦，本文中的例子最好直接写demo看效果） 基本动画将元素嵌入到元素内，来实现该元素的动画效果。12345678&lt;rect x="10" y="10" width="200" height="20" stroke="black" fill="none"&gt; &lt;animate attributeName="width" attributeType="XML" from="200" to="20" begin="0s" dur="5s" fill="freeze" /&gt;&lt;/rect&gt; 以上代码会一个20020的长方形，在5秒内渐变成一个2020的正方形，并且在动画结束时停留在正方形的状态。 元素的基本属性： attributeName定义发生变化的元素属性名 attributeType 当attributeType=”XML”时，attributeName被认为是XML的属性；当attributeType=”CSS”时，attributeName被认为是css的属性；不指定attributeType时，默认为”auto”，会先将attributeName作为css的属性，如果无效，再将attributeName作为XML的属性。 from &amp; to &amp; by from和to分别定义发生变化的属性的初始值和终止值。from可缺省，表示初始值即为父元素相应的属性值。可用by替换to，表示变化偏移量。可以理解为to = from + by。 begin &amp; dur &amp; end begin定义动画开始时间；dur定义动画所需时间；end定义动画终止时间。时间单位h：小时；min：分钟；s：秒；ms：毫秒。默认时间单位为s fill 当fill=”freeze”时，动画终止时，发生变化的元素属性值停留在动画终止时的状态；当fill=”remove”时，动画终止时，发生变化的元素属性值回复到动画起始时的状态。fill属性默认值为remove。允许在同一个元素内嵌入多个1234&lt;rect x="10" y="10" width="20" height="20" style="stroke: black; fill: #cfc;"&gt; &lt;animate attributeName="width" attributeType="XML" begin="0s" dur="2s" from="20" to="120" fill="freeze"/&gt; &lt;animate attributeName="height" attributeType="XML" begin="0s" dur="2s" from="20" by="100" fill="freeze"/&gt;&lt;/rect&gt; 动画时间当begin设置为一个具体时间，比如2s，svg会在元素加载完毕后，过2秒开始执行动画。begin还可以指定一个其他的begin或者end，比如：123456&lt;circle cx="60" cy="60" r="30" style="fill: #f9f; stroke: gray;"&gt; &lt;animate id="c1" attributeName="r" attributeType="XML" begin="0s" dur="4s" from="30" to="10" fill="freeze"/&gt;&lt;/circle&gt;&lt;circle cx="120" cy="60" r="10" style="fill: #9f9; stroke: gray;"&gt; &lt;animate attributeName="r" attributeType="XML" begin="c1.end" dur="4s" from="10" to="30" fill="freeze"/&gt;&lt;/circle&gt; 第二个圆的动画执行起始时间为第一个圆动画执行完毕时间。begin属性还可以进行简单计算：begin=”c1.end+1.5s”：表示动画执行起始时间为第一个圆执行完毕后的1.5秒。 当end设置为一个具体时间，比如2s，svg会在元素加载完毕后，过2秒即停止执行动画，不管这个元素的动画是否执行完毕。如果end设置的比begin小，则动画根本不会执行。 end同样可以指定一个其他的begin或者end，同样支持计算。 重复动画通过设置repeatDur或者repeatCount属性，让动画重复执行。 repeatDur 设置动画执行的总时长。在repeatDur设置的时间内，动画一直会重复执行。如果repeatDur小于dur，repeatDur的作用与end一样。 repeatCount 设置动画重复执行的次数。repeatDur和repeatCount都可以通过设置为indefinit实现无限循环动画。当repeatDur和repeatCount同时作用于同一个时，动画终止时间取两者中较小值。repeat可作为begin和end中的参数使用：123456&lt;circle cx="60" cy="60" r="15" style="fill: none; stroke: red;"&gt; &lt;animate id="circleAnim" attributeName="cx" attributeType="XML" begin="0s" dur="5s" repeatCount="3" from="60" to="260" fill="freeze"/&gt;&lt;/circle&gt;&lt;rect x="230" y="80" width="30" height="30" style="fill: #ccf; stroke: black;"&gt; &lt;animate attributeName="x" attributeType="XML" begin="circleAnim.repeat(1)+2.5s" dur="5s" from="230" to="30" fill="freeze"/&gt;&lt;/rect&gt; 长方形的动画会在圆形动画执行过一遍后延迟2.5秒后开始执行。repeat(n)中的n需大于0。 复杂属性的动画动画还可作用于颜色、paths、d等非纯数字属性。 颜色的动画过程可以分解成r,g,b,a四个数字的渐变。比如从#f00变化到#0f0，红色部分从1渐变到0，绿色部分同时从0渐变到1。paths和d要实现动画有一个前提，其参数个数不能变。变化前后参数一一对应，所有参数同时渐变。12345678910111213&lt;polygon points="30 30 70 30 90 70 10 70" style="fill:#fcc; stroke:black"&gt; &lt;animate id="animation" attributeName="points" attributeType="XML" to="50 30 70 50 50 90 30 50" begin="0s" dur="5s" fill="freeze"/&gt;&lt;/polygon&gt;&lt;path d="M15 50 Q 40 15, 50 50, 65 32, 100 40" style="fill:none; stroke: black" transform="translate(0,50)"&gt; &lt;animate attributeName="d" attributeType="XML" to="M50 15 Q 15 40, 50 50, 32 65, 40 100" begin="0s" dur="5s" fill="freeze"/&gt;&lt;/path&gt; 多节点动画实现一个属性的连续变化有两种方式： 多个组合 使用value + keyTimes + calcMode属性 基础动画中提到过多组合方式；这里说下values + keyTimes + calcMode。 values values属性值表示一个动画经过的节点数值，数值间以分号分割。1234567&lt;circle cx="175" cy="75" r="20" fill="red"&gt; &lt;animate attributeName="r" attributeType="XML" values="20;50;20" begin="0" dur="1" repeatCount="indefinite" fill="freeze"&gt;&lt;/animate&gt;&lt;/circle&gt; 上例中1秒内，圆的半径由20变为50，再由50变为20。 keyTimes keyTimes属性值与values属性值一一对应，第一个数值永远是0（表示起始时间点），最后一个数值永远是1（表示终止时间点）,中间的数值表示变化到对应values属性值时所处时间点百分比(0~1之间)。12345678&lt;circle cx="175" cy="75" r="20" fill="red"&gt; &lt;animate attributeName="r" attributeType="XML" values="20;50;20" keyTimes="0;0.2;1" begin="0" dur="1" repeatCount="indefinite" fill="freeze"&gt;&lt;/animate&gt;&lt;/circle&gt; 上例中0.2秒时圆的半径由20变为50，在之后的0.8秒又从50变为20。 calcMode calcMode可以影响动画各阶段的表现。calcMode有四种属性值：paced, linear, discrete, spline calcMode=”paced”时，动画会忽略keyTimes属性，根据values数值以匀速变化。calcMode=”linear”时，动画根据values和keyTimes属性，在每个时间段内匀速变化。linear为calcMode的默认属性值。calcMode=”discrete”时，动画根据values和keyTimes属性，去掉过度动画，到了keyTimes的某个节点，属性值直接变为values对应数值。calcMode=”spline”时，需要配合keySplines属性，设置每个时间段内的三次贝塞尔变化曲线。123456789&lt;circle cx="175" cy="75" r="20" fill="red"&gt; &lt;animate attributeName="r" attributeType="XML" values="20;50;20" keyTimes="0;.15;1" calcMode="spline" keySplines=".5 0 .5 1;.5 0 .5 1" begin="0" dur="1" repeatCount="indefinite" fill="freeze"&gt;&lt;/animate&gt;&lt;/circle&gt; 上例中加上贝塞尔曲线后圆形的变化有点类似心跳的节奏。 &lt;set&gt;元素也可设置属性变化的动画，但与有明显区别： 不需要from属性，起始状态即为父节点属性值。 一到begin属性设置的时点，指定的attributeName属性值即改为to指定的属性值，没有过度动画。 attributeName可以是属性值非数字的属性，如style=”visibility: hidden;” 1234567&lt;text text-anchor="middle" x="60" y="60" style="visibility: hidden;"&gt; &lt;set attributeName="visibility" attributeType="CSS" to="visible" begin="1s" dur="10s" fill="freeze"&gt;&lt;/set&gt; &lt;set attributeName="x" attributeType="XML" to="120" begin="2s" dur="10s" fill="freeze"&gt;&lt;/set&gt; All gone!&lt;/text&gt; 上例中1秒后显示All gone!，再过1秒后文字移动至（120,60）。 &lt;animateTransform&gt;要实现transform属性改变的动画，需要使用来替代。1234&lt;rect x="-10" y="-10" width="20" height="20" style="fill: #ff9; stroke: black;"&gt; &lt;animateTransform id="a1" attributeName="transform" attributeType="XML" type="scale" from="1" to="4 2" additive="sum" begin="0s" dur="4s" fill="freeze"&gt;&lt;/animateTransform&gt; &lt;animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0" to="45" additive="sum" begin="a1.end" dur="4s" fill="freeze"&gt;&lt;/animateTransform&gt;&lt;/rect&gt; 的attributeName指定为transform（个人感觉有点多余，animateTransform本身就是应用于改变transform属性值的）。用type属性指定transform需要改变的属性（translate, scale, rotate, skewX, skewY）。 还有个additive属性。上例中两个同时作用于一个元素，默认情况下additive属性值为replace，表示当前的初始状态与之前的变化结果无关。如果additive=”sum”，表示当前的变化基于之前的变化之上。 (刚看到一个长方形使用rotate会变成一个菱形感觉哪里不对，再回想了一下translate的本质和形变的次序，就明了了) &lt;animateMotion&gt;是个很强大的元素，之前所有动画功能在css里都可以用animation实现，但能实现的功能是单凭css无法实现的。 可以让父元素沿着指定的路径运动！直线路径可以简单使用from + to属性来指定起点和终点：123456&lt;g&gt; &lt;rect x="0" y="0" width="50" height="30" style="fill: #ccc;"/&gt; &lt;circle cx="40" cy="30" r="10" style="fill: #cfc; stroke: green;"/&gt; &lt;circle cx="10" cy="30" r="10" style="fill: #cfc; stroke: green;"/&gt; &lt;animateMotion from="0,0" to="60,30" dur="4s" fill="freeze"/&gt;&lt;/g&gt; 也可以实用path指定复杂的路径123456&lt;g&gt; &lt;rect x="0" y="0" width="50" height="30" style="fill: #ccc;"/&gt; &lt;circle cx="40" cy="30" r="10" style="fill: #cfc; stroke: green;"/&gt; &lt;circle cx="10" cy="30" r="10" style="fill: #cfc; stroke: green;"/&gt; &lt;animateMotion path="M50,125 C 100,25 150,225, 200, 125" dur="4s" fill="freeze"/&gt;&lt;/g&gt; 也可以指定元素作为自己的路径123456789&lt;path id="cubicCurve" d="M50,125 C 100,25 150,225, 200, 125"/&gt;&lt;g&gt; &lt;rect x="0" y="0" width="50" height="30" style="fill: #ccc;"/&gt; &lt;circle cx="40" cy="30" r="10" style="fill: #cfc; stroke: green;"/&gt; &lt;circle cx="10" cy="30" r="10" style="fill: #cfc; stroke: green;"/&gt; &lt;animateMotion dur="6s" fill="freeze"&gt; &lt;mpath xlink:href="#cubicCurve"/&gt; &lt;/animateMotion&gt;&lt;/g&gt; 有个rotate属性，默认为0，元素在运动时不会旋转。当设置为auto时，元素对应的水平轴会始终与path路径保持水平，上图中加上rotate=”auto”后的效果就像是车子开过山坡。 &lt;animateMotion&gt;节点与多节点动画类似，也有三个属性用于控制动画的节点。 keyPoints 第一个属性值为0（表示path路径的起始位置），最后一个属性值为1（表示path路径的终点位置），各属性值用分号分割，每个属性值与keyTimes的属性值一一对应，表示到某个时点运动到相对于路径的哪个位置。 keyTimes 第一个属性值为0（表示动画起始时间），最后一个属性值为1（表示动画终止时间），各属性值用分号分割，每个属性值与keyPoints的属性值一一对应，表示运动到某个位置需要的总动画时常占比。 calcMode 与多节点动画中的calcMode属性值及作用完全一致。123456789&lt;path d="M-10,-3 L10,-3 L0,-25z" style="fill: yellow; stroke: red;" &gt; &lt;animateMotion path="M50,125 C 100,25 150,225, 200, 125" rotate="auto" keyPoints="0;0.2;0.8;1" keyTimes="0;0.33;0.66;1" calcMode="linear" dur="6s" fill="freeze"/&gt;&lt;/path&gt; CSS动画css中有两种实现动画的方式：transition和animation。transition用于实现较简单的两点动画，即根据属性的起始状态和终止状态，完整中间过渡动画。 transitiontransition动画相关的css属性如下 transition-property 定义动画属性，可定义多个属性，逗号分隔 transition-duration 定义动画执行时间，单位(s,ms)，可定义多个属性，与transition-property一一对应，逗号分隔 transition-timing-function 与calcMode类似，影响动画的表现。默认值为ease。可选项有：ease | linear | ease-in | ease-out | ease-in-out | step-start | step-end | steps([, [ start | end ] ]?) | cubic-bezier(, , , ) transition-delay 定义动画延迟多少时间后开始执行 其中transition-timing-function中的step-start、step-end和steps有点类似calcMode中的discrete模式，状态之间切换没有中间过渡。具体来说stepts([, [start | end]])的第一个参数必须为正整数，表示分几步变化，第二个参数设置为start时，表示在动画开始执行时就进行变化，设置为end表示在动画经过transition-duration设置的时间才开始变化，第二个参数允许省略，缺省值为end。step-start相当于steps(1, start)即属性一开始就变为最终状态；step-end相当于steps(1,end)即属性经过transition-duration设置的时间后立刻变为终止状态。123456#car&#123; transition-property:width, height; transition-duration:1s, 3s; transition-timing-function: ease-in, cubic-bezier(1,0,0,1); transition-delay:2s, 0.5s;&#125; 可使用transition缩写简化上例中的css，直接从W3C规范里抄了下缩写组成部分。 123transition:&lt;single-transition&gt; [ ‘,’ &lt;single-transition&gt; ]*&lt;single-transition&gt; = [ none | &lt;single-transition-property&gt; ] || &lt;time&gt; || &lt;single-transition-timing-function&gt; || &lt;time&gt; 第一个对应transition-duration，第二个对应transition-delay。如果有一个里的第一个参数设置为none，则整个transition无效。也就是说none只能这么用：transition:none123#car&#123; transition:width 1s ease-in 2s, height 3s cubic-bezier(1,0,0,1) .5s;&#125; animationanimation可以说是transition的高级版，配合@keyframes可以实现对动画过程的多点控制。除了svg中延指定path路径运动的动画实现不了，其他都可以用animation来实现。其很多属性与svg的元素属性作用也能一一对应。先看下animation的属性 animation-name 对应的attributeName属性，属性值为@keyframes名对应，后面再说@keyframes animation-duration 对应的dur属性 animation-timing-function 对应的calcMode属性，可用三次贝塞尔曲线来设置动画运行的效果 animation-iteration-count 对应的repeatCount属性。默认为1。infinite表示无限重复（不同于repeatCount的indefinte） animation-delay 动画延迟执行时间。有点类似的start属性的作用，用start加上一些事件和时间的计算，也可以实现延迟执行动画的效果 animation-fill-mode 类似的fill属性，但有区别。animation-fill-mode有四个属性值可选：none | forwards | backwards | both。 forwards类似fill的freeze，动画结束后保持最后一帧时的状态。 backwards这个功能svg里好像没有。backwards是配合animation-delay一起使用的，如果动画延迟执行，那么在开始执行之前处于延迟的这段时间内，动画对象元素的默认状态是其原始状态，而非@keyframes的起始状态。当animation-fill-mode设置成backwards时，动画对象元素在延迟的这段时间内，将处于@keyframes设置的起始状态。 both相当于同时设置了forwards和backwards两个属性值。 nonenone是animation-fill-mode的默认属性值，即动画开始前和动画结束后，对象元素均处于其原始状态。 animation-play-state animation-play-state顾名思义控制动画状态的，两个属性值也好理解。 running表示让动画执行 paused表示暂停动画可以通过改变这个属性来控制动画的播放和暂停，pause改为running后不会让元素重头再执行一遍动画，而是接着暂停时的状态继续变化。 animation-direction 这个属性用于控制动画是正向执行，或者反向执行，如果设置了animation-iteration-count重复执行次数，还能控制一次动画执行完毕后，以何种方式执行接下去的一次动画。有四个属性值normal | reverse | alternate | alternate-reverse normal默认属性值，动画正向执行，重复执行动画时，每次都从起始状态开始变化。 reverse动画反向执行，即从指定的终止状态变化到起始状态，重复执行动画时，每次都从终止状态开始变化。其中animation-timing-function设置的运动曲线也会被颠倒，原来的ease-in会变成ease-out的效果。 alternate第一次执行动画时，从起始状态开始变化。重复执行动画时，单次动画结束后，下一次动画以当前状态作为起始状态开始变化，以上一次动画的起始状态作为该次动画的终止状态，相当于执行一次reverse的动画效果。 alternate-reverse和alternate类似，但是第一次执行动画时，从指定的结束状态开始向起始状态变化。可以用animation来缩写以上所有属性：123animation:&lt;single-animation&gt; [ ‘,’ &lt;single-animation&gt; ]*&lt;single-animation&gt; = &lt;single-animation-name&gt; || &lt;time&gt; || &lt;single-animation-timing-function&gt; || &lt;time&gt; || &lt;single-animation-iteration-count&gt; || &lt;single-animation-direction&gt; || &lt;single-animation-fill-mode&gt; || &lt;single-animation-play-state&gt; 其中第一个为animation-duration，第二个为animation-delay。 再来看与animation紧密相关的@keyframes@keyframes的作用类似values + keyTimes，可精细设置动画过程中每个变化节点。@keyframes必须包含一个动画起始状态信息，和一个动画终止状态信息。可以用from + to，也可以用0% + 100%：1234567891011121314151617181920@keyframes rotate1&#123; from &#123; left: 0; top: 0; &#125; to &#123; left: 100px; top: 100px; &#125;&#125;@keyframes rotate2&#123; 0% &#123; left: 0; top: 0; &#125; 100%&#123; left: 100px; top: 100px; &#125;&#125; 以上两段代码等价，都表示起始状态的left和top属性为0，终止状态的left和top属性为100px。对于中间动画节点，比如在动画进行到四分之一时，希望left为50px：12345678910111213@keyframes rotate2&#123; 0% &#123; left: 0; top: 0; &#125; 50%&#123; left: 50px; &#125; 100%&#123; left: 100px; top: 100px; &#125;&#125; 另外，还可以对每段动画的变化曲线做单独设置animation-timing-function属性，属性需要设置在起始状态信息中：123456789101112131415@keyframes rotate2&#123; 0% &#123; left: 0; top: 0; animation-timing-function: ease-out; &#125; 50%&#123; left: 50px; animation-timing-function: ease-in; &#125; 100%&#123; left: 100px; top: 100px; &#125;&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas-nest.js]]></title>
    <url>%2Fyear%2F04%2F17%2F53322%2F</url>
    <content type="text"><![CDATA[可能大家会看到很多像我博客背景中有网状物的东西在漂浮，感觉很好玩，我第一次见得时候也是感觉特别有意思。今天就来说一下，当然这个炫酷的东西不是我写的，项目地址.如果你想在你网站中使用，可以直接在&lt;/body&gt;前加上1&lt;script src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"&gt;&lt;/script&gt; 就可以了。源码这里也搬运一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * Copyright (c) 2016 hustcc * License: MIT * Version: v1.0.1 * GitHub: https://github.com/hustcc/canvas-nest.js**/! function() &#123; //封装方法，压缩之后减少文件大小 function get_attribute(node, attr, default_value) &#123; return node.getAttribute(attr) || default_value; &#125; //封装方法，压缩之后减少文件大小 function get_by_tagname(name) &#123; return document.getElementsByTagName(name); &#125; //获取配置参数 function get_config_option() &#123; var scripts = get_by_tagname("script"), script_len = scripts.length, script = scripts[script_len - 1]; //当前加载的script return &#123; l: script_len, //长度，用于生成id用 z: get_attribute(script, "zIndex", -1), //z-index o: get_attribute(script, "opacity", 0.5), //opacity c: get_attribute(script, "color", "0,0,0"), //color n: get_attribute(script, "count", 99) //count &#125;; &#125; //设置canvas的高宽 function set_canvas_size() &#123; canvas_width = the_canvas.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, canvas_height = the_canvas.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; &#125; //绘制过程 function draw_canvas() &#123; context.clearRect(0, 0, canvas_width, canvas_height); //随机的线条和当前位置联合数组 var e, i, d, x_dist, y_dist, dist; //临时节点 //遍历处理每一个点 random_points.forEach(function(r, idx) &#123; r.x += r.xa, r.y += r.ya, //移动 r.xa *= r.x &gt; canvas_width || r.x &lt; 0 ? -1 : 1, r.ya *= r.y &gt; canvas_height || r.y &lt; 0 ? -1 : 1, //碰到边界，反向反弹 context.fillRect(r.x - 0.5, r.y - 0.5, 1, 1); //绘制一个宽高为1的点 //从下一个点开始 for (i = idx + 1; i &lt; all_array.length; i++) &#123; e = all_array[i]; // 当前点存在 if (null !== e.x &amp;&amp; null !== e.y) &#123; x_dist = r.x - e.x; //x轴距离 l y_dist = r.y - e.y; //y轴距离 n dist = x_dist * x_dist + y_dist * y_dist; //总距离, m dist &lt; e.max &amp;&amp; (e === current_point &amp;&amp; dist &gt;= e.max / 2 &amp;&amp; (r.x -= 0.03 * x_dist, r.y -= 0.03 * y_dist), //靠近的时候加速 d = (e.max - dist) / e.max, context.beginPath(), context.lineWidth = d / 2, context.strokeStyle = "rgba(" + config.c + "," + (d + 0.2) + ")", context.moveTo(r.x, r.y), context.lineTo(e.x, e.y), context.stroke()); &#125; &#125; &#125;), frame_func(draw_canvas); &#125; //创建画布，并添加到body中 var the_canvas = document.createElement("canvas"), //画布 config = get_config_option(), //配置 canvas_id = "c_n" + config.l, //canvas id context = the_canvas.getContext("2d"), canvas_width, canvas_height, frame_func = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(func) &#123; window.setTimeout(func, 1000 / 45); &#125;, random = Math.random, current_point = &#123; x: null, //当前鼠标x y: null, //当前鼠标y max: 20000 // 圈半径的平方 &#125;, all_array; the_canvas.id = canvas_id; the_canvas.style.cssText = "position:fixed;top:0;left:0;z-index:" + config.z + ";opacity:" + config.o; get_by_tagname("body")[0].appendChild(the_canvas); //初始化画布大小 set_canvas_size(); window.onresize = set_canvas_size; //当时鼠标位置存储，离开的时候，释放当前位置信息 window.onmousemove = function(e) &#123; e = e || window.event; current_point.x = e.clientX; current_point.y = e.clientY; &#125;, window.onmouseout = function() &#123; current_point.x = null; current_point.y = null; &#125;; //随机生成config.n条线位置信息 for (var random_points = [], i = 0; config.n &gt; i; i++) &#123; var x = random() * canvas_width, //随机位置 y = random() * canvas_height, xa = 2 * random() - 1, //随机运动方向 ya = 2 * random() - 1; // 随机点 random_points.push(&#123; x: x, y: y, xa: xa, ya: ya, max: 6000 //沾附距离 &#125;); &#125; all_array = random_points.concat([current_point]); //0.1秒后绘制 setTimeout(function() &#123; draw_canvas(); &#125;, 100);&#125;(); 不得不多，css3和html5是越来越强大了，可以实现很多之前只能用js实现的效果，而且js也是越来越强大，所以前端还是很有前途的。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将视频作为页面背景的问题]]></title>
    <url>%2Fyear%2F04%2F16%2F3879%2F</url>
    <content type="text"><![CDATA[使用视频作为网页背景是件很酷的事情，但也是件困难的事情。CSS里的background-image属性只能使用图片、SVG、颜色或渐变色。但从技术讲，我们是可以伪造出一种效果，让视频以背景的角色出现在其它HTML元素后面。这其中的难点是视频要填充整个浏览器页面，而且要响应浏览器窗口大小的变化。 观看演示1 视频作为网页背景的限制因素在动手编码实现前，视频作为网页背景的有些问题我们要先考虑清楚： 并不是因为技术上可行你就可以任意使用：作为背景的视频内容必须能增强页面内容的感染力，而不是因为漂亮或技术上很酷就使用它。 作为背景的视频应该设置为自动播放，而默认状态下应该是关闭声音；事实上，视频里面最好不含声音。(你可以在页面上放置一个控制声音的按钮。) 背景视频应该有个替代图片，当浏览器不支持这种HTML5技术、视频格式时用图片替代。在等待背景视频加载的过程中也应该使用背景图片占位。而对于一些手机移动设备不支持视频自动播放，也应该使用图片替代。 视频长度很重要：太短了会明显感到重复播放(背景视频通常情况是重复播放的)，太长就变成了情节叙事，如果这样，这段视频应该单独放到页面上播放。我建议视频的长度应该是12-30秒之间。 带宽是个大问题。视频的体积应很小，尽量的压缩。同时，它需要在不同尺寸设备上自动的适应屏幕大小。如果有可能，应该使用JavaScript控制对不同的屏幕大小加载不同分辨率的背景视频。背景视频最好小于5M，如果你小于500K，那是更好。 对上面说的这些情况心里要有数，下面我们来看看技术实现上的细节。 CSS代码使用HTML5里播放视频的代码方法视频：1234567&lt;video autoplay loop poster="polina.jpg" id="bgvid"&gt; &lt;source src="polina.webm" type="video/webm"&gt; &lt;source src="polina.mp4" type="video/mp4"&gt;&lt;/video&gt; 注意：这里摆放视频格式的顺序很重要，因为有些版本的谷歌浏览器里，如果.webm格式的视频放在了其他视频后面，视频将无法播放。 我们使用视频的第一帧图像作为视频的封面图片，这样，当背景视频一旦加载完成，我们可以看到很流畅的从图片过度到背景视频播放。 让视频扩展到全屏的方法：12345678910111213video#bgvid &#123; position: fixed; right: 0; bottom: 0; min-width: 100%; min-height: 100%; width: auto; height: auto; z-index: -100; background: url(polina.jpg) no-repeat; background-size: cover; &#125; 一些老式的浏览器无法播放这种格式的视频，但它们仍然识别&lt;video&gt;标记(除了IE8/6)。对于这些浏览器，我们使用了background-image来弥补它们的不支持，使用的图片就是视频的封面图片。 你可能会发现，在手机设备上，&lt;video&gt;标记是无法扩展到全屏的，因为这些设备的屏幕长宽比限制了视频的扩展。我在以后的文章里了会继续探讨这个问题。 视频背景技术在 IE 8 上的问题IE8不仅不能识别&lt;video&gt;标记，它对所有的HTML5标记都不能识别，这是一个问题，对于IE8，我们至少要让替代的背景图片能显示出来。为了达到这个目的，我们需要两件事情：一行JavaScript代码，一个CSS条件判断注释语句。123456789&lt;!--[if lt IE 9]&gt;&lt;script&gt; document.createElement('video');&lt;/script&gt;&lt;![endif]--&gt; 在你的CSS代码里做如下的声明，让IE知道&lt;video&gt;是一个block元素：1video &#123; display: block; &#125; 有了这句代码，IE8至少能识别&lt;video&gt;标记，可以正确的显示背景图片。 使用JavaScript实现视频背景尽管使用HTML5/CSS3实现视频背景要比使用JavaScript好一些，但不妨说一下，有一些jQuery插件和JavaScript工具包也能达到视频背景的效果。下面是几个演示： 观看演示2 &nbsp;&nbsp;观看演示3 结论如果一个网站上使用了视频背景，那会变得相当的酷，但是，“能力越大，责任越大”，请审慎明智的使用。 (英文：Create Fullscreen HTML5 Page Background Video.)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSS里的line-height详解]]></title>
    <url>%2Fyear%2F04%2F15%2F31791%2F</url>
    <content type="text"><![CDATA[一、前言最近写CSS一直会用到line-height属性，但对其一直是一知半解。在看完《CSS权威指南》后，这周末就写写line-height的相关内容。 二、 基线、行间距和行高先说清楚一些名词概念，这是理解下文的基础,首先看一张图: 基线: 一个文本行分成4格线，分别是顶线、中线、基线、底线， 1基线的位置与 字体font-family 有关，不同的字体基线的位置有偏差 内容区（content area）: 顶线与底线包围的区域,其高度与字体和字号相关, 1粗略等于 font-size值; 行间距: 文本行基线之间的距离,由 line-height-font-size决定;还是看上面那张图，就有比较直观的感受了。下面是重点！注意看， line-height= (基线-底线的距离)+行距+(顶线-基线的距离)，等价于 顶线-基线+基线-底线 + 行距 = 顶线-底线 + 行距 而根据上文的定义， 顶线-底线就是内容区的大小，它由 font-size属性决定;所以可以得出: line-height= font-size + 行距 换句话说， 行间距=line-height - font-size 行内框/行高: 它就是单个内联元素的高度！它是由 line-height属性决定的;123我们在内容区的上下两部分，各自加上半行间距(行间距的一半)，就是行内框的高度；所以，行内框的大小就是: `（line-height - font-size)/2+font-size + （line-height - font-size)/2`即`（line-height - font-size) + font-size= line-height` 一定要注意:1仅考虑文本的情况，行内（文本）元素的高度是由line-height决定的，并不是由元素中的文本撑开的 行框: 它就是一行中，有多个内联元素时的 总体高度1由该行中行内框组成, 行框高度要包含最高行内框的顶端和最低行内框的底端 下面这张图，很直观的反应了行内框和行框的概念(但他内容区的): 所以总结一下就是，我们可以简单理解为， font-size :可以控制 内联元素里 文本大小(当然也和font-fmaily有关); line-height:可以控制 内联元素的 文本高度; 三、 line-height属性的值 em/ex和百分数值: 都相对于 (父)元素的font-size值 计算； number: 继承的是一个缩放因子，子元素能够根据自己的字体大小计算行高; 四、图像的行内框1图像元素的行内框高度是由它自己的盒子（height+padding+border+margin）决定的 五、参考文档 1. css中的line-height; 2. CSS line-height与行内框;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习CSS布局]]></title>
    <url>%2Fyear%2F04%2F12%2F7925%2F</url>
    <content type="text"><![CDATA[没有布局如果你只想把所有内容都塞进一栏里，那么不用设置任何布局也是OK的。然而，如果用户把浏览器窗口调整的很大，这时阅读网页会非常难受：读完每一行之后，你的视觉焦点要从右到左移动一大段距离。试着调整下浏览器窗口大小你就明白我的意思了！ 在解决这个问题之前，我们需要了解一个很重要的属性： display. display属性display 是CSS中最重要的用于控制布局的属性。每个元素都有一个默认的 display 值，这与元素的类型有关。对于大多数元素它们的默认值通常是 block 或 inline 。一个 block 元素通常被叫做块级元素。一个 inline 元素通常被叫做行内元素。 block div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素： header 、 footer 、 section 等等。 inlinespan是一个标准的行内元素。一个行内元素可以在段落中像这样包裹一些文字而不会打乱段落的布局。a元素是最常用的行内元素，它可以被用作链接。 none另一个常用的display值是none。一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。 它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。 其他display值还有很多的更有意思的 display 值，例如 list-item 和 table 。这里有一份详细的列表。之后我们会讨论到 inline-block 和 flex 。 额外加分点就像我之前讨论过的，每个元素都有一个默认的 display 类型。不过你可以随时随地的重写它！虽然“人为制造”一个行内元素可能看起来很难以理解，不过你可以把有特定语义的元素改成行内元素。常见的例子是：把 li 元素修改成 inline，制作成水平菜单。 margin:auto;1234#main &#123; width: 600px; margin: 0 auto;&#125; 设置块级元素的 width 可以防止它从左到右撑满整个容器。然后你就可以设置左右外边距为 auto 来使其水平居中。元素会占据你所指定的宽度，然后剩余的宽度会一分为二成为左右外边距。唯一的问题是，当浏览器窗口比元素的宽度还要窄时，浏览器会显示一个水平滚动条来容纳页面。让我们再来改进下这个方案… max-width1234#main &#123; max-width: 600px; margin: 0 auto;&#125; 在这种情况下使用 max-width 替代 width 可以使浏览器更好地处理小窗口的情况。这点在移动设备上显得尤为重要，调整下浏览器窗口大小检查下吧！ 顺便提下， 所有的主流浏览器包括IE7+在内都支持 max-width ，所以放心大胆的用吧。 盒模型在我们讨论宽度的时候，我们应该讲下与它相关的另外一个重点知识：盒模型。当你设置了元素的宽度，实际展现的元素却超出你的设置：这是因为元素的边框和内边距会撑开元素。看下面的例子，两个相同的元素显示的实际宽度却不一样。12345678910.simple&#123; width: 500px; margin: 20px auto;&#125;.fancy&#123; width: 500px; margin: 20px auto; padding: 50px; border-width: 10px;&#125; 以前有一个代代相传的解决方案是通过数学计算。CSS开发者需要用比他们实际想要的宽度小一点的宽度，需要减去内边距和边框的宽度。值得庆幸地是你不需要再这么做了… box-sizing人们慢慢的意识到传统盒子模型不直接，所以它们新增了一个叫做box-sizing的CSS属性。当你设置了一个元素为box-sizing: border-box;时，此元素的内边距和边框不再增加他的宽度。这里由一个与前一页相同的例子，惟一的区别是两个元素都设置了box-sizing: border-box;:12345678910111213141516.simple &#123; width: 500xp; margin: 20px auto; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125; .fancy &#123; width: 500px; margin: 20px auto; padding: 50px; border: solid blue 10px; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125; 既然没有比这更好的方法，一些CSS开发者想要页面上所有的元素都有如此表现。所以开发者们把以下CSS代码放在它们页面上： 12345* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125; 这样可以确保所有的元素都会用这种更直观的方式排版。&lt;br&gt; 不过&lt;code&gt;box-sizing&lt;/code&gt;是个很新的属性，目前你还应该向我上面例子中那样使用&lt;code&gt;-webkit&lt;/code&gt;和&lt;code&gt;-moz-&lt;/code&gt;前缀。这可以启动特定浏览器实验中的特性。同时记住它是支持IE8+的。 position为了制作更多复杂的布局，我们需要讨论下position属性。它有一大堆的值，名字还都特抽象，别提有多难记了。让我们先一个个的过一遍，不过你最好还是把这页放到书签里。 static123.static &#123; position: static;&#125; relative12345678910.relative1 &#123; position: relative;&#125;.relative2 &#123; position: relative; top: -20px; left: 20px; background-color: white; width: 500px;&#125; fixed一个固定定位（position属性的值为fixed)元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。 比如让一个div始终显示在页面右下角，CSS如下：1234567.fixed &#123; position: fixed; bottom: 0; right: 0; width: 200px; background-color: white;&#125; 一个固定定位元素不会保留它原本在页面应有的空隙（脱离文档流）。令人惊讶地是移动浏览器对 fixed 的支持很差。这里有相应的解决方案. absoluteabsolute是最棘手的position值。 absolute 与 fixed 的表现类似，但是它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 position 值不是 static 的元素。 position例子通过具体的例子可以帮助我们更好地理解”position”。下面是一个真正的页面布局。1234567891011121314151617181920212223.container &#123; position: relative;&#125;nav &#123; position: absolute; left: 0px; width: 200px;&#125;section &#123; /* position is static by default */ amrgin-left: 200px;&#125;footer &#123; position: fixed; bottom: 0; left: 0; height: 70px; background-color: white; width: 100%;&#125;body &#123; margin-bottom: 120px;&#125; 这个例子在容器比nav元素高的时候可以正常工作。如果容器比nav元素低，那么nav会溢出到容器的外面。之后我们会讨论下其他布局技术，它们都各有优劣。 float另一个布局中常用的CSS属性是float。float可用于实现文字环绕图片，如下1234img &#123; float: right; margin: 0 0 1em 1em;&#125; clearclear属性被用于控制浮动。比较下面两个例子：12&lt;div class="box"&gt;...&lt;/div&gt;&lt;section&gt;...&lt;/section&gt; 123456.box &#123; float: left; width: 200px; height: 100px; margin: 1em;&#125; 123456789.box &#123; float: left; width: 200px; height: 100px; margin: 1em;&#125;.after-box &#123; clear: left;&#125; 清除浮动(clearfix hack)在使用浮动的时候经常会遇到一个古怪的事情：123img &#123; float: right;&#125; 见证奇迹的时刻到了！有一种比较丑陋的方法可以解决这个问题，它叫做清除浮动（clearfix hack）. 让我们加入一些新的CSS样式：123.clearfix &#123; overflow: auto;&#125; 现在再看看发生了什么：这个可以在现代浏览器上工作。如果你想要支持IE6，你就需要再加入如下样式：1234.clearfix &#123; overflow: auto; zoom: 1;&#125; 有些独特的浏览器需要“额外的关照”。清除浮动这潭 水很深很深，但是这个简单的解决方案已经可以在今天所有的主要浏览器上工作。 浮动布局例子完全使用 float 来实现页面的布局是很常见的。这里有一个我之前用 position 实现的布局例子，这次我使用 float 实现了它。1234567nav &#123; float: left; width: 200px;&#125;section &#123; margin-left: 200px;&#125; 媒体查询“响应式设计（Responsive Design” 是一种让网站针对不同的浏览器和设备“呈现”不同显示效果的策略，这样可以让网站在任何情况下显示的很棒！ 媒体查询是做此事所需的最强大的工具。让我们使用百分比宽度来布局，然后在浏览器变窄到无法容纳侧边栏中的菜单时，把布局显示成一列：1234567891011121314@media screen and (min-width: 600px)&#123; nav &#123; float: left; width: 25%; &#125; section &#123; margin-left: 25%; &#125;&#125;@media screen and (max-width: 599px)&#123; nav li&#123; display: inline; &#125;&#125; 使用 meta viewport 之后可以让你的布局在移动浏览器上显示的更好。 inline-block你可以创建很多网格来铺满浏览器。在过去很长的一段时间内使用 float 是一种选择，但是使用 inline-block 会更简单。让我们看下使用这两种方法的例子： 困难的方式（使用浮动）123456789.box &#123; float: left; width: 200px; height: 100px; margin: 1em;&#125;.after-box &#123; clear: left;&#125; 容易的方式（使用 inline-block）你可以用 display 属性的值 inline-block 来实现相同效果。123456.box2 &#123; display: inline-block; width: 200px; height: 100px; margin: 1em;&#125; inline-block布局你可以使用 inline-block 来布局。有一些事情需要你牢记： vertical-align 属性会影响到 inline-block 元素，你可能会把它的值设置为 top 。 你需要设置每一列的宽度 如果HTML源代码中元素之间有空格，那么列与列之间会产生空隙 123456789nav &#123; display: inline-block; vertical-align: top; width: 25%;&#125;.column &#123; display: inline-block; vertical-align: top; width: 75%;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底搞懂 JS 中 this 机制]]></title>
    <url>%2Fyear%2F04%2F10%2F64598%2F</url>
    <content type="text"><![CDATA[目录 this 是什么 this 的四种绑定规则 绑定规则的优先级 绑定例外 扩展：箭头函数 this 是什么 理解this之前， 先纠正一个观点，this 既不指向函数自身，也不指函数的词法作用域。如果仅通过this的英文解释，太容易产生误导了。它实际是在函数被调用时才发生的绑定，也就是说this具体指向什么，取决于你是怎么调用的函数。 this 的四种绑定规则 this的4种绑定规则分别是：默认绑定、隐式绑定、显示绑定、new 绑定。优先级从低到高。 默认绑定什么叫默认绑定，即没有其他绑定规则存在时的默认规则。这也是函数调用中最常用的规则。 来看这段代码：123456function foo() &#123; &#125; console.log( this.a );var a = 2; foo(); //打印的是什么？foo() 打印的结果是2。 因为foo()是直接调用的（独立函数调用），没有应用其他的绑定规则，这里进行了默认绑定，将全局对象绑定this上，所以this.a 就解析成了全局变量中的a，即2。 注意：在严格模式下（strict mode），全局对象将无法使用默认绑定，即执行会报undefined的错误1234567function foo() &#123; "use strict"; console.log( this.a );&#125;var a = 2; foo(); // Uncaught TypeError: Cannot read property 'a' of undefined 隐式绑定除了直接对函数进行调用外，有些情况是，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。123456789101112function foo() &#123; console.log( this.a );&#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;obj.foo(); // ? obj.foo() 打印的结果是3。 这里foo函数被当做引用属性，被添加到obj对象上。这里的调用过程是这样的： 获取obj.foo属性 -&gt; 根据引用关系找到foo函数，执行调用 所以这里对foo的调用存在上下文对象obj，this进行了隐式绑定，即this绑定到了obj上，所以this.a被解析成了obj.a，即3。 多层调用链1234567891011121314151617function foo() &#123; console.log( this.a );&#125;var a = 2;var obj1 = &#123; a: 4, foo: foo &#125;;var obj2 = &#123; a: 3, obj1: obj1&#125;;obj2.obj1.foo(); //? obj2.obj1.foo() 打印的结果是4。同样，我们看下函数的调用过程： 先获取obj1.obj2 -&gt; 通过引用获取到obj2对象，再访问 obj2.foo -&gt; 最后执行foo函数调用 这里调用链不只一层，存在obj1、obj2两个对象，那么隐式绑定具体会绑哪个对象。这里原则是获取最后一层调用的上下文对象，即obj2，所以结果显然是4（obj2.a）。 隐式丢失（函数别名）注意：这里存在一个陷阱，大家在分析调用过程时，要特别小心 先看个代码：12345678910111213function foo() &#123; console.log( this.a );&#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;var bar = obj.foo;bar(); //? bar() 打印的结果是2。 为什么会这样，obj.foo 赋值给bar，那调用bar()为什么没有触发隐式绑定，使用的是默认绑定呢。 这里有个概念要理解清楚，obj.foo 是引用属性，赋值给bar的实际上就是foo函数（即：bar指向foo本身）。 那么，实际的调用关系是：通过bar找到foo函数，进行调用。整个调用过程并没有obj的参数，所以是默认绑定，全局属性a。 隐式丢失（回调函数）123456789101112function foo() &#123; console.log( this.a );&#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;setTimeout( obj.foo, 100 ); // ？ 打印的结果是2。 同样的道理，虽然参传是obj.foo，因为是引用关系，所以传参实际上传的就是foo对象本身的引用。对于setTimeout的调用，还是 setTimeout -&gt; 获取参数中foo的引用参数 -&gt; 执行 foo 函数，中间没有obj的参与。这里依旧进行的是默认绑定。 显示绑定相对隐式绑定，this值在调用过程中会动态变化，可是我们就想绑定指定的对象，这时就用到了显示绑定。 显示绑定主要是通过改变对象的prototype关联对象，这里不展开讲。具体使用上，可以通过这两个方法call(…)或apply(…)来实现（大多数函数及自己创建的函数默认都提供这两个方法）。 call与apply是同样的作用，区别只是其他参数的设置上123456789101112131415function foo() &#123; console.log( this.a );&#125;var a = 2;var obj1 = &#123; a: 3,&#125;;var obj2 = &#123; a: 4,&#125;;foo.call( obj1 ); // ?foo.call( obj2 ); // ? 打印的结果是3, 4。 这里因为显示的申明了要绑定的对象，所以this就被绑定到了obj上，打印的结果自然就是obj1.a 和obj2.a。 硬绑定12345678910111213141516171819202122function foo() &#123; console.log( this.a );&#125;var a = 2;var obj1 = &#123; a: 3,&#125;;var obj2 = &#123; a: 4,&#125;;var bar = function()&#123; foo.call( obj1 );&#125;bar(); // 3setTimeout( bar, 100 ); // 3bar.call( obj2 ); // 这是多少 前面两个（函数别名、回调函数）打印3，因为显示绑定了，没什么问题。 最后一个打印是3。 这里需要注意下，虽然bar被显示绑定到obj2上，对于bar，function(){…} 中的this确实被绑定到了obj2，而foo因为通过foo.call( obj1 )已经显示绑定了obj1，所以在foo函数内，this指向的是obj1，不会因为bar函数内指向obj2而改变自身。所以打印的是obj1.a（即3）。 new 绑定js中的new操作符，和其他语言中（如JAVA）的new机制是不一样的。js中，它就是一个普通函数调用，只是被new修饰了而已。 使用new来调用函数，会自动执行如下操作： 如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个新对象。从第三点可以看出，this指向的就是对象本身。 看个代码：1234567891011function foo(a) &#123; this.a = a;&#125;var a = 2;var bar1 = new foo(3);console.log(bar1.a); // ?var bar2 = new foo(4);console.log(bar2.a); // ? 最后一个打印是3, 4。 因为每次调用生成的是全新的对象，该对象又会自动绑定到this上，所以答案显而易见。 绑定规则优先级 上面也说过，这里在重复一下。优先级是这样的，以按照下面的顺序来进行判断: 数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。 数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话,this绑定的是 指定的对象。 数是否在某个上下文对象中调用(隐式绑定)?如果是的话,this绑定的是那个上下文对象。 果都不是的话,使用默认绑定。如果在严格模式下,就绑定到undefined,否则绑定到 全局对象。 var bar = foo() 规则例外 在显示绑定中，对于null和undefined的绑定将不会生效。 代码如下：12345function foo() &#123; console.log( this.a );&#125;foo.call( null ); // 2foo.call( undefined ); // 2 这种情况主要是用在不关心this的具体绑定对象（用来忽略this），而传入null实际上会进行默认绑定，导致函数中可能会使用到全局变量，与预期不符。 所以对于要忽略this的情况，可以传入一个空对象ø，该对象通过Object.create(null)创建。这里不用{}的原因是，ø是真正意义上的空对象，它不创建Object.prototype委托，{}和普通对象一样，有原型链委托关系。 1. 这里传null的一种具体使用场景是函数柯里化的使用 扩展：箭头函数 最后，介绍一下ES6中的箭头函数。通过“=&gt;”而不是function创建的函数，叫做箭头函数。它的this绑定取决于外层（函数或全局）作用域。 case 1 (正常调用) 普通函数 123456789101112function foo()&#123; console.log( this.a );&#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;obj.foo(); //3 箭头函数 12345678910111213var foo = () =&gt; &#123; console.log( this.a );&#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;obj.foo(); //2foo.call(obj); //2 ，箭头函数中显示绑定不会生效 case 2 （函数回调） 普通函数 123456789101112131415function foo()&#123; return function()&#123; console.log( this.a ); &#125; &#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;var bar = obj.foo();bar(); //2 箭头函数 1234567891011121314151617function foo()&#123; return () =&gt; &#123; console.log( this.a ); &#125; &#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;var bar = obj.foo();bar(); //3 通过上面两个列子，我们看到箭头函数的this绑定只取决于外层（函数或全局）的作用域，对于前面的4种绑定规则是不会生效的。它也是作为this机制的一种替换，解决之前this绑定过程各种规则带来的复杂性。 注意：对于ES6之前，箭头函数的替换版本是这样的12345678910111213141516// es6function foo()&#123; return () =&gt; &#123; console.log( this.a ); &#125; &#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;var bar = obj.foo();bar(); //3 通过上面两个列子，我们看到箭头函数的this绑定只取决于外层（函数或全局）的作用域，对于前面的4种绑定规则是不会生效的。它也是作为this机制的一种替换，解决之前this绑定过程各种规则带来的复杂性。 注意：对于ES6之前，箭头函数的替换版本是这样的1234567891011121314// es6function foo()&#123; return () =&gt; &#123; console.log( this.a ); &#125; &#125;// es6之前的替代方法function foo()&#123; var self = this; return () =&gt; &#123; console.log( self.a ); &#125; &#125; 总结 我们在使用js的过程中，对于this的理解往往觉得比较困难，再调试过程中有时也会出现一些不符合预期的现象。很多时候，我们都是通过一些变通的方式（如：使用具体对象替换this）来规避的问题。可问题一直存在那儿，我们没有真正的去理解和解决它。 本文主要参考了《你不知道的JavaScript（上卷）》，对this到底是什么，具体怎么绑定的，有什么例外情况以及ES6中的一个优化方向，来彻底搞清楚我们一直使用的this到底是怎么玩的。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生需要诗意]]></title>
    <url>%2Fyear%2F04%2F06%2F22604%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周周周杰伦]]></title>
    <url>%2Fyear%2F04%2F01%2F65184%2F</url>
    <content type="text"><![CDATA[网易云下架我伦真是在作死，不过估计这也是鹅厂为了打压网易云采取的卑劣手法吧。不能在云村听我伦真是难受，可是又实在不想用QQ音乐。唉，真是难受啊。不过网易云近来好像有点飘了。大家喜欢用网易云不外乎简洁的界面、贴心的日推和那些段子评论吧。可更新到5.0后，界面不再简洁，为了追短视频的热潮，把网易云硬是变成了网易快手、网易小视频，这应该违背了网易云音乐的初心了吧。本来在版权上就没什么优势，如果只是靠着情怀来拉拢用户，那估计用户也会慢慢流失吧。这次被迫下架杰伦事件希望可以给网易云提个醒，勿忘初心，还是简简单单做回最初的网易云音乐吧，做回大家熟悉的网易云吧。 杰伦所有的歌曲我网盘里整理的有，下载到本地就能继续用网易云听杰伦了。 链接: https://pan.baidu.com/s/1XT711VsLCOMq4FckZgx4dg 密码: anbd]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[知道这20个正则表达式，能让你少写1,000行代码]]></title>
    <url>%2Fyear%2F03%2F25%2F55931%2F</url>
    <content type="text"><![CDATA[正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。 正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码：123var reg = /^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;)$/; var r = fieldValue.match(reg); if(r==null)alert('Date format error!'); 下面是在前端开发中经常使用到的20个正则表达式。 1 . 校验密码强度密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。1^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 2. 校验中文字符串仅能是中文。1^[\\u4e00-\\u9fa5]&#123;0,&#125;$ 3. 由数字、26个英文字母或下划线组成的字符串1^\\w+$ 4. 校验E-Mail 地址同密码一样，下面是E-mail地址合规性的正则检查语句。1[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])? 5. 校验身份证号码下面是身份证号码的正则校验。15 或 18位。 15位：1^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$ 18位：1^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$ 6. 校验日期“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。1^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 7. 校验金额金额校验，精确到2位小数。1^[0-9]+(.[0-9]&#123;2&#125;)?$ 8. 校验手机号下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）1^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$ 9. 判断IE的版本IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。1^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$ 10. 校验IP-v4地址IP4 正则语句。1\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b 11. 校验IP-v6地址IP6 正则语句。1(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])) 12. 检查URL的前缀应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。1234if (!s.match(/^[a-zA-Z]+:\\/\\//))&#123; s = 'http://' + s;&#125; 13. 提取URL链接下面的这个表达式可以筛选出一段文本中的URL。1^(f|ht)&#123;1&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)? 14. 文件路径及扩展名校验验证windows下文件路径和扩展名（下面的例子中为.txt文件）1^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?"&lt;&gt;|]+\\.txt(l)?$ 15. 提取Color Hex Codes有时需要抽取网页中的颜色代码，可以使用下面的表达式。1^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$ 16. 提取网页图片假若你想提取网页中所有图片信息，可以利用下面的表达式。1\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\"\\']&#123;0,1&#125;([^\\"\\'\\ &gt;]*) 17. 提取页面超链接提取html中的超链接。1(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href="https?:\\/\\/)((?!(?:(?:www\\.)?'.implode('|(?:www\\.)?', $follow_list).'))[^"]+)"((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt; 18. 查找CSS属性通过下面的表达式，可以搜索到相匹配的CSS属性。1^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125; 19. 抽取注释如果你需要移除HMTL中的注释，可以使用如下的表达式。1&lt;!--(.*?)--&gt; 20. 匹配HTML标签通过下面的表达式可以匹配出HTML中的标签属性。1&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:".*?"|'.*?'|[\\^'"&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sublime_Text_3快捷键]]></title>
    <url>%2Fyear%2F03%2F20%2F31863%2F</url>
    <content type="text"><![CDATA[Sublime Text 3 快捷键精华版Ctrl+Shift+P：打开命令面板Ctrl+P：搜索项目中的文件Ctrl+G：跳转到第几行Ctrl+W：关闭当前打开文件Ctrl+Shift+W：关闭所有打开文件Ctrl+Shift+V：粘贴并格式化Ctrl+D：选择单词，重复可增加选择下一个相同的单词Ctrl+L：选择行，重复可依次增加选择下一行Ctrl+Shift+L：选择多行Ctrl+Shift+Enter：在当前行前插入新行Ctrl+X：删除当前行Ctrl+M：跳转到对应括号Ctrl+U：软撤销，撤销光标位置Ctrl+J：选择标签内容Ctrl+F：查找内容Ctrl+Shift+F：查找并替换Ctrl+H：替换Ctrl+R：前往 methodCtrl+N：新建窗口Ctrl+K+B：开关侧栏Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身Ctrl+F2：设置/删除标记Ctrl+/：注释当前行Ctrl+Shift+/：当前位置插入注释Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的Ctrl+Shift+A：选择当前标签前后，修改标签用的F11：全屏Shift+F11：全屏免打扰模式，只编辑当前文件Alt+F3：选择所有相同的词Alt+.：闭合标签Alt+Shift+数字：分屏显示Alt+数字：切换打开第N个文件Shift+右键拖动：光标多不，用来更改或插入列内容鼠标的前进后退键可切换Tab文件按Ctrl，依次点击或选取，可需要编辑的多个位置按Ctrl+Shift+上下键，可替换行 选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式 配置编译环境控制台输入（以C++为例） 原理很简单，就是在外部建立一个用来执行文件的 bat，然后调用它。注意的就是，需要用start 来打开一个新窗口，同时需要 pause 一下来看结果，其中很蛋疼的就是Sublime默认后台执行你的start，如果你的pause和start放在一个文件了pause对start %1 的文件是无效的，因此其实需要建立两个文件。注意环境变量。。。（关于什么是环境变量，三两句解释不清楚，最好自己百度一下。） 配好之后个人感觉控制台输入意义不是很大，做题的话都是从文件读入，做开发基本不需要读入。So~ 各位慎重。123456789101112131415161718MyCRun.bat@echo off %1 echo. echo ------------------- pause exit MyCallRun.bat@start MyCRun %1 配置文件在 Sublime Text 3\Packages\C++.sublime-package 。 先备份一下。 修改里面的 C++.sublime-build 为12345678910111213141516171819202122232425&#123; "shell_cmd": "g++ \"$&#123;file&#125;\" -o \"$&#123;file_path&#125;/$&#123;file_base_name&#125;\"", "file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$", "working_dir": "$&#123;file_path&#125;", "selector": "source.c, source.c++", "variants": [ &#123; "name": "Run", "shell_cmd": "g++ \"$&#123;file&#125;\" -o \"$&#123;file_path&#125;/$&#123;file_base_name&#125;\" &amp;&amp; MyCallRun \"$&#123;file_path&#125;/$&#123;file_base_name&#125;.exe\"" // 其实就是这里加了个MyCallRun &#125; ] &#125; C/C++ Sublime Text 3 默认配置好了 c++ 。但是需要你自己把 gcc 目录添加进环境变量 Java Sublime Text 3 默认只运行了 javac，需要自己添加运行。 苦逼看不懂 Sublime 的命令格式，于是把 javac 改成一个自己的bat。（感觉也可以像C++那样用 &amp;&amp; 连起来） 在命令行可直接访问的地方建立 myJRun.bat （我直接放在 jdk/bin 下了）1234567891011121314151617181920212223@ECHO OFF cd %~dp1 ECHO Compiling %~nx1... IF EXIST %~n1.class ( DEL %~n1.class ) javac %~nx1 IF EXIST %~n1.class ( ECHO Running... ECHO ----------------------OUTPUT---------------------- java %~n1 ) 注意不能使用 cls 。 修改java的编译选项（备份好原来的）。 目录：Packages/Java.sublime-package/JavaC.sublime-build123456789&#123; "shell_cmd": "myJRun.bat \"$file\"", "file_regex": "^(...*?):([0-9]*):?([0-9]*)", "selector": "source.java" &#125; 这样以后写的Java代码点 Build 就会自动运行了。 这种办法不能跨平台，再研究研究Sublime自己的方式。 Go 用 Sublime 开发 golang 的环境很简单，只需要安装一个 GoSublime 就差不多了。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L2TP/IPSec配置教程]]></title>
    <url>%2Fyear%2F03%2F19%2F49666%2F</url>
    <content type="text"><![CDATA[上次介绍过在服务器上配置shadowsocks的方法，但这种方法必须要有shadowsocks客户端才能使用，在android和windows下还好，都有客户端可以下载，但在Linux下就比较麻烦了。而我用的正是Linux。所以今天就又配置了L2TP/IPSec，这种连接更加安全，速度也更快，连接更简单。服务器依然用的上次介绍的Vultr，配置的话请看上篇教程。下面进入正题。这次我们采用的是Github上setup-ipsec-vpn这个脚本安装方法，不需要怎么配置，傻瓜式安装。先update一下Ubuntu Debian是sudo apt-get updateCentOS是yum update然后Ubuntu LTS, Debian 系统，使用下列这行代码：1wget https://git.io/vpnsetup -O vpnsetup.sh &amp;&amp; sudo sh vpnsetup.sh CentOS 系统,使用这行代码:1wget https://git.io/vpnsetup-centos -O vpnsetup.sh &amp;&amp; sudo sh vpnsetup.sh 然后就等待安装好。安装好后，会自动分配 Username，Password，Pre-Shared key,这些随机数会让人崩溃。别担心，可以修改的。Ubuntu、Debian复制、运行以下代码:1234wget https://git.io/vpnsetup -O vpnsetup.shnano -w vpnsetup.sh[Replace with your own values: YOUR_IPSEC_PSK, YOUR_USERNAME and YOUR_PASSWORD]sudo sh vpnsetup.sh CentOS是下面代码:1234wget https://git.io/vpnsetup-centos -O vpnsetup.shnano -w vpnsetup.sh[Replace with your own values: YOUR_IPSEC_PSK, YOUR_USERNAME and YOUR_PASSWORD]sudo sh vpnsetup.sh 把 username passward Pre-shared key分别改成你想设置的。这样服务器端就配置好了。 下面配置客户端先说比较麻烦的Linux吧。我的系统是Ubuntu 16.04 Lts，所以这里只介绍Ubuntu系统的。这里只把代码贴出来，依次复制运行就行。1sudo apt install intltool libtool network-manager-dev libnm-util-dev libnm-glib-dev libnm-glib-vpn-dev libnm-gtk-dev libnm-dev libnma-dev ppp-dev libdbus-glib-1-dev libsecret-1-dev libgtk-3-dev libglib2.0-dev xl2tpd strongswan 1git clone https://github.com/nm-l2tp/network-manager-l2tp.git 1cd network-manager-l2tp 12autoreconf -fi intltoolize 1./configure --disable-static --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib/x86_64-linux-gnu --libexecdir=/usr/lib/NetworkManager --localstatedir=/var --with-pppd-plugin-dir=/usr/lib/pppd/2.4.7 12make sudo make install 12sudo apparmor_parser -R /etc/apparmor.d/usr.lib.ipsec.charon sudo apparmor_parser -R /etc/apparmor.d/usr.lib.ipsec.stroke 1sudo apt remove xl2tpd 123456sudo apt install libpcap0.8-dev wget https://github.com/xelerance/xl2tpd/archive/v1.3.6/xl2tpd-1.3.6.tar.gz tar xvzf xl2tpd-1.3.6.tar.gz cd xl2tpd-1.3.6 make sudo make install 这样就好了。点wifi那个标志，编辑连接，增加，VPN里的L2TP，网关是你服务器地址，用户名、密码是你自己设的，再点IPsec设置，ID是你服务器地址，Pre-sharef key是你自己设置的。然后确定。这时候再看你的VPN连接里面就有了，点击连接就OK了。 Windows 10 and 8.x 右键单击系统托盘中的无线/网络图标。 选择 打开网络与共享中心。 单击 设置新的连接或网络。 选择 连接到工作区，然后单击 下一步。 单击 使用我的Internet连接 (VPN)。 在 Internet地址 字段中输入你的 VPN 服务器 IP。 在 目标名称 字段中输入任意内容。单击 创建。 返回 网络与共享中心。单击左侧的 更改适配器设置。 右键单击新创建的 VPN 连接，并选择 属性。 单击 安全 选项卡，从 VPN 类型 下拉菜单中选择 “使用 IPsec 的第 2 层隧道协议 (L2TP/IPSec)”。 单击 允许使用这些协议。确保选中 “质询握手身份验证协议 (CHAP)” 复选框。 单击 高级设置 按钮。 单击 使用预共享密钥作身份验证 并在 密钥 字段中输入你的 VPN IPsec PSK。 单击 确定 关闭 高级设置。 单击 确定 保存 VPN 连接的详细信息。注： 在首次连接之前需要修改一次注册表。请参见下面的说明。 Windows 7, Vista and XP 单击开始菜单，选择控制面板。 进入 网络和Internet 部分。 单击 网络与共享中心。 单击 设置新的连接或网络。 选择 连接到工作区，然后单击 下一步。 单击 使用我的Internet连接 (VPN)。 在 Internet地址 字段中输入你的 VPN 服务器 IP。 在 目标名称 字段中输入任意内容。 选中 现在不连接；仅进行设置以便稍后连接 复选框。 单击 下一步。 在 用户名 字段中输入你的 VPN 用户名。 在 密码 字段中输入你的 VPN 密码。 选中 记住此密码 复选框。 单击 创建，然后单击 关闭 按钮。 返回 网络与共享中心。单击左侧的 更改适配器设置。 右键单击新创建的 VPN 连接，并选择 属性。 单击 选项 选项卡，取消选中 包括Windows登录域 复选框。 单击 安全 选项卡，从 VPN 类型 下拉菜单中选择 “使用 IPsec 的第 2 层隧道协议 (L2TP/IPSec)”。 单击 允许使用这些协议。确保选中 “质询握手身份验证协议 (CHAP)” 复选框。 单击 高级设置 按钮。 单击 使用预共享密钥作身份验证 并在 密钥 字段中输入你的 VPN IPsec PSK。 单击 确定 关闭 高级设置。 单击 确定 保存 VPN 连接的详细信息。注： 在首次连接之前需要修改一次注册表，以解决 VPN 服务器 和/或 客户端与 NAT （比如家用路由器）的兼容问题。 要连接到 VPN： 单击系统托盘中的无线/网络图标，选择新的 VPN 连接，然后单击 连接。如果出现提示，在登录窗口中输入 你的 VPN 用户名 和 密码 ，并单击 确定。最后你可以到 这里 检测你的 IP 地址，应该显示为你的 VPN 服务器 IP。 OS X 打开系统偏好设置并转到网络部分。 在窗口左下角单击 + 按钮。 从 接口 下拉菜单选择 VPN。 从 VPN类型 下拉菜单选择 IPSec 上的 L2TP。 在 服务名称 字段中输入任意内容。 单击 创建。 在 服务器地址 字段中输入你的 VPN 服务器 IP。 在 帐户名称 字段中输入你的 VPN 用户名。 单击 鉴定设置 按钮。 在 用户鉴定 部分，选择 密码 单选按钮，然后输入你的 VPN 密码。 在 机器鉴定 部分，选择 共享的密钥 单选按钮，然后输入你的 VPN IPsec PSK。 单击 好。 选中 在菜单栏中显示 VPN 状态 复选框。 单击 高级 按钮，并选中 通过VPN连接发送所有通信 复选框。 单击 TCP/IP 选项卡，并在 配置IPv6 部分中选择 仅本地链接。 单击 好 关闭高级设置，然后单击 应用 保存VPN连接信息。要连接到 VPN： 使用菜单栏中的图标，或者打开系统偏好设置的网络部分，选择 VPN 并单击 连接。 Android 启动 设置 应用程序。 在 无线和网络 部分单击 更多…。 单击 VPN。 单击 添加VPN配置文件 或窗口右上角的 +。 在 名称 字段中输入任意内容。 在 类型 下拉菜单选择 L2TP/IPSec PSK。 在 服务器地址 字段中输入你的 VPN 服务器 IP。 在 IPSec 预共享密钥 字段中输入你的 VPN IPsec PSK。 单击 保存。 单击新的VPN连接。 在 用户名 字段中输入你的 VPN 用户名。 在 密码 字段中输入你的 VPN 密码。 选中 保存帐户信息 复选框。 单击 连接。 iOS 进入设置 -&gt; 通用 -&gt; VPN。 单击 添加VPN配置…。 单击 类型 。选择 L2TP 并返回。 在 描述 字段中输入任意内容。 在 服务器 字段中输入你的 VPN 服务器 IP。 在 帐户 字段中输入你的 VPN 用户名。 在 密码 字段中输入你的 VPN 密码。 在 密钥 字段中输入你的 VPN IPsec PSK。 启用 发送所有流量 选项。 单击右上角的 存储。 启用 VPN 连接。 好了，在Google的世界里尽情畅游吧！！！]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jinja2 简明教程]]></title>
    <url>%2Fyear%2F03%2F18%2F22581%2F</url>
    <content type="text"><![CDATA[Flask包含强大的Jinja模板语言，学习Flask之前要先学习一下jinja。在Jinja2之前，已经有类似的模板语言，如JSP，Django。这些语言实际上包含了变量以及一些编程逻辑，当它们被呈现为HTML时，它们会被实际值取代。变量和/或逻辑放置在标签或分隔符之间。例如，Jinja模板% … %用于表达式或逻辑（比如for循环），同时 … 用于向用户输出表达式或变量的结果。后者标记在呈现时被替换为一个或多个值，并且最终由用户看到。 Jinja模板只是.html文件。按照惯例，它们位于Flask项目的”/templates”目录中。如果你熟悉字符串格式化或插值，模板语言遵循相似的逻辑类型-只是整个HTML页面的规模。 简单示例运行这些示例(pip insatll jinja2)之前，确保安装了Jinja。12345678Python&gt;&gt;&gt; from jinja2 import Template&gt;&gt;&gt; t = Template("Hello &#123;&#123; something &#125;&#125;!")&gt;&gt;&gt; t.render(something = "world")u'Hello world!'&gt;&gt;&gt; t = Template("My favorite numbers: &#123;% for n in range(1,10) %&#125; &#123;&#123; n &#125;&#125;" "&#123;% endfor %&#125;")&gt;&gt;&gt; t.render()u'My favorite numbers: 1 2 3 4 5 6 7 8 9' 注意呈现给用户的实际输出如何落在标签内。 Flask 示例创建以下项目结构：123├── requirements.txt├── run.py└── templates 激活 virtualenv 安装 flask1$ pip install flask 添加下列代码到run.py1234567891011from flask import Flask, render_templateapp = Flask(__name__)@app.route("/")def template_test(): return render_template('template.html', my_string="Wheeeee!", my_list=[0,1,2,3,4,5])if __name__ == '__main__': app.run(debug=True) 这里我们建立路由/,通过render_template()函数将 template.html 传递到 /地址下。这个函数必须有一个模板名字，你也可以通过关键字参数将值传到模板中。如本例中的my_string和my_list。创建下列模板：12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Flask Template Example&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet" media="screen"&gt; &lt;style type="text/css"&gt; .container &#123; max-width: 500px; padding-top: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;p&gt;My string: &#123;&#123;my_string&#125;&#125;&lt;/p&gt; &lt;p&gt;Value from the list: &#123;&#123;my_list[3]&#125;&#125;&lt;/p&gt; &lt;p&gt;Loop through the list:&lt;/p&gt; &lt;ul&gt; &#123;% for n in my_list %&#125; &lt;li&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;script src="http://code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在templates文件夹中保存为template.html。注意这些模板标签，你能猜到会输出什么吗？运行后浏览器打开http://127.0.0.1:5000/ ，你会看到： 值得注意的是，Jinja只支持一些控制结构 - if语句和for循环是两个主要结构。语法与Python类似，不同之处在于不需要冒号，并且块的终止是使用endifor endfor而不是由空白完成的。您还可以完成控制器或视图中的逻辑，然后使用模板标记将每个值传递给模板。但是，在模板本身内执行这样的逻辑要容易得多。 模板继承模板通常利用继承，其中包含一个基模板，用于定义所有后续子模板的基本结构。使用% extends % 和 % block %实现继承。这个用例很简单：随着应用程序的增长，并且您继续添加新模板，您需要保持常见代码（如HTML导航栏，Javascript库，CSS样式表等）同步，这是很多工作。使用继承，我们可以将这些常见的部分移动到父/基模板，以便我们可以创建或编辑这样的代码，并且所有子模板都将有该代码。 您应该始终在您的基本模板中添加尽可能多的循环代码，以节省您未来的时间，这将远远超过最初的投资时间。 让我们将继承添加到我们的示例中。创建基模板：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Flask Template Example&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet" media="screen"&gt; &lt;style type="text/css"&gt; .container &#123; max-width: 500px; padding-top: 100px; &#125; h2 &#123;color: red;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;h2&gt;This is part of my base template&lt;/h2&gt; &lt;br&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &lt;br&gt; &lt;h2&gt;This is part of my base template&lt;/h2&gt; &lt;/div&gt; &lt;script src="http://code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 保存为layout.html.你注意到% block %标签了吗？这定义了子模板可以填充的块（或区域）。此外，这只是通知模板引擎子模板可能会覆盖模板中的这个块。 可以将这些视为占位符，由来自子模板的代码填充。 接下来更新 template.html:1234567891011121314&#123;% extends "layout.html" %&#125;&#123;% block content %&#125; &lt;h3&gt; This is the start of my child template&lt;/h3&gt; &lt;br&gt; &lt;p&gt;My string: &#123;&#123;my_string&#125;&#125;&lt;/p&gt; &lt;p&gt;Value from the list: &#123;&#123;my_list[3]&#125;&#125;&lt;/p&gt; &lt;p&gt;Loop through the list:&lt;/p&gt; &lt;ul&gt; &#123;% for n in my_list %&#125; &lt;li&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;h3&gt; This is the end of my child template&lt;/h3&gt;&#123;% endblock %&#125; so,% extends %告诉模板引擎该模板“扩展”了另一个模板layout.html。换句话说，这建立了模板之间的链接。运行。你会看到一个常见的用例是添加导航栏。添加以下代码到基模板layout.html,紧跟在开始标签后:123456789101112131415161718192021222324252627282930313233343536373839&lt;nav class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;Jinja!&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-left" role="search"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="Search"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;Dropdown &lt;b class="caret"&gt;&lt;/b&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 现在每个子模板都将具有相同的导航栏。从Java哲学中引用一条真理“Write once, use anywhere.” Super Blocks如果你需要从基本模板渲染块，使用 super block.1&#123;&#123; super() &#125;&#125; 添加页脚到基模板:1234567&lt;div class="footer"&gt; &#123;% block footer %&#125; Watch! This will be added to my base and child templates using the super powerful super block! &lt;br&gt; &lt;br&gt; &#123;% endblock %&#125;&lt;/div&gt; 添加后的代码应该是这样:12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Flask Template Example&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet" media="screen"&gt; &lt;style type="text/css"&gt; .container &#123; max-width: 500px; padding-top: 100px; &#125; h2 &#123;color: red;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;h2&gt;This is part of my base template&lt;/h2&gt; &lt;br&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &lt;br&gt; &lt;h2&gt;This is part of my base template&lt;/h2&gt; &lt;br&gt; &lt;div class="footer"&gt; &#123;% block footer %&#125; Watch! This will be added to my base and child templates using the super powerful super block! &lt;br&gt; &lt;br&gt; &lt;br&gt; &#123;% endblock %&#125; &lt;/div&gt; &lt;/div&gt; &lt;script src="http://code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行 添加 super block到 template.html1234567891011121314151617&#123;% extends "layout.html" %&#125;&#123;% block content %&#125; &lt;h3&gt; This is the start of my child template&lt;/h3&gt; &lt;br&gt; &lt;p&gt;My string: &#123;&#123;my_string&#125;&#125;&lt;/p&gt; &lt;p&gt;Value from the list: &#123;&#123;my_list[3]&#125;&#125;&lt;/p&gt; &lt;p&gt;Loop through the list:&lt;/p&gt; &lt;ul&gt; &#123;% for n in my_list %&#125; &lt;li&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;h3&gt; This is the end of my child template&lt;/h3&gt; &#123;% block footer %&#125; &#123;&#123;super()&#125;&#125; &#123;% endblock %&#125;&#123;% endblock %&#125; 在浏览器中查看 Suoer block用于父模板和子模板共享的通用代码，例如title两个模板共享标题的一部分，然后你只需要传入另一部分。例如父模板123&#123;% block heading %&#125; &lt;h1&gt;&#123;% block page %&#125;&#123;% endblock %&#125; - Flask Super Example&lt;/h1&gt;&#123;% endblock %&#125; 子模板1234&#123;% block page %&#125;Home&#123;% endblock %&#125;&#123;% block heading %&#125; &#123;&#123; super() &#125;&#125;&#123;% endblock %&#125; 看下效果可以试试% block page %Home% endblock %从子模板中移除会发生什么。 尝试一下使用相同的方法更新title 除了硬编码，也可以使用动态方法更新template.html中的两个代码片段：1&#123;％block title％&#125; &#123;&#123;title&#125;&#125; &#123;％endblock％&#125; 1&#123;％block page％&#125; &#123;&#123;title&#125;&#125; &#123;％endblock％&#125; 现在我们需要title从我们的控制器run.py中将一个变量传递给我们的模板：12345@app.route("/")def template_test(): return render_template( 'template.html', my_string="Wheeeee!", my_list=[0,1,2,3,4,5], title="Home") 测试一下。 宏在Jinja中，我们可以使用宏来抽象反复使用的常用代码片段，以避免重复我们自己。例如，突出显示导航栏上当前页面的链接（活动链接）很常见。否则，我们不得不使用if/ elif/ else语句来确定活动链接。使用宏，我们可以将这些代码抽象为一个单独的文件。将 macros.html 添加到 templates目录中：1234567&#123;% macro nav_link(endpoint, name) %&#125;&#123;% if request.endpoint.endswith(endpoint) %&#125; &lt;li class="active"&gt;&lt;a href="&#123;&#123; url_for(endpoint) &#125;&#125;"&gt;&#123;&#123;name&#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;% else %&#125; &lt;li&gt;&lt;a href="&#123;&#123; url_for(endpoint) &#125;&#125;"&gt;&#123;&#123;name&#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;% endif %&#125;&#123;% endmacro %&#125; 在这里，我们使用Flask的请求对象，默认情况下它是Jinja的一部分，用于检查请求的端点，然后将该active类分配给该端点。使用nav navber-nav基本模板中的类更新无需列表：12345&lt;ul class="nav navbar-nav"&gt; &#123;&#123; nav_link('home', 'Home') &#125;&#125; &#123;&#123; nav_link('about', 'About') &#125;&#125; &#123;&#123; nav_link('contact', 'Contact Us') &#125;&#125;&lt;/ul&gt; 另外，请确保在模板顶部添加导入：% from “macros.html” import nav_link with context %。注意我们如何调用nav-link宏并传递两个参数，即端点（来自我们的控制器）和我们想要显示的文本。 最后，让我们向控制器添加三个新端点：1234567891011121314151617@app.route("/home")def home(): return render_template( 'template.html', my_string="Wheeeee!", my_list=[0,1,2,3,4,5], title="Home")@app.route("/about")def about(): return render_template( 'template.html', my_string="Wheeeee!", my_list=[0,1,2,3,4,5], title="About")@app.route("/contact")def contact(): return render_template( 'template.html', my_string="Wheeeee!", my_list=[0,1,2,3,4,5], title="Contact Us") 刷新页面 过滤器Jinja使用过滤器来修改变量，主要用于格式化目的。例如1&#123;&#123; num | round &#125;&#125; 这将对num变量近似取值。如果传值 num=46.99, 将输出47.0.关于过滤器的更多知识，你可以看这里.在某些情况下，你可以在括号中指定可选参数。例如1&#123;&#123;list | join（'，'）&#125;&#125; 这将通过逗号分隔符加入列表。测试一下，添加下列代码到 template.html.1&lt;p&gt;Same list with a filter: &#123;&#123; my_list|join(', ') &#125;&#125;&lt;/p&gt; 除了内置的过滤器，我们也可以自己创建。让我们添加一个我们自己的。一个常见的例子是自定义日期时间过滤器。 创建应用程序后，将以下代码添加到我们的控制器 - app = Flask(name)：123456@app.template_filter()def datetimefilter(value, format='%Y/%m/%d %H:%M'): """convert a datetime to a different format.""" return value.strftime(format)app.jinja_env.filters['datetimefilter'] = datetimefilter 使用@app.template_filter()装饰器，我们将datetimefilter()函数注册为过滤器。 过滤器的默认名称只是该函数的名称; 然而，你可以通过传递一个参数来定制它 - 例如，@app.template_filter(formatdate)。 接下来，我们将过滤器添加到Jinja环境中，使其可访问。现在可以使用了。将以下代码添加到我们的子模板中：1&lt;h4&gt;Current date/time: &#123;&#123; current_time | datetimefilter &#125;&#125;&lt;/h4&gt; 最后，只需将日期时间传递给我们的模板：1current_time=datetime.datetime.now() 测试一下 这只是简明教程，详细教程请看这里。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Jinja2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表的基本概念]]></title>
    <url>%2Fyear%2F03%2F18%2F52829%2F</url>
    <content type="text"><![CDATA[一、线性表的定义线性表：零个或多个数据元素的有限序列。几个关键的地方。 首先它是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都只有一个前驱和后继。 然后，线性表强调是有限的。事实上，在计算机中处理的对象都是有限的，那种无限的数列，只存在于数学的概念中。 如果用数学语言来定义。可如下： 若将线性表记为(a1，…，ai-1，ai，ai+1，…，an)，则表中ai-1领先于ai，ai领先于ai+1，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i = 1，2，…，n-1时，ai有且仅有一个直接后继，当i = 2 , 3 , … , n时，ai有且仅有一个直接前驱。 所以线性表元素的个数n(n ≥ 0)定义为线性表长度，当n=0时，称为空表。 在非空表中的每个数据元素都有一个确定的位置，如a1是第一个数据元素，an是最后一个数据元素，ai是第i个数据元素，称i为数据元素ai在线性表中的位序。 举几个例子，来判断是否是线性表。 第一个：一年的星座列表，是不是线性表呢？ 答：当然是，星座通常都是白羊座开头，双鱼座收尾，当中的星座都有前驱后继，而且一共才12个，所以完全符合线性表的定义。 第二个：公司的组织交媾，总经理管理几个总监，每个总监管理几个经理，每个经理管理各自的下述和员工。这样的组织架构是不是线性关系呢？ 答：不是，为什么不是呢？因为每一个元素，都有不止一个后继，所以它不是线性表。 第三个：班级同学的友谊关系，是不是线性表呢？ 答：不是，因为每个人都可以和多个同学建立友谊，不满足线性的定义。 第四个：班级同学的点名册，是不是线性表？是不是点名册？ 答：是，这和刚才的友谊关系是完全不同的，因为它是有限序列，也满足类型相同特点，这个点名册中，每个元素除学生的学号外，还可以有同学的姓名、性别、出生年月什么的，这其实就是我们之前将的数据项。在较复杂的线性表中，一个数据元素可以由若干个数据项组成。 二、线性表的抽象数据类型线性表的抽象数据类型定义如下：12345678910111213141516ADT 线性表(List)Data 线性表的数据对象集合为&#123;a1,a2,....,an&#125;,每个元素的类型均为DataType。其中除了，第一个元素a1外，每一个元素有且只有一个直接前驱元素，除最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。Operation InitList(*L):初始化操作，建立一个空的线性表。 ListEmpty(L):若线性表为空，返回true，否则返回false。 ClearList(*L):线性表清空。 GetElem(L,i,*e):将线性表L中第i个位置元素返回给e。 LocateElem(L,e):在线性表L中查找与给定值e相等的元素，如果 查找成功,返回该元素在表中的序列号；否则，返回0表示失败。 ListInsert(*L,i,e):在线性表的第i个位置插入元素e。 ListDelete(*L,i,*e):删除线性表L中的第i个元素，并用e返回其值 ListLength(L):返回线性表L的元素个数。对于不同的应用，线性表的操作时不同的，上述操作时最基本的，问题中设计的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。 比如，要实现两个线性表集合A和B的并集操作。即要使得集合A = A ∪ B，说白了，就是把存在集合B中但并不存在中的数据元素插到A中即可。 仔细分析一下这个操作，发现我们只要循环集合B中的元素，判断是否存在A中，若不存在，则插到A中即可。思路应该是很容易想到的。 假设我们La表示集合A，Lb表示集合B，则实现代码如下：12345678910111213141516//将所有的在线性表Lb中但不在La中的元素插入到La中void unionL(List *La , List Lb)&#123; int La_len,Lb_len,i; ElemType e; La_len = ListLength(*La); Lb_len = ListLength(*Lb); for(i = 0 ;i ≤ Lb;i++) &#123; GetElem(Lb,i,*e);//取出Lb中第i个数据元素赋给e if(!LocateElem(*La,e))//La中不存在和e元素相同的数据元素 &#123; ListInsert(La,++La_len,e);//插入 &#125; &#125;&#125; 这里我们对于union操作，用到了前面线性表基本操作ListLength、GetElem、LocateElem，ListLength等，可见，对于复杂的个性化的操作，其实就是把基本操作组合起来实现的。 三、线性表的顺序存储结构1.顺序存储定义说了这么多的线性表，我们来看线性表的物理结构第一种——顺序存储结构。 线性表的顺序存储结构，指定的是用一段地址连续的存储单元一次存储线性表的数据元素。 2.顺序存储方式线性表的顺序存储方式，说白了，就是在内存中找了一块地方，把一定内存空间占了，然后把相同数据类型的数据元素一次存在在里面。既然线性表的数据元素的类型都相同，所以用C语言的一维数组来实现顺序存储结构，即把第一个数据元素存储到数组下表为0的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。 为了建立一个线性表，要在内存中找一块地，于是这块地的第一个位置就非常关键，它是存储空间的起始位置。 线性表中，我们估算这个线性表的最大存储容量，建立一个数组，数组的长度就是最大存储容量。 我们已经有了起始位置，也有了最大的容量，于是我们可以在里面增加数据了。随着数据的插入，我们线性表的长度开始变大，不过线性表的当前长度不能超过存储容量，即数组的长度。 来看线性表的顺序存储的结构代码。1234567#define MAXSIZE 20 //存储空间初始分配量typedef int ElemType;//ElemType根据实际情况而定，这里假设为inttypedef struct&#123; ElemType data[MAXSIZE];//数组存储数据元素,最大值为MAXSIZE int length;//线性表当前长度&#125;SqList; 这里我们发现描述顺序存储结构需要三个属性： ①存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。 ②线性表的最大存储容量：数组长度MaxSize。 ③线性表的当前长度：length。 3.数组长度与线性表长度区别数组长度是存放线性表的存储空间的长度，存储空间分配完一般是不变的。 线性表长度是线性表中元素数据的个数，随着线性表插入和删除操作的进行，这个量是变化的。 在任意时刻，线性表的长度应该小于等于数组的长度。 4.地址计算方法线性表的起始是从1开始的，可数组却是从0开始第一个下标的，于是线性表中第i个元素，存储在数组下标为i - 1的位置。 用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。 由于每个数据元素，不管他是整型、实型还是字符型，它都是需要占用一定的存储空间的。假设占用的是c个存储单元，那么线性表中第i + 1个元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。1LOC(ai+1) = LOC(ai) + c 所以对于第i个数据元素ai的存储位置可以由a1推算得出：1LOC(ai) = LOC(ai) + (i - 1) * c 通过这个公式，随时可以算出线性表中任意位置的地址，不管他是第一个还是最后一个，都是相同的事件。那么我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此我们算法中学到的时间复杂度的概念来说，它的存取时间的性能为O(1)。我们通常把具有这一特点的存储结构称为随机存取结构。 四、顺序存储结构的插入与删除1.获得元素操作对于线性表的顺序存储结构来说，我们要实现GetElem操作，即将线性表L中的第i个位置元素返回，其实是非常简单的。就程序而言，只要第i个元素在下标范围内，就是把数组第i - 1下表值返回即可。 来看代码：123456789101112131415#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;//Status是函数的类型，其值是函数结果状态代码，如OK等//初始条件：顺序线性表L已经存在，1 ≤ i ≤ ListLength(L)//操作结果：用e返回L中第i个元素的值Status GetElem(SqList L,int i,ElemType *e)&#123; if(L.length == 0 || i &lt; 1 || i &gt; L.length) return ERROR; *e = L.data[i - 1]; return OK;&#125; 注意这里返回值类型Status是一个整型，返回OK代表1，ERROR代表0。 2.插入操作刚才我们也谈到，这里的时间复杂度为O(1)。我们现在来考虑，如果我们要实现ListInsert(*L，i，e)，即在线性表L中第i个位置插入新元素e，应该如何操作？ 插入算法的思路： ①如果插入位置不合理，抛出异常； ②如果线性表长度大于等于数组长度，则抛出异常或动态增加容量； ③从最后一个元素开始向前遍历到第i个元素，分别将它们都向后移一位； ④将要插入元素填入位置i处； ⑤表长加1。 实现代码如下：12345678910111213141516171819202122//初始条件:顺序线性表L已存在,1 ≤ i ≤ ListLength(L)//操作结果:在L的第i个位置插入新的数据元素e,L的长度加1Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if(L-&gt;length == MAXSIZE)//当线性表已满 return ERROR; if(i &lt; 1 || i &gt;L-&gt;length + 1)//当i不在范围内时 &#123; return ERROR; &#125; if(i &lt;= L-&gt;length)//若插入数据位置不在表尾 &#123; for(k = L-&gt;length-1;k &gt; i-1;k--) &#123; L-&gt;data[k + 1] = L-&gt;data[k]; &#125; &#125; L-&gt;data[i - 1] = e;//将新元素插入 L-&gt;length++; return OK;&#125; 3.删除操作删除算法的思路： ①如果删除位置不合理，抛出异常； ②取出删除元素； ③从删除元素位置开始遍历到最后一个元素位置，分别将它们向前移动一个位置； ④表长减1。 实现代码如下：123456789101112131415161718//初始条件:顺序线性表L已经存在，1 &lt;= i &lt;= ListLength(L)//操作结果:删除L的第i个元素,并用e返回其值,L的长度减1Status ListDelete(SqList *L ,int i , ElemType *e)&#123; int k; if(L-&gt;length == 0)//线性表为空 return ERROR; if(i &lt; 1 || i &gt; L-&gt;length)//删除位置不正确 return ERROR; *e = L-&gt;data[i]; if(i &lt; L-&gt;length) &#123; for(k = i;k &lt; L-&gt;length;k++) L-&gt;data[k - 1] = L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 现在，我们来分析一下，插入和删除的事件复杂度。 现在我们来看最好的情况，如果一个元素要插入到最后一个位置，或者删除最后一个位置，此时时间复杂度为O(1)，因为不需要移动元素的。 最坏的情况呢，如果元素要插入到第一个位置或者删除第一个元素，此时时间复杂度是多少呢？那就意味着所有元素向后或者向前，所以这个时间复杂度为O(n)。 至于平均的情况，由于元素插入到第i个位置，或者删除第i个元素，需要移动n - i个元素，每个位置插入或删除元素的可能性是相同的，也就是位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间那个元素的移动次数相等，为(n - 1)/ 2。 根据时间复杂度的推导，平均时间复杂度还是O(n)。 这说明说明？线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1)；而插入或删除时，时间复杂度都是O(n)。这就说明，它比较适合元素个数不太变化，而更多是存取数据的应用。 4.线性表顺序存储结构的优缺点优点①无须为表中元素之间的逻辑关系而增加额外的存储空间 ②可以快速地存取表中任一位置的元素 缺点 ①插入和删除需要移动大量元素 ②当线性表长度变化较大时，难以确定存储空间的容量 ③造成存储空间的“碎片” 五、线性表的链式存储结构1.线性表链式存储结构定义线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些元素可以存在内存未被占用的任意位置。 以前在顺序结构中，每个元素数据只需要存储数据元素信息就可以了。现在在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。 因此，为了表示每个数据元素ai与其直接后级元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)。 n个结点(ai的存储映像)链结成一个链表，即为线性表(a1,a2,….,an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。 对于线性表来说，总得有个头有个尾，链表也不例外。我们把链表中第一个结点的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。 最后一个，当然意味着直接后继不存在了，所以我们规定，线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示）。 有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。 2.头指针与头结点的异同头指针与头结点的异同点。 头指针 ① 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 ②头指针具有标识作用，所以常用头指针冠以链表的名字 ③无论链表是否为空，头指针均不为空。头指针是链表的必要元素。 头结点 ①头结点是为了操作的统一和方便而设立的，放在第一元素的结点之间，其数据域一般无意义。 ②有了头结点，对在第一元素结点前插入结点，其操作与其它结点的操作就统一了。 ③头结点不一定是链表必须要素。 3.线性链表式存储结构代码描述若线性链表为空表，则头结点的指针域为“空”。 单链表中，我们在C语言中可用结构指针来描述。1234567//线性表的单链表存储结构typedef struct Node&#123; ElemType data; struct Node *next;&#125;Node;typedef struct Node *LinkList;//定义LinkList 在这个结构定义中，我们也就知道，结点由存放数据元素的数据域和存放后继结点地址的指针域组成。 假设p是指向线性表第i个元素的指针，则该结点ai的数据域我们可以用p-&gt;data来表示，p-&gt;data的值是一个数据元素，结点ai的指针可以用p-&gt;next来表示，p-&gt;next的值是一个指针。p-&gt;next指向谁呢？当然是指向第i + 1个元素，即指向ai+1。也就是说p-&gt;data = ai，那么p-&gt;next-&gt;data=ai+1 六、单链表的读取在线性表的顺序存储结构中，我们要计算任意一个元素的存储位置使很容易的。但在单链表中，由于第i个元素到底在哪？没办法一开始就知道，必须从头开始找。因此，对于单链表实现获取第i个元素的操作GetElem，在算法上，相对麻烦一些。 获得链表第i个数据的算法思路： 声明一个指针p指向链表第一个结点，初始化j从1开始。 当j &lt; i 时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1; 若链表末尾p为空，则说明第i个结点不存在； 否则查找成功，返回结点p的数据。 实现代码如下：123456789101112131415161718//初始条件:顺序线性表L已存在,1 ≤ i ≤ ListLength(L)//操作结果:用e返回L中第i个数据元素的值Status GetElem(LinkList L,int i,ElemType *e)&#123; int j; LinkList p;//声明一指针 p = L-&gt;next;//让p指向链表L的第一个结点 j = 1;//j为计数器 while(p &amp;&amp; j &lt; i)//p不为空且计数器j还没有等于i时，循环继续 &#123; p = p-&gt;next;//让p指向下也结点 ++j; &#125; if(p || j &gt; i) return ERROR;//第i个结点不存在 *e = p-&gt;data;//取第i个结点的数据 return OK;&#125; 说白了，就是从头开始找，直到第i个结点为止。由于这个算法复杂度取决于i的位置，当i = 1时，不需要变量，而当i = n时则遍历n - 1次才可以。因此最坏情况的时间复杂度是O(n)。 由于单链表的结构没有定义表长，所以不知道事先循环多少次，因此也就不方便使用for来控制循环。其主要核心思想是“工作指针后移”，这其实也是很多算法常用技术。 八、单链表的插入与删除1.单链表的插入假设存储元素e的结点为s，要实现结点p、p-&gt;next和s之间的逻辑关系的变化，只需要将s插到结点p和p-&gt;next之间即可。 根本不需要惊动其他结点，只需要让s-&gt;next和p-&gt;next的指针做一点改变。123//下面两句不可交换顺序s-&gt;next = p-&gt;next;p-&gt;next = s; 单链表第i个数据插入结点的算法思路： 声明一指针p指向链表头结点，初始化j从1开始; 当j &lt; i时，就遍历链表，让p的指针向后移动，不断指向下一结点,j累加1 若到链表末尾p为空，则说明第i个结点不存在; 若查找成功，在系统中生成一个空节点s； 将数据元素e赋给s-&gt;data； 单链表的插入标准语句s-&gt;next = p-&gt;next; p-&gt;next = s; 返回成功 实现代码算法如下：12345678910111213141516171819202122//初始条件:顺序线性表L已存在,1≤i≤ListLength(L)//操作结果:在L中第i个结点位置之前插入新的数据元素,L的长度加1Status ListInsert(LinkList *L , int i , ElemType e)&#123; int j = 1; LinkList p,s; p = *L; while( p &amp;&amp; j &lt; i) //寻找第i个结点 &#123; p = p-&gt;next; ++j; &#125; if( !p || j &gt; 1) &#123; return ERROR;//第i个结点不存在 &#125; s = (LinkList)malloc(sizeof(Node));//生成新结点 s-&gt;data = e; s-&gt;next = p-&gt;next;//将p的后继结点赋值给s的后继 p-&gt;next = s;//将s赋给p的后继 return OK;&#125; 在这段算法代码中，我们用到了C语言的malloc标准函数，它的作用就是生成一个新的结点，其类型与Node是一样的，其实质就是在内存中开辟了一段空间，用了存放数据e的s结点。 2.单链表的删除现在我们再来看单链表的删除。设存储元素ai的结点为q，要实现将结点q删除单链表的操作，其实就是将它的前继结点的指针绕过，指向他的后继结点即可。 我们所要做的，实际上就是一步，p-&gt;next = p-&gt;next-&gt;next;，用q来取代p-&gt;next即是：12q = p-&gt;next;p-&gt;next = q-&gt;next; 也就是说把p的后继结点改成p的后继的后继结点。 单链表第i个数据删除结点的算法思路： 声明一指针p指向链表头指针，初始化j从1开始； 当j &lt; i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，i累加1； 若到链表末尾p为空，则说明第i个结点不存在； 否则查找成功，将欲删除的结点p-&gt;next 赋给q； 单链表的删除标准与p-&gt;next = q-&gt;next； 将q结点中的数据赋给e，作为返回; 释放q结点 返回成功 实现代码算法如下：123456789101112131415161718192021//初始条件:顺序线性表L已存在,1≤ i ≤ListLength(L)//操作结果:删除L的i个结点,并用e返回其值,L的长度减1Status ListDelete(LinkList *L,int i,ElemType *e)&#123; int j; Link p,q; p = *L; j = 1; while(p-&gt;next &amp;&amp; j &lt; i)//遍历寻找第i - 1个结点 &#123; p = p-&gt;next; ++j; &#125; if( !(p-&gt;next) || j &gt; i) return ERROR;//第i个结点不存在 q = p-&gt;next; p-&gt;next = q-&gt;next;//将q的后继赋给p的后继 *e = q-&gt;data;//将q结点中的数据给e free(q);//让系统回收此结点，释放内存 return OK;&#125; 分析一下刚才我们讲解的单链表插入和删除算法，我们发现，它们其实都是由两部分组成：第一部分就是遍历查找第i个结点；第二部分就是插入和删除结点。 从整个算法来说，我们很容易推导出：它们的时间复杂度都是O(n)。 如果我们不知道第i个结点的指针位置，单链表数据结构在插入和删除操作上，与线下顺序存储结构是没有太大优势的。但如果，我们希望从第i个位置，插入10个结点，对于顺序结构意味着，每次都要移动n - i个结点，每次都是O(n)。而单链表，我们只需在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，事件复杂度为O(1)。 显然，对于插入和删除数据越频繁的操作，单链表的优势就越明显。 八、单链表的整表创建顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。而单链表和顺序存储结构就不一样，它不像顺序存储结构这么几种，它可以很散，是一种动态结构。对于每个链表来说，它所占用空间的大小和位置使不需要预先分配划定的，可以根据系统的情况和实际的需求即可生成。 所以创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，一次建立各元素结点，并逐个插入链表。单链表整表创建的思路算法： 声明一指针p和计数器变量1；初始化一空链表；让L的头结点的指针指向NULL，即建立一个带头结点的单链表；循环： 生成一新结点赋值给p; 随机生成一数字赋给p的数据域p-&gt;data; 将p插到头结点与前一个新节点之间的位置。 实现代码如下：12345678910111213141516//随机产生n个元素的值，建立带表头结点的单链表线性表L(头插法)void CreateListHead(LinkList *L,int n)&#123; LinkList p; int i; srand(time(0));//初始化随机数种子 *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL;//先建立一个带头结点的单链表 for(i = 0;i &lt; n;i++) &#123; p = (LinkList)malloc(sizoef(Node));//生成新的结点 p-&gt;data = rand() % 100 + 1;//随机生成100以内的数字 p-&gt;next = (*L)-&gt;next; (*L)-&gt;next = p; //插入到表头 &#125;&#125; 这段代码里，我们始终让新结点在第一的位置上，我们把这种算法简称为头插法。 可事实上，我们还可以把新结点放在最后。这才是排队时的正常思维。我们每次新结点都插在终端结点的后面，这种算法称之为尾插。 实现代码算法如下：1234567891011121314151617//随机产生n个元素的值,建立带表头结点的单链线性表L(尾插法)void CreateListTail(LinkList *L,int n)&#123; LinkList p,r; int i; srand(time(0));//初始化随机数种子 *L = (LinkList)malloc(sizeof(Node));//为整个线性表 r = *L;//r为指向尾部的结点 for(i = 0;i &lt; n;i++) &#123; p = (Node *)malloc(sizeof(Node));//生成新结点 p-&gt;data = rand() % 100 + 1;//随机生成100以内的数字 r-&gt;next = p;//将表尾终端结点的指针指向新结点 r = p; //就那个当前新结点定义为表尾终端结点 &#125; r-&gt;next = NULL;//表示当前链表结束&#125; 注意L与r的关系，L指整个单链表，而r指向尾节点的变量，r会随着循环不断地变化结点，而L则是随着循环增长为一个多结点的链表。 这里需要解释一下，r-&gt;next = p的意思，其实就是将刚才的表尾终端结点r的指针指向新结点p。 九、单链表的整表删除当我们不打算使用这个单链表时，我们需要把它销毁，其实也就是在内存中将它释放掉，以便于留出空间给其他程序或软件使用。 单链表整表删除的算法思路如下： 声明一结点p和q； 将第一个结点赋值给p； 循环 将下一结点赋值给q; 释放p; 将q赋值给p。 实现代码算法如下:1234567891011121314//初始条件:顺序线性表L已经存在，操作结果：将L重置为空表Status ClearList(LinkList *L)&#123; LinkList p,q; p = (*L)-&gt;next;//p指向第一个结点 while(p)//没到表尾 &#123; q = p-&gt;next; free(p); p = q; &#125; (*L)-&gt;next = NULL;//头结点指针域为空 return OK;&#125; 十、单链表结构与顺序存储结构优缺点简单地对单链表结构和顺序存储结构作对比。 1、存储分配方式： 顺序存储结构有一段连续的存储单元依然存储线性表的数据元素。 单链表采用链式存储结构，用一组任意的存储单元存放线性表的玩意。 2、时间性能：查找： 顺序存储结构O(1) 单链表O(n) 插入与删除 顺序存储结构需要平均移动表长一半的元素，时间为O(n) 单链表在线出某位置的指针后，插入和删除时间仅为O(1) 3、空间性能 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢。 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。 通过上面的对比，我们可以得出一些经验性的结论： ① 若线性表需要频繁查找，很少进入插入和删除操作时，宜采用顺序存储结构。 若需要频繁插入和删除时，宜采用单链表结构。 比如游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况下都是读取，所以应该考虑用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家游戏过程中，可能随时增加或删除，此时应该用单链表比较合适。当然，这只是简单地类比。现实生活中的软件开发，要考虑的问题会复杂得多。 ②当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不用考虑存储空间大小问题。而如果事先知道线性表的大致长度，比如一年12个月，这种用顺序存储结构效率会高很多。 总之，线性表的顺序存储结构和单链表结构各有其优点，不是简单地说哪个不好，需要根据实际情况，来综合平衡采用哪种数据更能满足和达到需求和性能。 十一、静态链表C语言具有指针能力，使得它可以非常容易地操作内存中的地址和数据，这比其他高级语言更加方便灵活。 后来的面向对象语言，如Java、C#等，虽不使用指针，但因为启用了对象引用机制，从某种角度上也间接实现了指针的某些作用。但对于一些语言，如Basic、Fortran等早期的编程高级语言，由于没有指针，链表结构就没办法实现。 有人想出用数组来代替指针，来描述链表。 首先我们用数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下表都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素后继在数组中的下表，我们把cur叫做游标。 我们把这种用数组描述的链表叫静态链表，这种描述方法还有起名叫做游标实现法。 为了我们方便插入数据，我们通常会把数组建立得大一些，以便有一些空闲空间可以方便插入不至于溢出。1234567//线性表的静态链表存储结构#define MAXSIZE 1000//假设链表的最大长度1000typedef struct&#123; ElemType data; int cur;//游标(Cursor),为0时表示无指向&#125;Component,StaticLinkList[MAXSIZE]; 另外我们对数组的第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下表;而数组的最后一个元素的cur则存放第一个有数值的元素的下表，相当于单链表中的头结点作用，当整个链表为空时，则为0²。12345678910//将一维数组space中个分量链成一备用链表//space[0].cur为头指针，"0"表示空指针Status InitList(StaticLinkList space)&#123; int i; for(i = 0;i &lt; MAXSIZE - 1;i++) space[i].cur = i + 1; space[MAXSIZE - 1].cur = 0;//目前静态链表为空 return OK;&#125; 1.静态链表的插入操作静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，不需要时释放。 我们前面说过，在动态链表中，结点的申请和释放分别借用malloc()和free()两个函数来实现。在静态链表中，操作的是数组，不存在像动态链表一样的申请和释放问题，所以我们需要自己实现这两个函数。 为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的以及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可从备用链表上取得第一个结点作为待插入的新结点。1234567891011//若备用空间链表为空，则返回分配的结点下表，否则返回0int Malloc_SLL(StaticLinkList space)&#123; int i = space[0].cur;//当前数组的第一个元素的Cur存的值 if(space[0].cur) &#123; space[0].cur = space[i].cur;//由于要拿出一个分量来使用 //所以我们,就得把它的下一个分量用作备用 &#125; return i;&#125; 插入元素123456789101112131415161718192021//在L中第i个元素之前插入新的数据元素eStatus ListInsert(StaticLinkList L, int i,ElemType e)&#123; int j,k,l; k = MAX_SIZE - 1;//注意k首先是最后一个元素的下表 if(i &lt; 1 || i &gt; ListLength(L) + 1) return ERROR; j = Malloc_SSL(L);//获得空闲分量的下标 if(j) &#123; L(j).data = e;//将数据赋值给此分量的下表 for(l = 1;l &lt;= i - 1;l++)//相当于循环链表，找到第i-1位 &#123; k = L[k].cur; &#125; L[j].cur = L[k].cur;//新的第i个元素元素指向原本第i个元素 L[k].cur = j;//第i - 1个元素指向新的第i个元素 return OK; &#125; return ERROR;&#125; 就这样，我们实现了在数组中，实现不移动元素，却插入了数据的操作。 2.静态链表的删除操作和前面一样，删除元素时，原来是需要释放结点的函数free()。我们也要自己实现它。123456789101112131415//删除在L中第i个数据元素eStatus ListDelete(StaticLinkList L,int i)&#123; int j , k; if(i &lt; 1 || i &gt; ListLength(L)) return ERROR; k = MAX_SIZE - 1; for(j = 1;j &lt; = i - 1;j++)//相当于遍历链表 &#123; k = L[k].cur; &#125; j = L[k].cur;//把要删除的数组下标赋值给j Free_SLL(L,j);//调用删除函数 return OK;&#125; 123456//将下表为k的空闲结点回收到备用链表void Free_SSL(StaticLinkList space,int k)&#123; space[k] = space[0].cur;//把原来第一位指向的下标赋给新第一位 space[0].cur = k;//要删除的分量赋给第一个元素cur&#125; 静态链表也就是相应其他操作的相关实现。比如ListLength12345678910111213//初始条件:静态链表L已存在。操作结果:返回L中数据元素个数int ListLength(StaticLinkList L)&#123; int j = 0; int i = L[MAXSIZE - 1].cur; while(i) &#123; i = L[i].cur; j++; &#125; return j;&#125;1 3.静态链表优缺点优点：在插入和删除操作时，只要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。 缺点：①没有解决连续存储分配带来表长难以确定的问题 ②失去了顺序存储结构随机存储的特性 十二、循环链表对于单个链表，由于每个结点只存储了向后的指针，到了尾标志就停止了向后链的操作，这样当中某一结点就无法找到它的前驱结点了。 将单链表中终端结点的指针由空指针改为指向头结点，就使整个单链表形成一个环， 这种头尾相接的单链表称为单循环链表，简称循环链表。 循环链表解决了一个很麻烦的问题，如何从当中一个结点出发，访问到链表的全部结点。 循环链表和单链表的主要差异就是在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束。 十三、双向链表在单链表中，有了next指针，这就使得我们要查找下一结点的事件复杂度为O(1)。可是如果我们要查找的是上一节点的话，那最坏的时间复杂度就是O(n)了，因为我们每次都要从头开始遍历寻找。 为了克服单向性这一缺点，设计出了双向链表。双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，一个指向直接前驱。1234567//线性表的双向链表存储结构typedef struct DulNode&#123; ElemType data; struct DuLNode *prior;//直接前驱指针 struct DuLNode *next;//直接后继指针&#125;DulNode,*DuLinkList; 既然单链表可以有循环，那么双向链表当然可以是循环表。 由于是双向链表，对于链表中某一结点p，它的后继的前驱是它自己。它的前驱的后继自然也是它自己。即：1p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next 插入操作时，其实并不复杂，但是顺序很重要。 假设存储元素e的结点为s，要实现将结点s插入到p和p-&gt;next之间需要下面几部。1234s-&gt;prior = p;//把p赋给s的前驱s-&gt;next = p-&gt;next;//把p-&gt;next赋给s的后继p-&gt;next-&gt;prior = s;//把s赋给p-&gt;next的前驱p-&gt;next = s;//把s赋给p的后继 如要删除结点p，只要下面两步骤。123p-&gt;prior-&gt;next = p-&gt;next;//把p-&gt;next赋给p-&gt;prior的后继p-&gt;next-&gt;prior = p-&gt;prior;//把p-&gt;proir赋给p-&gt;next的前驱free(p);//释放p的空间 双向链表对于单链表来说，要更复杂一些，对于插入和删除时，需要小心。 另外由于它每个结点需要几轮两份指针，所以在空间上是要占用略多一些的。不过由于良好的对称性，使得对某个结点的前后结点的操作，带来了方便，可以有效提高算法的时间性能。 说白了，也就是空间换时间。]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法时间复杂度和空间复杂度计算]]></title>
    <url>%2Fyear%2F03%2F18%2F11332%2F</url>
    <content type="text"><![CDATA[通常，对于一个给定的算法，我们要做 两项分析。第一是从数学上证明算法的正确性，这一步主要用到形式化证明的方法及相关推理模式，如循环不变式、数学归纳法等。而在证明算法是正确的基础上，第二步就是分析算法的时间复杂度。算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。因此，作为程序员，掌握基本的算法时间复杂度分析方法是很有必要的。 算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。而度量一个程序的执行时间通常有两种方法。 一、事后统计的方法 这种方法可行，但不是一个好的方法。该方法有两个缺陷：一是要想对设计的算法的运行性能进行评测，必须先依据算法编制相应的程序并实际运行；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优势。 二、事前分析估算的方法 因事后统计方法更多的依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优劣。因此人们常常采用事前分析估算的方法。 在编写程序前，依据统计方法对算法进行估算。一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素： 1.算法采用的策略、方法；2.编译产生的代码质量； 问题的输入规模； 机器执行指令的速度。 一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。为了便于比较同一个问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。 1、时间复杂度（1）时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。（2）时间复杂度 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 另外，上面公式中用到的 Landau符号其实是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界。在计算算法复杂度时一般只用到大O符号，Landau符号体系中的小o符号、Θ符号等等比较不常用。这里的O，最初是用大写希腊字母，但现在都用大写英语字母O；小o符号也是用小写英语字母o，Θ符号则维持大写希腊字母Θ。 T (n) = Ο(f (n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 T (n) ≤ C f(n)。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时T (n)的上界是C f(n)。其虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。例如，O(2n2+n +1) = O (3n2+n+3) = O (7n2 + n) = O ( n2 ) ，一般都只用O(n2)表示就可以了。注意到大O符号里隐藏着一个常数C，所以f(n)里一般不加系数。如果把T(n)当做一棵树，那么O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。 在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 从图中可见，我们应该尽可能选用多项式阶O(nk)的算法，而不希望用指数阶的算法。 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!) 一般情况下，对一个问题（或一类算法）只需选择一种基本操作来讨论算法的时间复杂度即可，有时也需要同时考虑几种基本操作，甚至可以对不同的操作赋予不同的权值，以反映执行不同操作所需的相对时间，这种做法便于综合比较解决同一问题的两种完全不同的算法。 （3）求解算法的时间复杂度的具体步骤是： ⑴ 找出算法中的基本语句； 算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。 ⑵ 计算基本语句的执行次数的数量级； 只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。 ⑶ 用大Ο记号表示算法的时间性能。 将基本语句执行次数的数量级放入大Ο记号中。 如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：123456[java] view plain copyfor (i=1; i&lt;=n; i++) x++; for (i=1; i&lt;=n; i++) for (j=1; j&lt;=n; j++) x++; 第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。 Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为P（Polynomial,多项式）类问题，而把后者（即指数时间复杂度的算法）称为NP（Non-Deterministic Polynomial, 非确定多项式）问题。 一般来说多项式级的复杂度是可以接受的，很多问题都有多项式级的解——也就是说，这样的问题，对于一个规模是n的输入，在n^k的时间内得到结果，称为P问题。有些问题要复杂些，没有多项式时间的解，但是可以在多项式时间里验证某个猜测是不是正确。比如问4294967297是不是质数？如果要直接入手的话，那么要把小于4294967297的平方根的所有素数都拿出来，看看能不能整除。还好欧拉告诉我们，这个数等于641和6700417的乘积，不是素数，很好验证的，顺便麻烦转告费马他的猜想不成立。大数分解、Hamilton回路之类的问题，都是可以多项式时间内验证一个“解”是否正确，这类问题叫做NP问题。 （4）在计算算法时间复杂度时有以下几个简单的程序分析法则:(1).对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间 (2).对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下”求和法则” 求和法则:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n))) 特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n)) (3).对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间 (4).对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下”乘法法则” 乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1T2=O(f(n)g(n)) (5).对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度 另外还有以下2个运算法则:(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；(2) O(Cf(n)) = O(f(n)),其中C是一个正常数 （5）下面分别对几个常见的时间复杂度进行示例说明：(1)、O(1) Temp=i; i=j; j=temp; 以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 (2)、O(n2) 2.1. 交换i和j的内容12345[java] view plain copysum=0； （一次） for(i=1;i&lt;=n;i++) （n+1次） for(j=1;j&lt;=n;j++) （n2次） sum++； （n2次） 解：因为Θ(2n2+n+1)=n2（Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(n2)； 2.2.1234567[java] view plain copyfor (i=1;i&lt;n;i++) &#123; y=y+1; ① for (j=0;j&lt;=(2*n);j++) x++; ② &#125; 解： 语句1的频度是n-1 语句2的频度是(n-1)*(2n+1)=2n2-n-1 f(n)=2n2-n-1+(n-1)=2n2-2； 又Θ(2n2-2)=n2 该程序的时间复杂度T(n)=O(n2). 一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 (3)、O(n)123456789[java] view plain copya=0; b=1; ① for (i=1;i&lt;=n;i++) ② &#123; s=a+b; ③ b=a; ④ a=s; ⑤ &#125; 解： 语句1的频度：2, 语句2的频度： n, 语句3的频度： n-1, 语句4的频度：n-1, 语句5的频度：n-1, T(n)=2+n+3(n-1)=4n-1=O(n).(4)、O(log2n)1234[java] view plain copyi=1; ① hile (i&lt;=n) i=i*2; ② 解： 语句1的频度是1, 设语句2的频度是f(n), 则：2^f(n)&lt;=n;f(n)&lt;=log2n 取最大值f(n)=log2n, T(n)=O(log2n ) (5)、O(n3)123456789[java] view plain copyfor(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;i;j++) &#123; for(k=0;k&lt;j;k++) x=x+2; &#125; &#125; 解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,…,m-1 , 所以这里最内循环共进行了0+1+…+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+…+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n3). （5）常用的算法的时间复杂度和空间复杂度 一个经验规则：其中c是一个常量，如果一个算法的复杂度为c 、 log2n 、n 、 n*log2n ,那么这个算法时间效率比较高 ，如果是2n ,3n ,n!，那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意。 算法时间复杂度分析是一个很重要的问题，任何一个程序员都应该熟练掌握其概念和基本方法，而且要善于从数学层面上探寻其本质，才能准确理解其内涵。 2、算法的空间复杂度 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\”进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。 如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构笔记]]></title>
    <url>%2Fyear%2F03%2F17%2F28074%2F</url>
    <content type="text"><![CDATA[基本概念和术语数据：是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。数据元素：是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。数据项：是组成数据元素的、有独立含义的、不可分割的最小单位。数据对象：是性质相同的数据元素的集合，是数据的一个子集。 数据结构数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括逻辑结构和存储结构两个层次。逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。存储结构： 数据对象在计算机中的存储表示称为数据的存储结构，也称为物理结构。把数据对象存储到计算机时，通常要求既要存储各数据元素的数据，又要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。数据元素在计算机中有两种基本的存储结构，分别是顺序存储结构和链式存储结构。顺序存储结构是借助元素在存储器中的相对位置来 表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。链式存储结构：顺序存储结构要求所有的元素依次存放在一片连续的存储空间中，而链式存储结构，无需占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。所以链式存储结构通常借助于程序设计语言的指针类型来描述。 数据类型和抽象数据类型数据类型是一个值的集合和定义在这个值集上的一组操作的总称。抽象数据类型一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合。抽象数据类型的概念与面向对象方法的思想是一致的。抽象数据类型独立于具体实现，将数据和操作封装在一起，使得用户程序只能通过抽象数据类型定义的某些操作来访问其中的数据，从而实现了信息隐藏。抽象数据类型相当于在概念层上描述问题，而类相当于在实现层上描述问题。 算法和算法分析算法(Algorithm)是为了解决某些问题而规定的一个有限长的操作序列。一个算法必须满足以下五个重要特性：1.有穷性。2.确定性。3.可行性。4.输入。5.输出。一个算法的优劣应该从以下几方面来评价：1.正确性。2.可读性。3.健壮性。4.高校性。算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，以考察算法的时间和空间效率。一般情况下，鉴于运算空间较为充足，故将算法的时间复杂度作为分析的重点。算法执行时间的数量级称为算法的渐进时间复杂度，T(n)=O(f(n)),它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，简称时间复杂度。 线性表线性表的定义和特点由n(n&gt;=0)个数据特性相同的元素构成的有限序列称为线性表。线性表中元素的个数n(n&gt;=0)定义为线性表的长度，n=0时称为空表。对于非空的线性表或线性结构，其特点是：1.存在唯一的一个被称作“第一个”的数据元素。2.存在唯一的一个被称作“最后一个”的数据元素。3.除第一个之外，结构中的每个数据元素均只有一个前驱。4.除最后一个之外，结构中的每个数据元素均只有一个后继。 线性表的类型定义1234567891011121314151617181920ADT List&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2...,n.n&gt;=0&#125; 数据关系: R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 基本操作: InitList(&amp;L) 操作结果:构造一个空的线性表L。 DestroyList(&amp;L) 初始条件：线性表L已存在。 操作结果：销毁线性表L。 ClearList(&amp;L) ListEmpty(L) ListLength(L) GetElem(L,i,&amp;e) LocateElem(L,e) PriorElem(L,cur_e,&amp;pre_e) NestElem(L,cur_e,&amp;next_e) ListInsert(&amp;L,i,e) ListDelete(&amp;L,i) TraverseList(L) &#125;ADT List 线性表的顺序表示和实现线性表的顺序存储表示线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常称这种顺序存储结构的线性表为顺序表。其特点是，逻辑上相邻的数据元素，其物理次序也是相邻的。]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安装TomCat学习JSP]]></title>
    <url>%2Fyear%2F03%2F17%2F33888%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;这学期开了JSP应用教程，昨天上课时需要安装TomCat，但大家安装的都不是很顺利，安装后也会有各种问题，我就帮大家解决了各种问题，在这里记录一下，以后有同学需要的时候可以看一下。 安装JDK，配置java环境JSP，全称Java Server Page ，所以肯定需要Java环境。我安装的是1.8.0_161，不推荐安装最新版的9.0。Linux系统安装JDK可以参考我之前这篇文章，点这里。Windows系统，我习惯安装在C:\Java,默认安装在C:\Program Files\Java,安装在哪里都行，然后一路默认下去，等待安装结束。然后就是配置Java环境。 右击我的电脑属性，高级系统设置，环境变量，点系统变量的新建， 变量名：JAVA_HOME 变量值：是你安装的路径，我的是C:\Java\jdk1.8.0_161,默认的话是 C:\ProgramFiles\Java\jdk1.8.0_161,你可以点击 浏览目录选择。 再修改path 变量，win7可以直接在最前面加上， %JAVA_HOME%\bin;注意在英文输入法下输;,win10需要点新建 ，值也是%JAVA_HOME%\bin;，然后点击上移到第一个，确定。 再新建 classpath ,变量值为.\;%JAVA_HOME%\lib\tiils.jar 然后就确定、确定、确定。 打开cmd,分别输入java、javac 看是不是分别输出一大长串东西，是的话就是安装好了，如果提示不是内部命令，那就检查一下是不是分号在中文输入法下输入的，win10的path可能会默认加上“ ;”,有的话就删掉。 这样的话就能配置好Java环境了。 安装TomCat 下载TomCat 下载好后一路点下去就能安装好了。 如果你下载的有两个或以上Java版本，在选择Java地址是一定选择你现在配置的那个版本地址，不然会出错。 打开TomCat，在浏览器输入 127.0.0.1:8080 出现TomCat的相关页面就安装好了。 如果操作没有问题，Java路径也没问题，那就卸载后重新装一下。 Linux环境下，创建TomCat文件夹，解压，命令行 12$ cd TomCat/apache-tomcat-8.5.29/bin/$ ./startup.sh 就可以运行 使用时的问题TomCat默认安装在 C:\Program Files\Apache Software Foundation下,找到webapps\Root,这是TomCat的Web服务器的根目录，在里面新建JSP文件，就可以在浏览器中运行了。但win10下你肯定会发现无法将JSP文件保存在这个目录下，就算保存下来也是TXT格式，不是JSP格式，这是因为win10为了安装问题，默认不能通过修改文件后缀名来修改文件格式，解决这个问题可以将下图中的文件扩展名打上勾。然后就解决了。如果运行时再提示有问题，那就是你输入格式的错误了，看是不是空格多打或少打了，或者大小写弄错了，自己琢磨一下就能解决了。 有问题的直接评论问我，或者给我发邮件。大早上起床写教程，好累啊。]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
      <tags>
        <tag>TomCat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Looking up at the stars]]></title>
    <url>%2Fyear%2F03%2F14%2F29068%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vim精简版教程]]></title>
    <url>%2Fyear%2F03%2F13%2F12935%2F</url>
    <content type="text"><![CDATA[编辑器的分类 文本编辑器，ASCII码 字处理器：word全称 vi：Visual interface vim: Visual interface improved分类 全屏编辑器, vimEmacsnotepad++… 模式编辑器 grepsedawk vim模式：1.编辑模式（命令模式）2.输入模式3.末行模式4.可视化模式（块）默认处于编辑模式模式转换编辑模式（命令模式） —&gt;&gt;输入模式i：在当前光标所在字符的的前面，转换为输入 a：在当前光标所在字符的的后面，转换为输入 o:在当前光标所在字符的行下方，新建一行，并转为输入模式。 I:在当前光标所在行的行首，转为输入模式 A:在当前光标所在行的行尾，转为输入模式 O:在当前光标所在行的上方，新建一行，并转为输入模式。输入模式—&gt;编辑模式（命令模式)ESC键编辑模式（命令模式）—-&gt;&gt;末行模式:10d10,20dset nu!ls /etc末行模式—-&gt;&gt; 编辑模式（命令模式）ESC ESC键一.打开文件：vim filenamevim /path/to/somefilevim +12 file ：打开文件，光标在12行vim +# file :打开文件，光标在N行vim + file：打开文件，光标在最后一行。vim +/pattern file ：打开文件，光标在第一个匹配的行首二.关闭文件：1.末行模式关闭文件:q 退出:q!:wq 保存退出；w 保存：w! 强制保存:wq –&gt; :x 2.编辑模式（命令模式）ZZ:保存退出 三.移动光标（编辑模式）1.逐字符移动： h:向右 j:向下 k:向上 l:向左 数字h 5h：向右移动5个字符 2.逐个单词移动 w:移动到下一个单词词首 e：跳到当前单词或下一单词的词尾 b：跳到当前单词或前一单词的词首 #w：一次跳n个单词。 4b: 行内跳转0：跳到行首(绝对行首)^:行首的第一个非空白字符$:绝对行尾4.行间跳转#G：跳转到n行G：最后一行GG：第一行 末行模式 ：# 移动到n行 四、翻屏编辑模式（命令模式）f： 向后翻一屏、CTRL+b:向上翻一屏 Ctrl+d： 向下翻半屏Ctrl+u:向上翻半屏 五、删除单个字符x：删除光标所在处的单个字符 #x:删除光标所在处及向后n个字符 六、删除命令：dd命令跟跳转命令组合使用dw：3dw： #de，#dbdd：删除当前光标所在行 #dd：删除当前光标所在行及下面共#行 末行模式下startadd，Endaddd1,8d.,5+d.:表示当前行$:表示最后一行+#：向下#行1,$-3d: 最后一次删除的内容，可以粘贴到别处 七、粘贴命令pp:如果删除或复制为整行内容，则粘贴至光标所在行的下方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的后面；P:如果删除或复制为整行内容，则粘贴至光标所在行的上方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的前面； 八、复制命令 yyy：一行 #y： 九、先删除内容，在转换为输入模式(修改)c：同d命令c$:cc:5C: 十、替换r:替换单个字符R：进入替换模式 十一、撤销编辑操作：u:撤销前一次的操作： 连续u，撤销此前n次操作3u #u：撤销最近#次操作 十二、撤销上一次的撤销Ctrl+r恢复 十三、重复前一次编辑操作. 十四、可视化模式v：按字符选取V：按矩形选取Ctrl+v: 十五、查找/pattern?patternnN 十六、查找并替换在末行模式下 用法和sed一样 address1，address2s/pattern/string/gi 1，$ %:表示全文。 十七、打开多个文件vim file1 file2;next 切换至下一个文件：prev 切换至前一个文件：last 切换至最后一个文件：first 切换最前面的一个文件退出：qall 全部退出 十八：分屏显示一个文件ctrl+w ,s:水平分割窗口ctrl+w,v:垂直分割窗口 在窗口间切换光标Ctrl+w，ARRON ：qa 关闭所有窗口 十九、分窗口多个文件vim -o file1 file2 file3 ..水平分割窗口vim -O file1 file3 …. 垂直分割窗口 二十、将当前文件部分内容另存为另一文件末行模式下使用w命令：w：add1,addr2w /path/to/somewhere 二十一、将另一个文件的内容填充在当前文件中：r /path/to/somefile 二十二、跟shell交互：!command 二十三、高级话题1.显示或取消行号：set numberset nu：set nonu2、显示忽略大小写或区分大小写set ignorecaseset ic:set noignorecase:set noic3.设定自动缩进：set autoindent:set noai 4.查找的文本高亮显示或取消：set hlsearch:set nohlsearch 5.语法高亮:syntax on:syntax off 二十四、配置文件/etc/vimrc~/.vimrc(家目录下) 二十五、练习vim的小游戏vimtutorvim -r file总结以上都是我大学的时候，学习的笔记，无意间看到了，发现很多东西都忘记了，现在准备复习一下，分享在这里。下面赠送一个安装vim插件的命令。神器： wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[青春，呼啸而过]]></title>
    <url>%2Fyear%2F03%2F12%2F27979%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; &nbsp;&nbsp;今天不经意间又翻到这篇文章，第一次读是在初三吧，那时候就特别有感触，可能是因为也同样有过这样相似的经历吧。原来的那些人，早已物是人非。 &nbsp;&nbsp; &nbsp;&nbsp; 在教室里我们习惯往窗外看，有一只鸟，从这棵树飞向另一棵树，它自由地去喉叫属于它自己的青春，这些都是窗子内的我最羡慕的事。 —-题记 &nbsp;&nbsp; &nbsp;&nbsp;高四开学的第一个傍晚，原本想放弃一切安心学习的我受不了同学的诱惑而跟他们去踢球。我不知道在这种特殊的时期下踢球是不是一种错误，或许我们选择的是一份自由，而在那次球赛上我认识了他—-老鸟。 &nbsp;&nbsp; &nbsp;&nbsp;我一个“踩单车”便轻松摆脱了老鸟的堵截，一脚抽射，球轻而易举地进了球门外的臭水沟。老鸟伸出姆指说“强”。我问老鸟为什么说我强，我并没有把球踢进去啊？老鸟说是看了我托着一双废品回收店里的托鞋还来踢球，真的是暴强。那天院长在我身边，我拿起他那只断了一半的托鞋扔向老鸟，怒喊道:我乐意。老鸟缩下头躲着，破口大骂，我不知道他骂什么，因为托鞋打到了他的嘴巴。 &nbsp;&nbsp; &nbsp;&nbsp; 院长挡在我们中间，我没跟老鸟打架。后来我跟老鸟还经常在足球场上交流，但彼此都很鄙视对方，直到高四上学期快结束的某一个晚上，我们几个人都没去上晚自习，踢完球后直接回宿舍洗澡间老鸟则跑到厕所里抽烟，我真的不明白老鸟为什么总躲在厕所里抽烟，随口问他难道单纯地只是不让老师看到吗。 &nbsp;&nbsp; &nbsp;&nbsp;最后老鸟才告诉我，别以为厕所是最臭、最恶心的地方，其实厕所是校园唯一安静的地方。这里不用去想那些矛盾的事情，而且可以把所有的烦恼都排泄到这里，静静地，一个人抽烟，人们总在这里留下什么，却又无法带走。 &nbsp;&nbsp; &nbsp;&nbsp;那晚，厕所里的灯光昏黄昏黄的，我也喜欢上了呆在厕所里抽烟。老鸟跟我说他除了足球也喜欢摇滚，喜欢汪峰，我没想到我可以和老鸟同穿一条裤子，更无法猜测喜欢摇滚的人的疯狂外表下其实是一颗坦诚的心。后来我跟老鸟唱完了汪峰的《笑着哭》后，老鸟头一次没装逼，对我说：我当你是兄弟…… &nbsp;&nbsp; &nbsp;&nbsp;有时候听着摇滚就会忘记老鸟的爱情悲剧史，醒来的时候模糊记得老鸟那个时候整天拿着我的《围城》，而且动不动就说：对丑女细看是种残忍。 &nbsp;&nbsp; &nbsp;&nbsp;“对丑女细看是种残忍”这句话的直接受害者就是我们的校花。老鸟每次见到她就损她几句，本以为校花会恨透老鸟，给我们这些渴望“脱光”者（摆脱光棍）一个机会，没想到那天我硬着头皮向老鸟要回《围城》的时候，老鸟竟公布校花成了他的女朋友。 &nbsp;&nbsp; &nbsp;&nbsp;我说，不会吧，你这屎克螂也有人要，快说，你是用多少金币收买人家的。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟说，有钱我就买泡面了，是她主动写情书给我的。这仿佛告诉我拉登就藏在他家一样。最后老鸟瞪了我一眼笑着说，随便玩玩而已，我不会动真格的，随后便去跟校花约会了。我骂道，你他妈的老鸟，你不要也不给我机会啊…… &nbsp;&nbsp; &nbsp;&nbsp;到了高四下学期，我跟老鸟算是成了真正的兄弟。除了足球、摇滚外，老鸟不断地向我炫耀他那无法验证的爱情史。 &nbsp;&nbsp; &nbsp;&nbsp;他时不时地叼着一支七匹狼的烟，看起来蛮帅的样子，随后他又开谈他跟校花过家家式的爱情剧，他总是说他毫不在意校花：“她的一举一动在我心里好像蜻蜓点水一样，即使泛起一丝波澜最后也归于平静。” &nbsp;&nbsp; &nbsp;&nbsp;可事实是：那天中午校花跑到男生宿舍哭，宿管人员十分无奈，找到老鸟并且对他说：“你拉屎还让我帮你擦屁股啊。”老鸟马上跑过来对我说，这搞的他十分惭愧，真想当场挖个洞把自己埋了。 &nbsp;&nbsp; &nbsp;&nbsp;爱情剧演到最后的时候，校花在班上号啕大哭，老鸟又坐到我旁边对我说：“我真的是无地自容，这真的是扒光我的衣服然后把我放到讲台上。” &nbsp;&nbsp; &nbsp;&nbsp;到了晚上，老鸟约大家去KTV，我们一如既往地点了摇滚歌曲《无地自容》，我不知道我们为什么老是点这首歌，我们这帮人还是老鸟、院长、俊、阿元、我，始终没变过，也没想过要变。 &nbsp;&nbsp; &nbsp;&nbsp;鬼哭狼嚎完后，老鸟说他们分手了。 &nbsp;&nbsp; &nbsp;&nbsp; 我说好啊，失恋也别太伤心，被抛弃后还是男人。 &nbsp;&nbsp; &nbsp;&nbsp; 老鸟没砍我，而是跟我拼酒。当然啦，我肯定敌不过她，不过喝到一半他就哭了，他不会转过头去，是那么坦然，任眼泪流淌。 &nbsp;&nbsp; &nbsp;&nbsp; 之后发生了什么我基本想不起来了，我模糊记得在宿舍里我吐得一塌糊涂时老鸟递给我毛巾和水。可从那以后，我们没再去那家菜给得不是很多的KTV，因为我们成长在这个残酷的时期。 &nbsp;&nbsp; &nbsp;&nbsp;高考结束后我们到离家很远的一个包装工厂里打工，之所以选择在这个破烂的地方是因为这里离家很远，远的忘记了高考。 &nbsp;&nbsp; &nbsp;&nbsp;还是原班人马，我们这几个曾经在晚自习上吼叫《无地自容》，每天踢球踢得很晚，跑回宿舍呆在厕所里抽烟的这帮家伙。但是这里我们告别了足球、告别了摇滚，因为我们已经经历了两次高考。 &nbsp;&nbsp; &nbsp;&nbsp; 单调而劳累的工作后，我们疲倦地躺在杂乱的宿舍里。老鸟说他真想K歌，他怀念高四的残忍与痛快。我看了他一眼，太多的心事其实不必说出口，因为我们彼此明白，我想老鸟是累了，不光是工作么累，每个高考失败的学子都会回想属于他的那一段忧伤，这里不曾有爱情，只有友谊与珍惜……我们轻轻地唱着汪峰的《美丽世界的孤儿》，我们都哭了，不知道为什么，可能我们早已被世人遗忘，只是这个美丽世界的孤儿。 &nbsp;&nbsp; &nbsp;&nbsp; 生活总是太无聊，特别是在这个高考后的日子里。但是老鸟还是会寻找属于自己的快乐，除了老鼠和蟑螂，包装厂里不缺的就是废纸和胶带，于是老鸟用胶带包起一大摞废纸便产生了世界上最原始的足球，而厂房便是我们的足球场，任何时候都是比赛时间，这些仅仅是老鸟和我遗忘世界的方式。 &nbsp;&nbsp; &nbsp;&nbsp;不过这个伟大的发明在工厂里的玻璃碎后被老板扼杀了，老鸟并没有生气，如果在以往他肯定会跟老板大干一场，可是今天他只是异常失落，或许他的心早已疲惫。 &nbsp;&nbsp; &nbsp;&nbsp;在宿舍里，我安慰老鸟说：“没事，心在足球就在，自由不需要方式。” &nbsp;&nbsp; &nbsp;&nbsp;老鸟头一次点了点头，真的像一只受伤的鸟儿。“我想她了。”他一头扎进我的怀中。 &nbsp;&nbsp; &nbsp;&nbsp;我叹了叹气，我想就我知道他是一个受伤的孩子，他是真心对她的，但是他不会说出口，哪怕到最后分手，哪怕自己受伤，永远不会，他是一个任性的孩子。 &nbsp;&nbsp; &nbsp;&nbsp; “我心很痛，很痛。”老鸟哭了，头一次他自己哭我没陪他，因为这是属于他自己的故事…… &nbsp;&nbsp; &nbsp;&nbsp; 我跑到楼下买了一个二手的低音炮，插上MP3。“想唱点什么歌？”我笑着问。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟掀开头上的被子，无奈地笑着说：“《谁伴我闯荡》。” &nbsp;&nbsp; &nbsp;&nbsp;“前面是哪方/谁伴我闯荡/前路没有指引/若我走上又是窄巷/寻梦像扑火/谁共我疯狂……”低音炮的声音很小，但是我们依旧喉破了喉咙，其实歌声响起的时候世界很安静，老鸟和我都在宁静中流下了寂寞的泪水。 &nbsp;&nbsp; &nbsp;&nbsp; 8月，我们还在工厂里打工，录取结果下来了，我们这群经历过两次高考的孩子竟然异常冲动与恐惧。一大早老鸟就约我去网吧，但是他还说：“你先查吧，我再也经不起打击了。” &nbsp;&nbsp; &nbsp;&nbsp; …… &nbsp;&nbsp; &nbsp;&nbsp; 我被北方一所本科高校录取，专业是我向往的中文系。老鸟说，跑那么远干吗，看来你是没有福气跟我踢球、摇滚了，很不幸啊。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟没有告诉我他的录取结果，只是在我要去上大学的前一个晚上老鸟来送我。 &nbsp;&nbsp; &nbsp;&nbsp; 那晚，老鸟仅仅是穿着一件陈旧的牛仔裤和褶皱的衬衣。突然觉得他的衬衣像是我们过去的回忆，所有无法留住的点滴都将折叠起来。今人兴奋的是老鸟终于背起了吉他。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟笑了笑，他的脸异常干燥，像是野地。“怎么样，我比你早学会了吉他，不用低音炮我也可以自己摇滚了。” &nbsp;&nbsp; &nbsp;&nbsp;我竟有一种说不出的感动，却忘记了我们即将告别，就像今晚的月色，是如此朦胧，如此凄美，引人入醉，醒来却是无限的疼痛。“来首什么歌曲呢？” &nbsp;&nbsp; &nbsp;&nbsp;老鸟很霸道地说：“丫的，你懂个屁，这次我自己弹唱。”他接着说：“只送给你的，一个人。” &nbsp;&nbsp; &nbsp;&nbsp;我没有反驳他，或许在他面前我已经失去了反驳的力量，只要期待着他这个无法结束的故事。 &nbsp;&nbsp; &nbsp;&nbsp; 是达达乐队的《南方》，听到旋律我就知道了，突然发现老鸟的声音很有磁性，仿佛回到高四的教室，那里有排得长长的书;我们躲在厕所里抽烟，哭着唱完了汪峰的歌曲;我们一起在KTV里吼歌，等喉咙快吼破的时候我们一起拼酒;在宿舍吐得一踏糊涂的时候老鸟给我递来热水和毛巾……这些陈旧的往事都将折叠在老鸟褶皱的衬衣上，借着凄凉的月光，竟是如此忧伤，我哭了…… &nbsp;&nbsp; &nbsp;&nbsp;“那里总是很潮湿/那里总是很松软/那里总是很多琐碎事/那里总是红和蓝/就这样一天天浪漫/就这样一天天感叹……南方……”老鸟唱着唱着也哭了，我没有问老鸟将要何去何从，他也只是说了声珍重就离开了。那晚老鸟背着吉他，背着他的摇滚梦离开了，我也离开了南方，可至今依旧感伤…… &nbsp;&nbsp; &nbsp;&nbsp; 我真的摸不清这个故事，我也没法去扮演这个角色了。老鸟离开的时候我仿佛发觉：现实总是背叛想象的。一切就像老鸟的高四，面对着残忍却去选择另一种痛苦，他是被青春遗忘的孤儿，拥有遥不可及的梦，或许，青春的我们都失去了年少的背影。 &nbsp;&nbsp; &nbsp;&nbsp; 之后大学的某个早上，我背起吉他的某个早上，我听到有人在弹唱《南方》:“我第一次恋爱在那里/不知她现在怎么样/我家门前的湖边/这时谁还在流连/时间过得飞快/转眼这些已成回忆/每天都有新的问题/不知何时又会再忆起……” &nbsp;&nbsp; &nbsp;&nbsp;这声音再熟悉不过了，我的眼泪突然哗哗流下，不顾一切跑了过去……]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库原理笔记]]></title>
    <url>%2Fyear%2F03%2F11%2F43793%2F</url>
    <content type="text"><![CDATA[一、概论数据库系统的核心任务是数据处理。数据和信息是数据处理中的两个基本概念。数据是信息的一种表现形式，数据通过能书写的信息编码表示信息。数据管理发展的三个阶段：1.人工管理阶段。2.文件管理阶段。3.数据库管理阶段.数据库系统(DataBase Systems, DBS)是为适应数据处理需要而发展起来的一种较为理想数据处理的核心机构。数据库（DataBase，DB）是指长期存储在计算机内、有组织的、统一管理的相关数据的集合。数据库中存储数据具有“集成的”和“共享的”的特点。数据库管理系统(DataBase Management System, DBMS)为用户或应用程序提供访问数据库的方法，包括数据库的建立、查询、更新及各种数据控制。数据库管理系统的主要功能有以下五个方面：1.数据库的定义功能。2.数据库的操纵功能。3.数据库的保护功能。4.数据库的维护功能。5.数据字典(数据库系统中存放三级结构定义的数据库称为数据字典）。 数据库系统结构为了有效组织、管理数据，提高数据库的逻辑独立性和物理独立性，美国国家标准协会为数据库设计了一个严密的三级模式体系结构,它包括外模式、概念模式和内模式。外模式：外模式又称为子模式或用户模式，是用户与数据库系统的接口，是用户能够看见和使用的局部数据逻辑结构和特征的描述。一个数据库可以有多个外模式。不同需求，外模式描述就不相同。概念模式：概念模式又称为模式或逻辑模式，是数据库中全部数据逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个概念模式，通常一某种数据模型为基础，综合考虑所有用户的需求，并将这些需求有机的结合成一个逻辑整体。内模式：内模式也称为存储模式或物理模式，是对数据物理结构和存储方式的描述，是数据在数据库内部的表示方式，一个数据库只有一个内模式。内模式是数据库最低一级的逻辑描述，它定义所有内部数据类型、索引和文件的组织方式，以及数据控制等方面的细节。两级映像：为了能够实现数据库三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两级映像。外模式/概念模式映像：对于每一个外模式，数据库系统都有一个外模式/概念模式映像，它定义了该外模式与概念模式之间的对应关系。当概念模式改变时，只需要数据库管理员对各个外模式/概念模式映像做相应的改变，就可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序可以不必修改，保证了数据与程序的逻辑独立性。概念模式/内模式映像：该影响是唯一的，它定义了数据库的全局逻辑结构与存储结构之间的对应关系。当数据库的存储结构发生改变时，只需数据库管理员对概念模式/内模式映射做相应的改变，就可以使概念模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性。外模式/概念模式映像一般在外模式中描述，概念模式/内模式映像一般在内模式中描述。 数据模型数据模型（data model)包括数据库数据的结构部分、操作部分和约束条件，它是研究数据库技术的核心和基础。数据处理的三个阶段1.概念模型:也称信息模型，是对现实世界的认识和抽象描述，按用户的观点对数据和信息进行建模。E-R模型是现实世界到数据世界的一个中间层，表示实体及实体间的联系。涉及的基本术语有：1.实体。2.实体集。3.属性。4.实体标识符。 二元关系主要有以下三种情况：1.一对一联系。2.一对多联系。3.多对多联系。在E-R图中用矩形表示现实世界中的实体，用椭圆形表示实体的属性，用菱形表示实体间的联系。2.逻辑模型:逻辑模型是对应于数据世界的模型，是数据库中实体及其联系的抽象描述。传统的逻辑模型有层次模型、网状模型和关系模型三种，非传统的逻辑模型有面向对象模型。逻辑模型中的数据描述有1.字段（标记实体属性的命名单位称为字段）：字段的命名往往和属性名相同。2.记录，字段的有序集合称为记录。3.文件：同一类记录的集合称为文件。4.关键码：能唯一标识文件中每个记录的字段或字段集，称为记录的关键码（简称为键）。3.物理模型，用于描述数据在物理存储介质上的组织结构，与具体的数据库管理系统、操作系统和计算机硬件都有关系。从概念模型到逻辑模型的转换是由数据库设计人员完成的，从逻辑模型到物理模型的转换是由数据库管理系统完成的，一般人员不必考虑物理实现的细节。常见的数据模型：1.层次模型。2.网状模型。3.关系模型。4.面向对象模型。 二、关系型数据库基本理论关系数据模型关系数据结构1.关系模式：每个关系都有一个模式，称为关系模式，由一个关系名及它的所有属性名构成。如关系模式R(A,B,C),也称关系R或关系模式R。关系中属性个数称为“元数”(arity),元组个数称为“基数”(cardinality).在关系模型中，字段称为属性，字段值称为属性值，记录类型称为关系模式。记录称为元组，元组的集合称为关系或实例。一般用前面的大写英语字母A、B、C…表示单个属性，用后面的大写字母W、X、Y、Z表示属性集，用小写字母表示属性值。元组为行，属性为列。关系中每一个属性都有一个取值范围，称为属性的域(domain)。属性A的域用DOM(A)表示。关系具有以下特点：1.关系（表）可以看成是由元组（行）和属性（列）组成的二维表格。它表示一个实体的集合。2.2.表中一行称为一个元组，可用来表示实体集中一个具体的实体。3.表中的列称为属性，给每一列起一个名称即属性名，表中的属性名不能相同。4.列的取值范围称为域，同列具有相同的域，不同列可以有相同域。5.表中任意两个元组（行）不能相同。2.键(key)在关系型数据库中，键也称为码或关键字，它同常由一个或几个属性组成，能唯一地表示一个元组。超键：在一个关系中，能唯一标识元组的属性或属性组称为关系的超键。候选键：如果一个属性组能唯一标识元组，且又不含有多余的属性，那么这个属性组称为关系的候选键。主键(PK)：如果一个关系中有多个候选键，选其中的一个候选键为关系的主键。外键（FK）：若一个关系R中包含有另一个关系S的主键所对应的属性组F，则称F为R的外键。并称关系S为参照关系，关系R为依赖关系。例如：学生关系和学院关系分别为：学生(SNO,SNAME,SEX,AGE,SDNO)学院(SDNO,SDNAME,CHAIR)学生关系的主键为SNO，学院关系的主键为SDNO，在学生关系中，SDNO是他的外键。更确切的说，SDNO是学院表的主键，将它作为外键放在学生表中，实现两个表之间的联系。我们约定，在主键的属性下面加下划线，在外键的属性下面加波浪线。3.关系模式、关系子模式和存储模式关系模型基本上遵循数据库的三级体系结构。在关系模型中，概念模式是关系模式的集合，外模式是关系子模式的集合，内模式是存储模式的集合。1）关系模式， 是对关系的描述，严格来讲，除了应该包含模式名以及组成该关系的诸属性名以外，还应该包含值域名和模式的主键。一个具体的关系称为一个实例。2）关系子模式，有时，用户使用的数据不直接来自一个关系模式中的数据，而是通过外键连接从若干关系模式中抽取满足一定条件的数据，这种结构可用关系子模式实现。关系子模式是用户所需数据结构的描述，其中包括这些数据来自哪些模式和应满足哪些条件。3）存储模式 描述了关系是如何在物理存储设备上存储的。关系存储的基本组织方式是文件。 关系运算关系运算的特点是集合运算模式，即运算的对象和结果都是集合。关系模型中常用的关系运算包括查询(query)、插入(insert)、删除(delete)、更新(update)。查询运算又可以分为选择、投影、连接、除、并、差、交、笛卡儿积等。其中选择、投影、并、差、笛卡儿积是五种基本运算。 关系的完整性约束1.域完整性约束：关系中属性A的值应该是域DOM(A)中的值，并由语义决定其能否取空值(NULL).2.实体完整性约束：若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值。3.参照完整性约束：关系的外键必须是另一个关系主键的有效值或者是空值。需要注意如下两点：1）外键和相应的主键可以不同名，只要定义在相同的域上即可。2）外键的取值是否为空值，应视具体情况而定。如果外键是相应主键的属性，则不允许外键的值为空。4.用户定义完整性约束]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git push失败]]></title>
    <url>%2Fyear%2F03%2F10%2F36673%2F</url>
    <content type="text"><![CDATA[刚才在将本地文件夹上传到github上时出现下面报错12$ git push -u origin masterfatal: unable to access 'https://github.com/hao14293/blogbackup.git/': gnutls_handshake() failed: Error in the pull function. 解决方法1$ git config --global credential.helper store 然后再次1$ git push -u origin master 输入Username Password就完美解决了。]]></content>
      <categories>
        <category>Git and Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[玩转运动世界校园]]></title>
    <url>%2Fyear%2F03%2F10%2F29072%2F</url>
    <content type="text"><![CDATA[本来今天打算写个刷运动世界校园的教程，结果一大早起来发现，用模拟器刷的方法炸了，弄了半天也没解决，这篇文章先放这里，等有方法了再写。]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 安装Eclipse]]></title>
    <url>%2Fyear%2F03%2F10%2F47249%2F</url>
    <content type="text"><![CDATA[配置 java 环境 官方下载jdk(我安装的是jdk1.8.0_161) 创建安装文件夹（我的是 /opt/java)sudo mkdir /opt/java 把下载下来的jdk-8u161-linux-x64.tar.gz 移到 /opt/java 并解压sudo mv /下载/jdk-8u161-linux-x64.tar.gz /opt/java sudo tar -zxvf jdk-8u161-linux-x64.tar.gz 配置环境变量sudo gedit /etc/environment 末尾加入以下配置（JAVA_HOME后的路径就是你jdk的文件位置） PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin" export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export JAVA_HOME=/opt/java/jdk1.8.0_161 修改完后保存关闭，输入下面命令使环境变量生效 source /etc/environment 但这个时候输入java -version发现是下面这样$ java -version程序 ‘java’ 已包含在下列软件包中： default-jre gcj-5-jre-headless openjdk-8-jre-headless gcj-4.8-jre-headless gcj-4.9-jre-headless openjdk-9-jre-headless请尝试：sudo apt install &lt;选定的软件包&gt;这是因为Ubuntu默认安装的有java环境，需要我们再配置以下 sudo update-alternatives –install /usr/bin/java java /opt/java/jdk1.8.0_161/bin/java 300 sudo update-alternatives –install /usr/bin/javac javac /opt/java/jdk1.8.0_161/bin/javac 300 sudo update-alternatives –install /usr/bin/jar jar /opt/java/jdk1.8.0_161/bin/jar 300 sudo update-alternatives –install /usr/bin/javah javah /opt/java/jdk1.8.0_161/bin/javah 300 sudo update-alternatives –install /usr/bin/javap javap /opt/java/jdk1.8.0_161/bin/javap 300 上面命令把每条后半部分地址改为你的jdk地址，/opt/java是我的地址。最后执行这条命令使之生效sudo update-alternatives –config java这个时候再执行java -version javac -version$ java -versionjava version “1.8.0_161”Java(TM) SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)$ javac -versionjavac 1.8.0_161这样就大功告成。 安装 Eclipse 官方下载 解压（我是单独创建了个eclipse文件夹）cd 下载/ sudo mv eclipse-inst-linux64.tar.gz /eclipse tar -zxvf eclipse-inst-linux64.tar.gz 进入文件夹双击eclipse-inst,然后就安装吧。（耐心） 创建快捷方式[Desktop Entry]Encoding=UTF-8Name=EclipseComment=EclipseExec=/home/ubuntu/eclipse/jee-oxygen/eclipse/eclipseIcon=/home/ubuntu/eclipse/jee-oxygen/eclipse/icon.xpmTerminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development;ExecIcon改成你的地址。对该文件进行赋权chmod u+x /usr/share/applications/Eclipse.desktop大功告成。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git 基础教程]]></title>
    <url>%2Fyear%2F03%2F09%2F46251%2F</url>
    <content type="text"><![CDATA[Git 和 Github是同学们经常使用的工具，这里简单写个基础操作教程。 安装GitUbuntu sudo apt-get install git-core Mac OS X如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ Windows在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！安装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name "Your Name" $ git config --global user.email "email@example.com" 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： mkdir learngit cd learngit pwd /home/ubuntu/learngit pwd命令用于显示当前目录。 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： git init 初始化空的 Git 仓库于 /home/ubuntu/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。 把文件添加到版本库 首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用Windows的童鞋要特别注意： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可. 现在我们编写一个readme.txt文件，内容如下： Git is a version control system. Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m "wrote a readme file" [master （根提交） a6ee6ed] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m "xxx"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m "add 3 files." 时光机穿梭 我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： Git is a distributed version control system. Git is free software. 现在，运行git status命令看看结果： $ git status 位于分支 master 尚未暂存以备提交的变更： （使用 "git add ..." 更新要提交的内容） （使用 "git checkout -- ..." 丢弃工作区的改动） 修改： readme.txt 修改尚未加入提交（使用 "git add" 和/或 "git commit -a"） git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： $ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： $ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： $ git status 位于分支 master 要提交的变更： （使用 "git reset HEAD ..." 以取消暂存） 修改： readme.txt git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： $ git commit -m "add distributed" [master ea34578] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： $ git status 位于分支 master 无文件要提交，干净的工作区 Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。 版本回退 git log命令可以查看历史记录 $ git log commit 4e77f2f8aada37a56fda295813a8b40847933dae Author: hao14293 Date: Thu Mar 8 13:07:05 2018 +0800 add commit a6ee6ed74739651569179c5aadc961a2b548a2a9 Author: hao14293 Date: Thu Mar 8 12:54:56 2018 +0800 wrote a readme file 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： $ git log --pretty=oneline 4e77f2f8aada37a56fda295813a8b40847933dae add a6ee6ed74739651569179c5aadc961a2b548a2a9 wrote a readme file 需要友情提示的是，你看到的一大串类似3628164...882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 现在我们准备退回上一个版本 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 现在我们把当前版本回退到上一版本,就可以使用git reset命令： $ git reset --hard HEAD^ HEAD 现在位于 a6ee6ed wrote a readme file --hard参数有啥意义？这个后面再讲，现在你先放心使用. 打开readme.txt，已经回到上一个版本了。 工作区、暂存区和版本库 我们先来理解下Git 工作区、暂存区和版本库概念 * 工作区：就是你在电脑里能看到的目录。 * 暂存区：英文叫stage, 或index。一般存放在 ".git目录下" 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 * 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： ![1.jpg](https://i.loli.net/2018/03/08/5aa0d97ba6186.jpg) 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： $ git status 位于分支 master 尚未暂存以备提交的变更： （使用 "git add ..." 更新要提交的内容） （使用 "git checkout -- ..." 丢弃工作区的改动） 修改： readme.txt 未跟踪的文件: （使用 "git add ..." 以包含要提交的内容） LICENSE 修改尚未加入提交（使用 "git add" 和/或 "git commit -a"） Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： $ git status 位于分支 master 要提交的变更： （使用 "git reset HEAD ..." 以取消暂存） 新文件： LICENSE 修改： readme.txt 现在，暂存区的状态就变成这样了： ![1.jpeg](https://i.loli.net/2018/03/08/5aa0db74a0056.jpeg) 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 $ git commit -m "understand how stage works" [master f9c5b54] understand how stage works 2 files changed, 4 insertions(+), 2 deletions(-) create mode 100644 LICENSE 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： $ git status 位于分支 master 无文件要提交，干净的工作区 现在版本库变成了这样，暂存区就没有任何内容了： ![2.jpeg](https://i.loli.net/2018/03/08/5aa0dbfc271a4.jpeg) Git 基本操作 * git init: 用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。在目录中执行 git init，就可以创建一个 Git 仓库了。 * git clone: 使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 执行命令： git clone [url] [url] 为你想要复制的项目，就可以了。 * git add: git add 命令可将该文件添加到缓存 * git status: git status 以查看在你上次提交之后是否有修改。 * git diff: 执行 git diff 来查看执行 git status 的结果的详细信息。 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 * * 尚未缓存的改动：git diff * * 查看已缓存的改动： git diff --cached * * 查看已缓存的与未缓存的所有改动：git diff HEAD * * 显示摘要而非整个 diff：git diff --stat * git commit: 使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。 * git reset HEAD: git reset HEAD 命令用于取消已缓存的内容。 * git rm: 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。 * * 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作 git rm * * 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f git rm -f * * 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可 git rm --cached 如我们删除 hello.php文件： $ git rm hello.php rm 'hello.php' $ ls README * * 不从工作区中删除文件： $ git rm --cached README rm 'README' $ ls README * * 可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件： git rm –r * 进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。 * git mv: git mv 命令用于移动或重命名一个文件、目录、软连接。 我们先把刚移除的 README 添加回来： $ git add README 然后对其重名: $ git mv README README.md $ ls README.md 远程仓库 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C "youremail@example.com" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。 添加远程库 现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： $ git remote add origin git@github.com:hao14293/learngit.git 请千万注意，把上面的hao14293替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master Counting objects: 19, done. Delta compression using up to 4 threads. Compressing objects: 100% (19/19), done. Writing objects: 100% (19/19), 13.73 KiB, done. Total 23 (delta 6), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new branch] master -> master Branch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ SSH警告 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added 'github.com' (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 从远程库克隆 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： $ git clone git@github.com:hao14293/gitskills.git Cloning into 'gitskills'... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. $ cd gitskills $ ls README.md 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/hao14293/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理 几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为"必杀技特性"，而正是因为它，将 Git 从版本控制系统家族里区分出来。 创建分支命令： git branch (branchname) 切换分支命令: git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 合并分支命令: git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。 列出分支 列出分支基本命令： git branch 没有参数时，git branch 会列出你在本地的分支。 $ git branch * master 此例的意思就是，我们有一个叫做"master"的分支，并且该分支是当前分支。 当你执行 git init 的时候，缺省情况下 Git 就会为你创建"master"分支。 如果我们要手动创建一个分支。执行 git branch (branchname) 即可。 $ git branch testing $ git branch * master testing 现在我们可以看到，有了一个新分支 testing。 当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了"testing"分支，Git 将还原你的工作目录到你创建分支时候的样子 接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 $ ls README $ echo 'runoob.com' > test.txt $ git add . $ git commit -m 'add test.txt' [master 048598f] add test.txt 2 files changed, 1 insertion(+), 3 deletions(-) delete mode 100644 hello.php create mode 100644 test.txt $ ls README test.txt $ git checkout testing Switched to branch 'testing' $ ls README hello.php 当我们切换到"testing"分支的时候，我们添加的新文件test.txt被移除了, 原来被删除的文件hello.php文件又出现了。切换回"master"分支的时候，它们有重新出现了。 $ git checkout master Switched to branch 'master' $ ls README test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 $ git checkout -b newtest Switched to a new branch 'newtest' $ git rm test2.txt rm 'test2.txt' $ ls README test.txt $ git commit -am 'removed test2.txt' [newtest 556f0a0] removed test2.txt 1 file changed, 1 deletion(-) delete mode 100644 test2.txt $ git checkout master Switched to branch 'master' $ ls README test.txt test2.txt 如你所见，我们创建了一个分支，在该分支的上下文中移除了一些文件，然后切换回我们的主分支，那些文件又回来了。 使用分支将工作切分开来，从而让我们能够在不同上下文中做事，并来回切换。 删除分支 删除分支命令： git branch -d (branchname) 例如我们要删除"testing"分支： $ git branch * master testing $ git branch -d testing Deleted branch testing (was 85fc7e7). $ git branch * master 分支合并 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去： git merge $ git branch * master newtest $ ls README test.txt test2.txt $ git merge newtest Updating 2e082b7..556f0a0 Fast-forward test2.txt | 1 - 1 file changed, 1 deletion(-) delete mode 100644 test2.txt $ ls README test.txt 以上实例中我们将 newtest 分支合并到主分支去，test2.txt 文件被删除。 合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。 $ git branch * master $ cat test.txt runoob.com 首先，我们创建一个叫做"change_site"的分支，切换过去，我们将内容改为 www.runoob.com 。 $ git checkout -b change_site Switched to a new branch 'change_site' $ vim test.txt $ head -1 test.txt www.runoob.com $ git commit -am 'changed the site' [change_site d7e7346] changed the site 1 file changed, 1 insertion(+), 1 deletion(-) 将修改的内容提交到 "change_site" 分支中。 现在，假如切换回 "master" 分支我们可以看内容恢复到我们修改前的，我们再次修改test.txt文件。 $ git checkout master Switched to branch 'master' $ head -1 test.txt runoob.com $ vim test.txt $ cat test.txt runoob.com 新增加一行 $ git diff diff --git a/test.txt b/test.txt index 704cce7..f84c2a4 100644 --- a/test.txt +++ b/test.txt @@ -1 +1,2 @@ runoob.com +新增加一行 $ git commit -am '新增加一行' [master 14b4dca] 新增加一行 1 file changed, 1 insertion(+) 现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。 我们将前一个分支合并到 “master” 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。 $ vim test.txt $ cat test.txt www.runoob.com 新增加一行 $ git diff diff --cc test.txt index f84c2a4,bccb7c2..0000000 --- a/test.txt +++ b/test.txt @@@ -1,2 -1,1 +1,2 @@@ - runoob.com + www.runoob.com +新增加一行 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 $ git status -s UU test.txt $ git add test.txt $ git status -s M test.txt $ git commit [master 88afe0e] Merge branch 'change_site' 现在我们成功解决了合并中的冲突，并提交了结果。 标签管理 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 比如说，我们想为我们的 runoob 项目发布一个"1.0"版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）"v1.0"的标签。 -a 选项意为"创建一个带注解的标签"。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 $ git tag -a v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。 现在，注意当我们执行 git log --decorate 时，我们可以看到我们的标签了： $ git log --oneline --decorate --graph * 88afe0e (HEAD, tag: v1.0, master) Merge branch 'change_site' |\ | * d7e7346 (change_site) changed the site * | 14b4dca 新增加一行 |/ * 556f0a0 removed test2.txt * 2e082b7 add test2.txt * 048598f add test.txt * 85fc7e7 test comment from runoob.com 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 85fc7e7 $ git log --oneline --decorate --graph * 88afe0e (HEAD, tag: v1.0, master) Merge branch 'change_site' |\ | * d7e7346 (change_site) changed the site * | 14b4dca 新增加一行 |/ * 556f0a0 removed test2.txt * 2e082b7 add test2.txt * 048598f add test.txt * 85fc7e7 (tag: v0.9) test comment from runoob.com 如果我们要查看所有标签可以使用以下命令： $ git tag v0.9 v1.0 指定标签信息命令： git tag -a -m "runoob.com标签" PGP签名标签命令： git tag -s -m "runoob.com标签" Github …or create a new repository on the command line echo "# test" >> README.md git init git add README.md git commit -m "first commit" git remote add origin https://github.com/hao14293/test.git git push -u origin master …or push an existing repository from the command line git remote add origin https://github.com/hao14293/test.git git push -u origin master git将本地仓库推送到github 1. 首先在本地创建ssh key; $ ssh-keygen -t rsa -C "your_email@youremail.com" 2. 回到github，进入Account Settings，左边选择SSH Keys，Add SSH Key,title随便填，粘贴key。为了验证是否成功，在Git bash下输入： $ ssh -T git@github.com 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。 git config –global user.name “your name”git config –global user.email “your_email@youremail.com“ 进入要上传的仓库，添加远程地址： $ git remote add origin git@github.com:yourName/yourRepo.git(可以去git上复制仓库的地址)4.提交、上传 接下来在本地仓库里添加一些文件，比如README， git add README git commit -m “first commit” 上传到github： $ git push origin mastergit push命令会将本地仓库推送到远程服务器。 git pull命令则相反。]]></content>
      <categories>
        <category>Git and Github</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 程序快捷方式创建方法]]></title>
    <url>%2Fyear%2F03%2F09%2F43744%2F</url>
    <content type="text"><![CDATA[方法很简单，下面以创建Eclipse快捷方式为例。其他程序只需把名字改为对应名字就行。 sudo gedit /usr/share/applications/Eclipse.desktop 复制以下代码： [Desktop Entry] Encoding=UTF-8 Name=Eclipse Comment=Eclipse Exec=/home/ubuntu/eclipse/jee-oxygen/eclipse/eclipse Icon=/home/ubuntu/eclipse/jee-oxygen/eclipse/icon.xpm Terminal=false StartupNotify=true Type=Application Categories=Application;Development; 把Exec和Icon改为你的地址。 最后 sudo chmod u+x Eclipse.desktop]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows10环境下装Ubuntu双系统]]></title>
    <url>%2Fyear%2F03%2F08%2F56114%2F</url>
    <content type="text"><![CDATA[很多入门的小伙伴都想体验一下Linux，但又不舍得Windows,所以就想到了装双系统。我刚开始也是这样，大一开始折腾，虽然网上教程很多，但我第一次仔仔细细地按照教程做，最后还是没能成功，还把Windows上资料给弄没了。这两年也装过不少次系统了，所以今天想写一下教程，按照这个教程请放心安装，一定可以成功。 环境/工具 windows10 U盘（大于4G） Ultraiso ubuntu 16.04 LTS (百度云下载) 耐心 方法/步骤一. 制作Ubuntu 16.04启动盘1.插入用来制作启动盘的U盘（会被格式化，请备份好重要文件），打开UltraISO刻录软件（免费无限期试用）。 2.选择“文件(F)”-&gt;“打开”，找到“Ubuntu-16.04-desktop-amd64.iso”镜像文件，然后点击“打开”。3.选择“启动(B)”-&gt;“写入硬盘映像”，打开启动盘制作界面。4.然后点击下方的“写入”，会弹出警告提示，确定后，就会开始制作启动盘。写入完成后关闭UltraISO软件即可。 这样就制作好了启动盘。 二. 为Ubuntu系统分盘在Windows 10中打开“磁盘管理器”，找一个空闲的磁盘分区，压缩出来一部分空间给Ubuntu使用，压缩出来的硬盘应处于未分配状态。或者通过删除某个不使用的本地磁盘使其处于未分配状态。敲黑板:这个可能有人不太理解，其实很简单，如果你只有C盘，右击选择压缩磁盘，大小就是你要分出来的ubuntu系统的大小，想要好好用linux的同学最好分出大于40G。分出来后这部分是黑色的。 三. [BIOS设置]不同电脑进入BIOS方法不同，一般 F2键和 ESC键的比较多，可以试一下，不行的话可以自己百度。1.关机，重新打开电脑，进入BIOS，关闭Windows系统的快速启动（Fast Boot）选项，即设置为Disable状态。 2.在BIOS中设置U盘为第一启动项，保存并重启电脑。不知道怎么设置的看这里:上图中的Boot Option #1就是第一启动项，按ENTER键和上下键选择你的U盘启动项后ENTER，然后保存后重启。 四. [安装Ubuntu 16.04 LTS] 这时候开机后会看到Try Ubuntu或者Install Ubuntu,选择Try Ubuntu，也就是第一个，Enter。 稍等一会儿进入UbuntuDesktop。 双击左上角的”Install Ubuntu 16.04LTS“，打开安装界面。（安装过程比较简单，根据提示输入一些信息即可）在左侧语言栏选择安装语言，然后点击“继续”。如果网速比较快，可以勾选“安装Ubuntu时下载更新”。（如果选择的语言是中文，这里在更新的时候会自动安装中文输入法，当然也可以安装完成后安装搜狗拼音输入法Linux版）注意注意，重点来了,一定要选择最后一个其他选项,不要有疑问，为了你的Windows安全。接下来要为Ubuntu系统分区，就像Windows下的C、D、E盘。网上有不同的分法，我的使用经验是分三个就行，分别是/boot、/swap和 /。 /boot我是分1G，swap分5G，剩下的全部分给/。我没截到图，图片是网上找的，就是先点分出来标注空闲的那个分区，然后点左下角+号，/boot /swap / 都是在挂载点里面选择。选择逻辑分区。把三个都分好。特别注意,分好后看最下面的安装启动引导器的设备,我第一次错就是在这里，这个要选择/boot 对应的sda，不然会失败。继续shanghai 继续继续名字、密码配好继续耐心等待可以拔掉U盘了，立即重启。如果此时黑屏的话不要紧张，电源键重启，开机后就会看到选择进入系统界面了，第一个就是Ubuntu系统，第三个是Windows，第二个也是Ubuntu，先不用管。然后，好好折腾你的Ubuntu吧！！！]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码暴力破解 '2018年刑侦科推理试题']]></title>
    <url>%2Fyear%2F03%2F07%2F42008%2F</url>
    <content type="text"><![CDATA[据说是2018年刑侦科推理试题，感受一下。 作为一个学渣，瞅一眼头就晕了，那就按老师说的‘不会的就选Ｃ吧’，不过仔细分析一下这题挺有意思的。 正常推理的话是这个样子： 读题知，第五题为核心题目。先假设第五题为A，则2为C,8为A。由8知，2、5、10与1相邻，则1为B。可知第6题排除A B，可知第9题中x与5答案相同，第9题若选A，则6为A不符合；不选C；若选D，矛盾；故9为B。则10为A。第6题排除D，故6为C。第4题为C。第3题为A。至此，选A有4，选C有3，选B有2，则7为D。证毕。(若第五题不为A，应继续假设为其他项证明之) 最后得出答案 BCACACDABA. 对于我这种脑子笨的人来说，推出来也差不多半个小时了。。。 那这题让程序员来做会怎么样呢？ 上代码。 Python def p0(ans, hypo): return True def p1(ans, hypo): if ans == 'A': return hypo[4] == 'C' if ans == 'B': return hypo[4] == 'D' if ans == 'C': return hypo[4] == 'A' if ans == 'D': return hypo[4] == 'B' return None def p2(ans, hypo): if ans == 'A': return hypo[2] != hypo[5] and hypo[2] != hypo[1] and hypo[2] != hypo[3] if ans == 'B': return hypo[5] != hypo[2] and hypo[5] != hypo[1] and hypo[5] != hypo[3] if ans == 'C': return hypo[1] != hypo[2] and hypo[1] != hypo[5] and hypo[1] != hypo[3] if ans == 'D': return hypo[3] != hypo[2] and hypo[3] != hypo[5] and hypo[3] != hypo[1] return None def p3(ans, hypo): if ans == 'A': return hypo[0] == hypo[4] if ans == 'B': return hypo[1] == hypo[6] if ans == 'C': return hypo[0] == hypo[8] if ans == 'D': return hypo[5] == hypo[9] return None def p4(ans, hypo): if ans == 'A': return hypo[4] == hypo[7] if ans == 'B': return hypo[4] == hypo[1] if ans == 'C': return hypo[4] == hypo[8] if ans == 'D': return hypo[4] == hypo[6] return None def p5(ans, hypo): if ans == 'A': return hypo[7] == hypo[1] and hypo[7] == hypo[3] if ans == 'B': return hypo[7] == hypo[0] and hypo[7] == hypo[5] if ans == 'C': return hypo[7] == hypo[2] and hypo[7] == hypo[9] if ans == 'D': return hypo[7] == hypo[4] and hypo[7] == hypo[8] return None def p6(ans, hypo): na, nb, nc, nd = 0, 0, 0, 0 for x in hypo: if x == 'A': na += 1 if x == 'B': nb += 1 if x == 'C': nc += 1 if x == 'D': nd += 1 min_opt = min(na, nb, nc, nd) if ans == 'A': return nc == min_opt if ans == 'B': return nb == min_opt if ans == 'C': return na == min_opt if ans == 'D': return nd == min_opt return None def p7(ans, hypo): x = ord(hypo[0]) if ans == 'A': return abs(x - ord(hypo[6])) != 1 if ans == 'B': return abs(x - ord(hypo[4])) != 1 if ans == 'C': return abs(x - ord(hypo[1])) != 1 if ans == 'D': return abs(x - ord(hypo[9])) != 1 return None def p8(ans, hypo): a = hypo[0] == hypo[5] if ans == 'A': return a != hypo[5] == hypo[4] if ans == 'B': return a != hypo[9] == hypo[4] if ans == 'C': return a != hypo[1] == hypo[4] if ans == 'D': return a != hypo[8] == hypo[4] return None def p9(ans, hypo): na, nb, nc, nd = 0, 0, 0, 0 for x in hypo: if x == 'A': na += 1 if x == 'B': nb += 1 if x == 'C': nc += 1 if x == 'D': nd += 1 delta = max(na, nb, nc, nd) - min(na, nb, nc, nd) if ans == 'A': return delta == 3 if ans == 'B': return delta == 2 if ans == 'C': return delta == 4 if ans == 'D': return delta == 1 return None def test_hypo(problem_list, hypo): index = 0 for p in problem_list: if not p.__call__(hypo[index], hypo): return False index += 1 return True def hypo_generator(size): num = 1 for x in range(size): num *= 4 hypo = [None] * size for i in xrange(num): for j in range(size): hypo[j] = ['A', 'B', 'C', 'D'][(i >> (j < 1)) & 3] yield hypo def main(): problem_list = [p0, p1, p2, p3, p4, p5, p6, p7, p8, p9] for hypo in hypo_generator(len(problem_list)): if test_hypo(problem_list, hypo): print 'Answer:', hypo if __name__ == '__main__': main() 'D'){ return false; } v[i] = c; if (!solve(v, i + 1, 'A') && !solve(v, i, c + 1)) { return false; } const int x = (c - 'A'); switch (i) { case 1: return true; case 2: if (v[5] == "CDAB"[x]) { return true; } break; case 3: { const int w[4] = { 3,6,2,4 }; int j = 0; for (; j < 4; ++j) { if (j != x && v[w[j]] == v[w[x]]) { break; } } if (j >= 4) { return true; } break; } case 4: if (v["1216"[x] - '0'] == v["579:"[x] - '0']) { // '9' + 1 = ':' return true; } break; case 5: if (c == v["8497"[x] - '0']) { return true; } break; case 6: if ((v["2135"[x] - '0'] == v["46:9"[x] - '0']) && (v["2135"[x] - '0'] == v[8])) { return true; } break; case 7: if ("CBAD"[x] - 'A' == stat(v, 'm')) { return true; } break; case 8: if (abs(v["752:"[x] - '0'] - v[1]) > 1) { return true; } break; case 9: if ((v[1] == v[6]) != (v["6:29"[x] - '0'] == v[5])) { return true; } break; case 10: if (("3241"[x] - '0') == stat(v, 'd')) { return true; } break; } return solve(v, i, c + 1); } int main() { const int n = 11; vector v(n); if (solve(v, 1, 'A')) { for (int i = 1; i < n; ++i) { cout < i < ' '; } cout < endl; for (int i = 1; i < n; ++i) { cout < v[i] < ' '; } cout < endl; } }]]></content>
      <categories>
        <category>cool-code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《我》]]></title>
    <url>%2Fyear%2F03%2F02%2F10484%2F</url>
    <content type="text"><![CDATA[我喜欢出发 喜欢离开喜欢一生中都能有新的梦想千山万水 随意行去我喜欢停留 喜欢长久喜欢在园里种下千棵果树期待冬雷夏雨 春华秋实喜欢生命里只有单纯的盼望只有一种安定和缓慢的成长我喜欢岁月漂洗过后的颜色喜欢那没有唱出来的歌我喜欢在夜里写一首长诗然后再来在这清凉的早上逐行逐段地检视慢慢删去每一个与你有着关联的字《我》 － 席慕蓉]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫入门项目]]></title>
    <url>%2Fyear%2F03%2F01%2F33549%2F</url>
    <content type="text"><![CDATA[今天为大家整理了32个Python爬虫项目。 整理的原因是，爬虫入门简单快速，也非常适合新入门的小伙伴培养信心。所有链接指向GitHub，祝大家玩的愉快~ 1、WechatSogou [1]– 微信公众号爬虫。 基于搜狗微信搜索的微信公众号爬虫接口，可以扩展成基于搜狗搜索的爬虫，返回结果是列表，每一项均是公众号具体信息字典。 github地址：https://github.com/Chyroc/WechatSogou 2、DouBanSpider [2]– 豆瓣读书爬虫。 可以爬下豆瓣读书标签下的所有图书，按评分排名依次存储，存储到Excel中，可方便大家筛选搜罗，比如筛选评价人数&gt;1000的高分书籍；可依据不同的主题存储到Excel不同的Sheet ，采用User Agent伪装为浏览器进行爬取，并加入随机延时来更好的模仿浏览器行为，避免爬虫被封。 github地址：https://github.com/lanbing510/DouBanSpider3、zhihu_spider [3]– 知乎爬虫。 此项目的功能是爬取知乎用户信息以及人际拓扑关系，爬虫框架使用scrapy，数据存储使用mongo github地址：https://github.com/LiuRoy/zhihu_spider 4、bilibili-user [4]– Bilibili用户爬虫。 总数据数：20119918，抓取字段：用户id，昵称，性别，头像，等级，经验值，粉丝数，生日，地址，注册时间，签名，等级与经验值等。抓取之后生成B站用户数据报告。 github地址：https://github.com/airingursb/bilibili-user 5、SinaSpider [5]– 新浪微博爬虫。 主要爬取新浪微博用户的个人信息、微博信息、粉丝和关注。代码获取新浪微博Cookie进行登录，可通过多账号登录来防止新浪的反扒。主要使用 scrapy 爬虫框架。 github地址：https://github.com/LiuXingMing/SinaSpider 6、distribute_crawler [6]– 小说下载分布式爬虫。 使用scrapy,Redis, MongoDB,graphite实现的一个分布式网络爬虫,底层存储MongoDB集群,分布式使用Redis实现,爬虫状态显示使用graphite实现，主要针对一个小说站点。 github地址：https://github.com/gnemoug/distribute_crawler 7、CnkiSpider [7]– 中国知网爬虫。 设置检索条件后，执行src/CnkiSpider.py抓取数据，抓取数据存储在/data目录下，每个数据文件的第一行为字段名称。 github地址：https://github.com/yanzhou/CnkiSpider 8、LianJiaSpider [8]– 链家网爬虫。 爬取北京地区链家历年二手房成交记录。涵盖链家爬虫一文的全部代码，包括链家模拟登录代码。 github地址：https://github.com/lanbing510/LianJiaSpider 9、scrapy_jingdong [9]– 京东爬虫。 基于scrapy的京东网站爬虫，保存格式为csv。 github地址：https://github.com/taizilongxu/scrapy_jingdong 10、QQ-Groups-Spider [10]– QQ 群爬虫。 批量抓取 QQ 群信息，包括群名称、群号、群人数、群主、群简介等内容，最终生成 XLS(X) / CSV 结果文件。 github地址：https://github.com/caspartse/QQ-Groups-Spider 11、wooyun_public[11]-乌云爬虫。 乌云公开漏洞、知识库爬虫和搜索。全部公开漏洞的列表和每个漏洞的文本内容存在MongoDB中，大概约2G内容；如果整站爬全部文本和图片作为离线查询，大概需要10G空间、2小时（10M电信带宽）；爬取全部知识库，总共约500M空间。漏洞搜索使用了Flask作为web server，bootstrap作为前端。 https://github.com/hanc00l/wooyun_public 12、spider[12]– hao123网站爬虫。 以hao123为入口页面，滚动爬取外链，收集网址，并记录网址上的内链和外链数目，记录title等信息，windows7 32位上测试，目前每24个小时，可收集数据为10万左右 https://github.com/simapple/spider 13、findtrip [13]– 机票爬虫（去哪儿和携程网）。 Findtrip是一个基于Scrapy的机票爬虫，目前整合了国内两大机票网站（去哪儿 + 携程）。 https://github.com/fankcoder/findtrip 163spider [14] – 基于requests、MySQLdb、torndb的网易客户端内容爬虫 https://github.com/leyle/163spider doubanspiders[15]– 豆瓣电影、书籍、小组、相册、东西等爬虫集 https://github.com/fanpei91/doubanspiders QQSpider [16]– QQ空间爬虫，包括日志、说说、个人信息等，一天可抓取 400 万条数据。 https://github.com/LiuXingMing/QQSpider baidu-music-spider [17]– 百度mp3全站爬虫，使用redis支持断点续传。 https://github.com/Shu-Ji/baidu-music-spider tbcrawler[18]– 淘宝和天猫的爬虫,可以根据搜索关键词,物品id来抓去页面的信息，数据存储在mongodb。 https://github.com/pakoo/tbcrawler stockholm [19]– 一个股票数据（沪深）爬虫和选股策略测试框架。根据选定的日期范围抓取所有沪深两市股票的行情数据。支持使用表达式定义选股策略。支持多线程处理。保存数据到JSON文件、CSV文件。 https://github.com/benitoro/stockholm BaiduyunSpider[20]-百度云盘爬虫。 https://github.com/k1995/BaiduyunSpider Spider[21]-社交数据爬虫。支持微博,知乎,豆瓣。 https://github.com/Qutan/Spider proxy pool[22]-Python爬虫代理IP池(proxy pool)。 https://github.com/jhao104/proxy_pool music-163[23]-爬取网易云音乐所有歌曲的评论。 https://github.com/RitterHou/music-163 jandan_spider[24]-爬取煎蛋妹纸图片。 CnblogsSpider[25]-cnblogs列表页爬虫。 spider_smooc[26]-爬取慕课网视频。 CnkiSpider[27]-中国知网爬虫。 knowsecSpider2[28]-知道创宇爬虫题目。 aiss-spider[29]-爱丝APP图片爬虫。 SinaSpider[30]-动态IP解决新浪的反爬虫机制，快速抓取内容。 csdn-spider[31]-爬取CSDN上的博客文章。 ProxySpider[32]-爬取西刺上的代理IP，并验证代理可用性 作者：一直在水下链接：https://www.jianshu.com/p/39d4b15c05ee來源：简书]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16道Python经典面试题及答案]]></title>
    <url>%2Fyear%2F02%2F26%2F34102%2F</url>
    <content type="text"><![CDATA[随着Python在企业中的应用越来越多，岗位需求越来越大，面试成为了搞定优质职位的快速方式，下面是笔者面试10余家企业总结的面试题，希望对Python从业者有帮助。 1.Python是如何进行内存管理的？ 答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制 一、对象的引用计数机制Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况： 1，一个对象分配一个新名称 2，将其放入一个容器中（如列表、元组或字典） 引用计数减少的情况： 1，使用del语句对对象别名显示的销毁 2，引用超出作用域或被重新赋值 sys.getrefcount( )函数可以获得对象的当前引用计数 多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。 二、垃圾回收 1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。 三、内存池机制 Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。 1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。 3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。 2.什么是lambda函数？它有什么好处? 答：lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数 lambda函数：首要用途是指点短小的回调函数 lambda [arguments]:expression a=lambdax,y:x+y a(3,11) 3.Python里面如何实现tuple和list的转换？ 答：直接使用tuple和list函数就行了，type()可以判断对象的类型 4.请写出一段Python代码实现删除一个list里面的重复元素 答：1,使用set函数，set(list) 2，使用字典函数， =[1,2,4,2,4,5,6,5,7,8,9,0] b={} b=b.fromkeys(a) c=list(b.keys()) c 5.编程用sort进行排序，然后从最后一个元素开始判断 a=[1,2,4,2,4,5,7,10,5,5,7,8,9,0,3] a.sort() last=a[-1] for i inrange(len(a)-2,-1,-1): if last==a[i]: del a[i] else:last=a[i] print(a) 6.Python里面如何拷贝一个对象？（赋值，浅拷贝，深拷贝的区别） 答：赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。 浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）{1,完全切片方法；2，工厂函数，如list()；3，copy模块的copy()函数} 深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）{copy模块的deep.deepcopy()函数} 7.介绍一下except的用法和作用？ 答：try… except… except… [else…] [finally…]执行try下的语句，如果引发异常，则执行过程会跳到except语句。对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。 try下的语句正常执行，则执行else块代码。如果发生异常，就不会执行如果存在finally语句，最后总是会执行。 8.Python中pass语句的作用是什么？ 答：pass语句不会执行任何操作，一般作为占位符或者创建占位程序，while False: pass 9.介绍一下Python下range()函数的用法？ 答：列出一组数据，经常用在for in range()循环中.. 10.如何用Python来进行查询和替换一个文本字符串？ 答：可以使用re模块中的sub()函数或者subn()函数来进行查询和替换，格式： sub(replacement, string[,count=0])（replacement是被替换成的文本，string是需要被替换的文本，count是一个可选参数，指最大被替换的数量） import re p=re.compile(‘blue|white|red’) print(p.sub(‘colour’,’blue socks and red shoes’)) colour socks and colourshoes print(p.sub(‘colour’,’blue socks and red shoes’,count=1)) colour socks and redshoes subn()方法执行的效果跟sub()一样，不过它会返回一个二维数组，包括替换后的新的字符串和总共替换的数量 11.Python里面match()和search()的区别？ 答：re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。 re模块中research(pattern,string[,flags]),在string搜索pattern的第一个匹配值。 print(re.match(‘super’, ‘superstition’).span()) (0, 5) print(re.match(‘super’, ‘insuperable’)) None print(re.search(‘super’, ‘superstition’).span()) (0, 5) print(re.search(‘super’, ‘insuperable’).span()) (2, 7) 12.用Python匹配HTML tag的时候，和有什么区别？ 答：术语叫贪婪匹配( )和非贪婪匹配( )例如: test : test : 13.Python里面如何生成随机数？ 答：random模块随机整数：random.randint(a,b)：返回随机整数x,a&lt;=x&lt;=b random.randrange(start,stop,[,step])：返回一个范围在(start,stop,step)之间的随机整数，不包括结束值。 随机实数：random.random( ):返回0到1之间的浮点数 random.uniform(a,b):返回指定范围内的浮点数。 14.有没有一个工具可以帮助查找python的bug和进行静态的代码分析？ 答：PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告 Pylint是另外一个工具可以进行codingstandard检查 15.如何在一个function里面设置一个全局的变量？ 答：解决方法是在function的开始插入一个global声明： def f(): global x 16.单引号，双引号，三引号的区别 答：单引号和双引号是等效的，如果要换行，需要符号(),三引号则可以直接换行，并且可以包含注释 如果要表示Let’s go 这个字符串 单引号：s4 = ‘Let\’s go’ 双引号：s5 = “Let’s go” s6 = ‘I realy like“python”!’ 这就是单引号和双引号都可以表示字符串的原因了作者：地球的外星人君链接：https://zhuanlan.zhihu.com/p/34124369来源：知乎]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法和数据结构 －－ 初等排序]]></title>
    <url>%2Fyear%2F02%2F21%2F19195%2F</url>
    <content type="text"><![CDATA[排序就是将数据按一定顺序重新排列。它是很多算法的基础，可以让数据变得更容易处理。这篇文章会简单地介绍几种排序算法，当然这是初等排序，在效率上会比较差，但实现起来相对容易。 1. 插入排序法插入排序法是一种很容易想到的算法，它的思路与打扑克时排列手牌的方法很相似。 插入排序法的算法如下： insertionSort(A,N) //包含N个元素的0起点数组A for i从１到N-1 v = A[i] j = i - 1 while j &gt;= 0 且 A[j] &gt; v A[j+1] = A[j] j– A[j+1] = v 请编写一个程序，用插入排序法将包含N个元素的数列A按升序排列。为检验算法的执行过程，请输出个计算步骤的数组。 输入 在第１行输入定义数组长度的整数N。在第２行输入N个整数，以空格隔开。 输出 输出总共有N行。 限制 1 =&lt; N =&lt; 100 0 =&lt; A的元素 =&lt; 1000 C #include &lt;stdio.h&gt; /* 按顺序输出数组元素 */ void trace(int A[], int N){ int i; for(i=0;i&lt;N;i++){ if(i&gt;0) printf(&quot; &quot;); /*相邻元素之间输出１个空格 */ printf(&quot;%d&quot;, A[i]); } printf(&quot;\n&quot;); } /* 插入排序 */ void insertionSort(int A[], int N){ int j, i, v; for(i=1;i&lt;N;i++){ v = A[i]; j=i-1; while(j&gt;=0 &amp;&amp; A[j]&gt;v){ A[j+1] = A[j]; j--; } A[j+1] = v; trace(A,N); } } int main(){ int N, i, j; int A[100]; scanf(&quot;%d&quot;, &amp;N); for(i=0; i &lt; N; i++) scanf(&quot;%d&quot;, &amp;A[i]); trace(A,N); insertionSort(A,N); return 0; } 2. 冒泡排序法顾名思义，冒泡排序法就是让数组元素像水中的气泡一样逐渐上浮，进而达到排序的目的。下述算法便是利用冒泡排序法将数列排为升序的例子。 bubbleSort(A,N) //包含N个元素的0起点数组A flag = 1 while flag flag = 0 for j从N-1到1 if A[j]&lt;A[j-1] A[j]与A[j-1]交换 flag = 1 请编写一个程序，读取数列A，利用冒泡排序法将其按升序排列并输出。另外请报告冒泡排序法执行元素交换的次数。 输入 在第１行输入定义数组长度的整数N。在第2行输入N个整数，以空格隔开。 输出 总计２行。请在第１行输出排序后的数列。相邻元素以一个空格隔开。第２行输出元素交换的次数。 限制 1 =&lt; N =&lt; 100 0 =&lt; A的元素 =&lt; 100 C++ #include &lt;iostream&gt; using namespace std; //使用flag的冒泡排序法 int bubbleSort(int A[], int N){ int sw = 0; bool flag = 1; for(int i=0; flag; i++){ flag = 0; for(int j= N-1; j&gt;=i+1; j--){ if(A[j] &lt; A[j-1]){ swap(A[j], A[j-1]); flag = 1; sw++; } } } return sw; } int main(){ int A[100], N, sw; cin &gt;&gt; N; for( int i=0; i&lt; N; i++) cin &gt;&gt; A[i]; sw = bubbleSort(A,N); for(int i=0; i &lt; N; i++){ if (i) count &lt;&lt; &quot; &quot;; count &lt;&lt; A[i]; } count &lt;&lt; endl; count &lt;&lt; sw &lt;&lt; endl; return 0; } 3.选择排序法选择排序法是一种非常直观的算法，它会在每个计算步骤中选出一个最小值，进而完成排序。 selectionSort(A,N) for i 从0到N-1 minj = i for j从i到N-1 if A[j] &lt; A[minj] minj = j A[i]与A[min]交换 请编写一个程序，读取数列A，利用选择排序法将其按升序排列并输出。请输出实际运行过程中执行交换操作的次数。 输入 在第１行输入定义数组长度的整数N。在第2行输入N个整数，以空格隔开。 输出 总计２行。请在第１行输出排序后的数列。相邻元素以一个空格隔开。第２行输出元素交换的次数。 限制 1 =&lt; N =&lt; 100 0 =&lt; A的元素 =&lt; 100 C #include &lt;stdio.h&gt; /*选择排序法*/ int selectionSort( int A[], int N){ int i,j, t, sw=0, minj; for(i = 0;i &lt; N-1; i++){ minj = i; for(j = i; j&lt; N; j++) { if(A[j] &lt; A[minj] ) minj = j; } t = A[i]; A[i] = A[minj]; A[minj] = t; if (i != minj) sw++; } return sw; } int main(){ int A[100], N, i, sw; scanf(&quot;%d&quot;, &amp;N); for(i=0; i &lt; N; i++) scanf(&quot;%d&quot;, &amp;A[i]); sw = selectionSort(A,N); for(i = 0; i &lt; N; i++){ if( i &gt; 0) printf(&quot; &quot;); printf(&quot;%d&quot;, A[i]); } printf(&quot;\n&quot;); printf(&quot;%d&quot;, A[i]); } printf(&quot;\n&quot;); printf(&quot;%d\n&quot;, sw); return 0; } 4. 稳定排序所谓稳定排序，是指当数据中存在２个或２个以上键值相等的元素时，这些元素在排序处理前后顺序不变。 现在我们来给扑克牌排序。我们使用的扑克牌包含S,H,C,D的４种花色以及１，２，…,9，的９个数字，总计３６张。例如红桃８记为“H８”，方块１记为“D1”。 请编写一个程序，分别用冒泡排序法和选择排序法对输入的N张扑克牌进行以数字为基准的升序排列。两种算法需各自遵循下述伪代码的描述。下述数组元素皆为0起点。 bubbleSort(C,N) for i = 0 to N-1 for j = N-1 downto i+1 if C[j].value &lt; C[j-1].value C[j] 与 C[j-1]交换 selestionSort(C, N) for i = 0 to N-1 minj = i for j = i to N-1 if C[j].value &lt; C[minj].value minj = j C[i] 与 C[minj] 交换 另外，请报告各算法对于所给输入是否有稳定输出。 输入 在第１行输入扑克牌的张数N. 第２行输入N张扑克牌的数据。每张牌由代表花色和数字的２个字符组成，相邻扑克牌之间用１个空格隔开。 输出 在第一行按顺序输出经冒泡排序法排序后的扑克牌，相邻扑克牌之间用１个空格隔开。 在第２行输出该输出是否稳定。 在第3行按顺序输出经选择排序法排序后的扑克牌，相邻扑克牌之间用１个空格隔开。 在第4行输出该输出是否稳定。 限制 1 =&lt; N =&lt; 36C++ #include &lt;iostream&gt; using namespace std; struct Card{ char suit, value;}; void bubble(struct Card A[], int N){ for(int i=0; i&lt;N; i++){ for(int j = N-1; j &gt;= i+1; j--){ if(A[j].value &lt; A[j-1].value){ Card t= A[j]; A[j]=A[j-1]; A[j-1]=t; } } } } void selection(struct Card A[], int N){ for(int i=0; i&lt;N;i++){ int minj = i; for(int j=i; j&lt; N; j++){ if(A[j].value &lt; A[minj].value) minj = j; } Card t = A[i]; A[i] = A[minj]; A[minj] = t; } } void print(struct Card A[], int N){ for (int i=0; i&lt;N; i++){ if(i&gt;0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; A[i].suit&lt;&lt; A[i].value; } cout &lt;&lt; endl; } bool isStable(struct Card C1[], struct Card C2[], int N){ for( int i=0; i&lt; N;i++){ if(C1[i].suit != C2[i].suit) return false; } return true; } int main(){ Card C1[100], C2[100]; int N; char ch; cin &gt;&gt; N;&apos; for( int i=0; i&lt; N;i++){ cin &gt;&gt; C1[i[.suit &gt;&gt; C1[i].value; } for(int i=0; i&lt;N; i++) C2[i] = C1[i]; bubble(C1,N); selection(C2, N); print(C1,N); cout&lt;&lt; &quot;Stable&quot; &lt;&lt; endl; print(C2, N); if( isStable(C1,C2,N){ cout&lt;&lt; &quot;Stable&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;not stable&quot; &lt;&lt; endl; } return 0; } 5. 希尔排序法我们在插入排序法的基础上进一步发挥，将包含ｎ个整数的数列A通过下列程序进行升序排列。 insertionSort(A,n,g) for i = g to n-1 v = A[i] j = i - g while j &gt;= 0 &amp;&amp; A[j] &gt; v A[j+g] = A[j] j = j - g cnt ++ A[j+g] = v shellSort(A,n) cnt = 0 m = ? G[] = {?,?,?,?,…,?} for i = 0 to m-1 insertionSort(A, n, G[i]) insertionSort(A,n,g)是以间隔为g的元素为对象进行的插入排序。shellSort(A,n)则是insertionSort(A,n,g)的循环，并在每轮循环后逐渐缩小g的范围。这种排序方法称为希尔排序法。 C++ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;vector&gt; using namespace std; long long cnt; int l; int A[1000000]; int n; vector&lt;int&gt; G; //指定了间隔g的插入排序 void insertionSort(int A[], int n, int g){ for( int i = g; i&lt; n; i++){ int v = A[i]; int j = i - g; while (j &gt;= 0 &amp;&amp; A[j] &gt; v){ A[j+g] = A[j]; j -= g; cnt++; } A[j+g] = v; } } void shellSort( int A[], int n){ //生成数列 G={1,4,13,40,121,364, 1093,...} for (int h=1; ; ){ if(h &gt; n) break; G.push_back(h); h = 3*h + 1; } for ( int i = G.size()-1; i&gt;= 0; i--){ //按逆序指定G[i] = g insertionSort(A, n, G[i]); } } int main(){ cin &gt;&gt; n; //使用速度更快的scanf函数进行输入 for ( int i=0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;A[i]); cnt = 0; shellSort(A,n); cout &lt;&lt; G.size() &lt;&lt; endl; for( int i= G.size() - 1; i &gt;= 0; i--){ printf(&quot;%d&quot;, G[i]); if(i) printf(&quot; &quot;); } printf(&quot;\n&quot;); printf(&quot;%d\n&quot;, cnt); for ( int i = 0; i &lt; n; i++) printf(&quot;%d\n&quot;, A[i]); return 0; }]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 Socket]]></title>
    <url>%2Fyear%2F02%2F13%2F858%2F</url>
    <content type="text"><![CDATA[1. Socket 基础 Socket原指“孔”或“插座”，它最初作为BSD UNIX的进程通信机制，通常被称作“套接字”。当然，如今Socket已经是Windows和Mac等其他操作系统所共同遵守的网络编程标准，用于描述IP地址和端口，是一个通信连的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。Internet上的主机一般运行了多个服务软件，同时提供几种服务，每种服务都打开一个Socket，并绑定到一个端口上，不用的端口对应不同的服务。 在操作系统结构上，Socket为应用程序屏蔽了TCP/IP网络传输层及以下的网络细节，如图所示。Socket为操作系统的用户空间提供网络抽象，开发者编写的网络程序都会直接或间接地用到Socket抽象。通过Socket抽象可以控制传输层协议TCP和UDP,甚至包括部分网络层协议，例如IP和ICMP。Socket使用IP地址＋端口＋协议的三元组唯一标识一个通信链路。服务器端的一个通信链路可以对应于多个客户端，比如一个Web服务器端的80端口可以同时服务于大量的客户端。 2. 实战演练: Socket TCP 原语 用Socket进行网络开发需了解服务器和客户端的Socket原语，每个原语在不同的高级语言中都有相应的实现方式。TCP的Socket原语如图所示，所有基于TCP的Socket通信都遵循如图所示的流程。下面解释每个原语的含义。socket(): 建立Socket对象。Socket是以类似文件系统的文件系统【打开、读写、关闭】的模式设计的，socket()原语相当于“打开”。socket()原语的参数通常包括使用的传输层协议类型、网络层类型等。 bind(): 绑定。在参数中需要传入要绑定的IP地址和端口。IP地址必须是主机上的一个可用的地址（除了0.0.0.0指定绑定所有的本机IP）。端口必须是一个该Socket协议未被占用的端口，比如当一个主机上的两个程序试图同时绑定到80端口时，只有一个程序能够成功。服务器端程序在listen()之前必须进行bind()操作,而客户端程序如果在connect()原语之前没有调用bind()，则系统会自动为该Socket分配一个未被占用的地址和端口。 技巧: 当主机上存在多个IP时，绑定地址0.0.0.0可以监听所有这些可用的IP。 listen():监听。只在服务器端有用，告诉操作系统开始监听之前绑定的IP地址和端口，可以下参数中指定允许排队的最大连接数量。 connect():在客户端连接服务器。参数中需要指定服务器的地址和端口。调用connect()可能有两种结果，即与服务器端完成TCP３次握手并建立连接或者连接服务器失败。 accept():接受连接。只在服务器端有用，从监听到的连接中取出一个，并将其包装成一个新的Socket对象。这个新的Socket对象可被用于和相应的客户端进行通信。完成accept()标志着Socket已经完成TCP链路建立阶段的3次握手。如果当前没有客户端连接请求，则accept()调用会阻塞等待。 send():发送数据。服务器端和客户端均可调用send()向对方发送数据，在sendI)的参数中传入要发送的数据，通过send()的返回值判断数据是否发送成功。 recv():接收数据。服务器端和客户端均可调用recv()从对方接收数据。如果Socket中没有消息可以读取，则在默认情况下recv()调用会被阻塞直到消息到达；开发者也可以将Socket()设置为非阻塞模式，使recv()以失败形式返回。 close():关闭连接。通信中的任何一方可以调用close()发起关闭连接请求，另一方收到后也可调用close()关闭连接。 【示例】下面通过Python代码演示Socket编程方法，TCP服务器端的代码如下： #!/usr/bin/env python #-- coding: utf-8 -- import socketimport datetime HOST=’0.0.0.0’PORT=3434 #AF_INET说明使用IPV4地址， SOCK_STREAM指明TCPs = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((HOST,PORT))s.listen(1) while True: conn,addr = s.accept() print ‘Client %s connected!’ % str(addr) dt = datetime.datetime.now() message = “Current time is “ + str(dt) conn.send(Sent: “, message conn.close()包socket封装了所有python的原生Socket操作，代码中通过socket(),bind(),listen()的一系列调用实现了对指定端口的监听，通过accept()接受客户端的连接，当有客户端连接成功后将当前系统时间发送给客户端，并马上关闭连接。因为代码主体处于while循环中，所以程序将不断监听并一直运行。 与该服务器端的代码相对应的客户端代码如下： #!/usr/bin/env python #-- coding: utf-8 -- import socket HOST = ‘127.0.0.1’PORT = 3434 #AF_INET说明使用IPV4地址， SOCK_STREAM指明TCP协议 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) print ‘Connect %s:%d OK!’ % (HOST, PORT) data = s.recv(1024) #接受数据，最大长度为1024 print ‘Received: ‘, data s.close()客户端通过connect()调用、连接服务器，连接成功后接收从服务器发来的数据，然后关闭连接、退出程序。 注意：客户端的Socket端口号由系统自动分配。 3.Socket UDP原语UDP相对于TCP在传输层提供更少的控制，没有建立连接、断开连接等概念，所以基于UDP的Socket通信过程也比TCP稍微简单。在UDP中可以直接指定IP:Port进行数据收发。UDP Socket可以复用TCP中的socket()和bind()原语，除此之外，UDP属于自己的Socket原语如下。 recvfrom():从绑定的地址接收数据。 sendto():向指定的地址发送数据，在调用的参数中应该传入通信对端的地址和端口。 【示例】UDP的python服务器端的代码示例如下： #!/usr/bin/env python #-- coding: utf-8 -- import socket HOST = ‘0.0.0.0’PORT = 3434 #AF_INET说明使用IPV4地址， SOCK_DGRAM指明UDPs = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)s.bind() while True(): data, addr = s.recvgrom(1024) print ‘Received: %s’ % (data, str(addr)) s.close()代码通过socket()和bind()调用绑定了本地所有地址的3434端口，通过socket()中的SOCKET_DGRAM指定Socket使用UDP, 在一个循环中不断地接收数据并打印。相应的UDP客户端python代码如下： #!/usr/bin/env python #-- coding: utf-8 -- import socket HOST = ‘127.0.0.1’PORT = 3434 #AF_INET说明使用IPV4地址，socket.SOCK_DGRAM指明UDPs = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) data = “Hello UDP!”s.sendto(data, (HOST, PORT))print “Sent: %s to %s:%d” % (data, HOST, PORT) s.close()]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vultr VPS上搭建Shadowsocks]]></title>
    <url>%2Fyear%2F02%2F07%2F57013%2F</url>
    <content type="text"><![CDATA[作为一个离开Google就没法生活的人，之前也尝试了很多方法。这次自己搭建vpn,也折腾了不少，值得好好记录一下。废话少说，直接进入正题。 1.VPS的选择 可选择的VPS有很多，国内有阿里云、腾讯云，不过随着国内管控越来越严，在国内厂商的VPS上搭建VPN不是一个好的选择(你懂得)。知乎上有个相关话题,需要的可以参考一下。我选择Vultr是因为它便宜，在这里说我也不怕嘲笑，我还是个穷学生，经济问题还是首先要考虑的。可选择的套餐很多，5 $/mon还可以接受。 进入官网后注册登录后还要先充值10，当时我想先充0.01得了，结果人家不傻，最低要10$，也算了，为了我的Google,花点钱也可以学点东西。选择好位置、价格后，其他的默认就行了，然后就可以部署了。 提示：系统最好选择centos 6，方便部署 2.在VPS上部署Shadowsocks首先先登录到VPS上，我系统是Ubuntu 16.04 LTS,直接ssh root@your vps ipaddress ipaddress可以在这里看密码是系统默认生成的，如果需要修改密码，可以参考这个官方教程。 2.1下面开始进入重点，部署Shadowsocks服务端.这里使用 teddysun 的一键安装脚本。 依次输入下面三条命令 wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2>&1 | tee shadowsocks.log 最后一步输完，你应该会看到下图中内容──是要你为 Shadowsocks 服务设置一个个人密码。 设置 ss 密码输好回车后会让你选择一个端口，输入 1-65535 间的数字都行。 设置 ss 端口 遵照上图指示，按任意键开始部署 Shadowsocks。这时你什么都不用做，只需要静静地等它运行完就好。结束后就会看到你所部署的 Shadowsocks 的配置信息。 ss 配置信息记住黄框中的内容，也就是服务器 IP、服务器端口、你设的密码和加密方式。 2.2 TCP Fast Open实际上只要具备上述四个信息，你就可以在自己的任意设备上进行登录使用了。但是为了更好的连接速度，你还需要多做几步。 首先是打开 TCP Fast Open，输入以下命令，意为用 nano 这个编辑器打开一个文件。 nano /etc/rc.local 你的「终端」会刷新一下，出现下图。 别慌张，它就是个文本编辑器。用方向键把光标移到最末端，粘贴下面这一行内容，然后按 Ctrl + X 退出。 echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 输入“Y”并回车确认退出。 然后依法炮制，输入：nano /etc/sysctl.conf 在文末加上下面的内容，保存退出。 net.ipv4.tcp_fastopen = 3 打开一个 Shadowsocks 配置文件。 nano /etc/shadowsocks.json 把其中 “fast_open” 一项的 false 替换成 true。 “fast_open”:true 如果你希望添加多用户的话，可以将 “password” 字段如下图修改。其中，”22345”:”password1”意为该用户使用 22345 端口、以“password1”为密码连接登录 Shadowsocks。 保存退出。最后，输入以下命令重启 Shadowsocks。 /etc/init.d/shadowsocks restart 2.3 安装 Shadowsocks 客户端客户端安装就简单很多了，Android、Win、Mac这里就不再多述了。Linux客户端配置还是很麻烦的，改天再单独写个教程。 3.开启锐速完成上述步骤后，使用过程中可能会发现连接速度有时不太稳定。这就是「锐速」发挥功能的时候了。 3.1 什么是锐速锐速 ServerSpeeder 是一个 TCP 加速软件，对 Shadowsocks 客户端和服务器端间的传输速度有显著提升。而且，不同于 FinalSpeed 或 Kcptun 等需要客户端的工具，「锐速」的一大优势是只需要在服务器端单边部署就行了。换句话说，你不需要再安装另外一个应用。另外，「锐速」虽然已经停止注册和安装了，不过网上还是有不少「破解版」可用。 3.2 部署锐速首先需要用 SSH 登录 VPS。 ssh root@your vps ipaddress 依然使用一键安装脚本，输入以下命令。 wget -N –no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh && bash serverspeeder-all.sh 安装需要一段时间，等待一会。如果出现下图内容，请按提示输入数字。另外，若运行中碰到提示说需要更换内核的话，请参考此文更换之。 安装完成后，输入以下命令打开配置文件。 nano /serverspeeder/etc/config 将 advinacc 的 0 改为 1，保存并退出。 退出「终端」程序。至此，整个搭建过程就大功告成了！接下来，尽情地享受起飞的速度吧😄 需要帮助的话直接联系我。]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>vps</tag>
        <tag>ss</tag>
      </tags>
  </entry>
</search>
